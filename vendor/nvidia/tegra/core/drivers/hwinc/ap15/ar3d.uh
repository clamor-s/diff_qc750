//
// DO NOT EDIT - generated by simspec!
//

#ifndef ___AR3D_UH_INC_
#define ___AR3D_UH_INC_
// --------------------------------------------------------------------------
//
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// could not use GR3DCMD in ar3d.spec because the 3d command packets have a "cmd" field.
// address space reserved for each unit/broadcast space
#define AR3D_ADDRBITS_PER_UNIT  8
// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// ar3d_ctl.spec
// 3D registers that aren't really owned by any blocks (host, stat, clocks, etc.)
// unused channel id guarenteed to be invalid (hardware resets current CTXSW_CHANNEL to this value)
#define AR3D_INVALID_CHANNEL    15
#define NV_AR3D_CTL_INCR_SYNCPT_NB_CONDS        4
// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 

// Register AR3D_CTL_INCR_SYNCPT 
#define LIST_REG_FLD_AR3D_CTL_INCR_SYNCPT(_) \
_(AR3D_CTL,INCR_SYNCPT,COND) \
_(AR3D_CTL,INCR_SYNCPT,INDX)
#define REG_AR3D_CTL_INCR_SYNCPT(_) _(AR3D_CTL,INCR_SYNCPT,0x0,0x0,1,1,0xffff,0x0,NOARY,FLD)
// Condition mapped from raise/wait
#define REG_FLD_AR3D_CTL_INCR_SYNCPT_COND(_) _(AR3D_CTL,INCR_SYNCPT,COND,8,15,8,23,0xff,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_CTL_INCR_SYNCPT_COND(_) \
_(AR3D_CTL,INCR_SYNCPT,COND,IMMEDIATE,0) \
_(AR3D_CTL,INCR_SYNCPT,COND,OP_DONE,1) \
_(AR3D_CTL,INCR_SYNCPT,COND,RD_DONE,2) \
_(AR3D_CTL,INCR_SYNCPT,COND,REG_WR_SAFE,3) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_4,4) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_5,5) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_6,6) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_7,7) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_8,8) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_9,9) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_10,10) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_11,11) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_12,12) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_13,13) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_14,14) \
_(AR3D_CTL,INCR_SYNCPT,COND,COND_15,15)
#define AR3D_CTL_INCR_SYNCPT_COND_IMMEDIATE                     _MK_ENUM_CONST(0)
#define AR3D_CTL_INCR_SYNCPT_COND_OP_DONE                       _MK_ENUM_CONST(1)
#define AR3D_CTL_INCR_SYNCPT_COND_RD_DONE                       _MK_ENUM_CONST(2)
#define AR3D_CTL_INCR_SYNCPT_COND_REG_WR_SAFE                   _MK_ENUM_CONST(3)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_4                        _MK_ENUM_CONST(4)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_5                        _MK_ENUM_CONST(5)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_6                        _MK_ENUM_CONST(6)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_7                        _MK_ENUM_CONST(7)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_8                        _MK_ENUM_CONST(8)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_9                        _MK_ENUM_CONST(9)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_10                       _MK_ENUM_CONST(10)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_11                       _MK_ENUM_CONST(11)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_12                       _MK_ENUM_CONST(12)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_13                       _MK_ENUM_CONST(13)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_14                       _MK_ENUM_CONST(14)
#define AR3D_CTL_INCR_SYNCPT_COND_COND_15                       _MK_ENUM_CONST(15)

// syncpt index value
#define REG_FLD_AR3D_CTL_INCR_SYNCPT_INDX(_) _(AR3D_CTL,INCR_SYNCPT,INDX,8,7,0,23,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_INCR_SYNCPT_INDX(_)


// Register AR3D_CTL_INCR_SYNCPT_CNTRL 
#define LIST_REG_FLD_AR3D_CTL_INCR_SYNCPT_CNTRL(_) \
_(AR3D_CTL,INCR_SYNCPT_CNTRL,INCR_SYNCPT_NO_STALL) \
_(AR3D_CTL,INCR_SYNCPT_CNTRL,INCR_SYNCPT_SOFT_RESET)
#define REG_AR3D_CTL_INCR_SYNCPT_CNTRL(_) _(AR3D_CTL,INCR_SYNCPT_CNTRL,0x1,0x1,1,1,0x101,0x0,NOARY,FLD)
// If NO_STALL is 1, then when fifos are full,
// INCR_SYNCPT methods will be dropped and the
// INCR_SYNCPT_ERROR[COND] bit will be set.
// If NO_STALL is 0, then when fifos are full,
// the client host interface will be stalled.
#define REG_FLD_AR3D_CTL_INCR_SYNCPT_CNTRL_INCR_SYNCPT_NO_STALL(_) _(AR3D_CTL,INCR_SYNCPT_CNTRL,INCR_SYNCPT_NO_STALL,1,8,8,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_INCR_SYNCPT_CNTRL_INCR_SYNCPT_NO_STALL(_)

// If SOFT_RESET is set, then all internal state
// of the client syncpt block will be reset.
// To do soft reset, first set SOFT_RESET of
// all host1x clients affected, then clear all
// SOFT_RESETs.
#define REG_FLD_AR3D_CTL_INCR_SYNCPT_CNTRL_INCR_SYNCPT_SOFT_RESET(_) _(AR3D_CTL,INCR_SYNCPT_CNTRL,INCR_SYNCPT_SOFT_RESET,1,0,0,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_INCR_SYNCPT_CNTRL_INCR_SYNCPT_SOFT_RESET(_)


// Register AR3D_CTL_INCR_SYNCPT_ERROR 
#define LIST_REG_FLD_AR3D_CTL_INCR_SYNCPT_ERROR(_) \
_(AR3D_CTL,INCR_SYNCPT_ERROR,COND_STATUS)
#define REG_AR3D_CTL_INCR_SYNCPT_ERROR(_) _(AR3D_CTL,INCR_SYNCPT_ERROR,0x2,0x2,1,1,0xffffffff,0x0,NOARY,FLD)
// COND_STATUS[COND] is set if the fifo for COND overflows
// This bit is sticky and will remain set until overwritten
// with a zero
#define REG_FLD_AR3D_CTL_INCR_SYNCPT_ERROR_COND_STATUS(_) _(AR3D_CTL,INCR_SYNCPT_ERROR,COND_STATUS,32,31,0,23,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_INCR_SYNCPT_ERROR_COND_STATUS(_)

// reserve locations for future expansion
// just in case names were redefined using macros
//
// INTR_STATS maintains a vector of interrupt sources which are currently signaling to the host (level sensitive)
//
// CTXSW_INT:
// When setup receives a context switch, it first compares the channel_id (that came along with the context
// switch request) against the active channel_id.  If the two channel_ids are the same -or- CTXSW_INT_EN is
// DISABLE, it sends an ACK back to the host acknowledging the context switch immediately. If the channel_ids
// are different -and- CTXSW_INT_EN is ENABLE, setup asserts an interrupt to the CPU and waits for the CPU to
// store the current context's state (assuming it is valid) and restore the new context's state (assuming it
// is valid). The CPU then writes the CTXSW_CHANNEL LAST field with the NEXT field's value to cause a CTXSW_ACK
// to be sent to the host, restarting DMA input to the new channel.
//

// Register AR3D_CTL_INTSTATUS 
#define LIST_REG_FLD_AR3D_CTL_INTSTATUS(_) \
_(AR3D_CTL,INTSTATUS,CTXSW_INT)
#define REG_AR3D_CTL_INTSTATUS(_) _(AR3D_CTL,INTSTATUS,0x8,0x8,1,1,0x1,0x0,NOARY,FLD)
// context switch interrupt status (clear on write)
#define REG_FLD_AR3D_CTL_INTSTATUS_CTXSW_INT(_) _(AR3D_CTL,INTSTATUS,CTXSW_INT,1,0,0,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_INTSTATUS_CTXSW_INT(_)


// Register AR3D_CTL_INTENABLE 
#define LIST_REG_FLD_AR3D_CTL_INTENABLE(_) \
_(AR3D_CTL,INTENABLE,CTXSW_INT)
#define REG_AR3D_CTL_INTENABLE(_) _(AR3D_CTL,INTENABLE,0x9,0x9,1,1,0x1,0x0,NOARY,FLD)
// context switch interrupt enable
#define REG_FLD_AR3D_CTL_INTENABLE_CTXSW_INT(_) _(AR3D_CTL,INTENABLE,CTXSW_INT,1,0,0,3,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_CTL_INTENABLE_CTXSW_INT(_) \
_(AR3D_CTL,INTENABLE,CTXSW_INT,DISABLE,0) \
_(AR3D_CTL,INTENABLE,CTXSW_INT,ENABLE,1)
#define AR3D_CTL_INTENABLE_CTXSW_INT_DISABLE                    _MK_ENUM_CONST(0)
#define AR3D_CTL_INTENABLE_CTXSW_INT_ENABLE                     _MK_ENUM_CONST(1)

// Context switch register.  Should be common to all modules.  Includes the
// current channel/class (which is writable by SW) and the next channel/class
// (which the hardware sets when it receives a context switch).
// Context switch works like this:
// Any context switch request triggers an interrupt to the host and causes the
// new channel/class to be stored in NEXT_CHANNEL/NEXT_CLASS (see
// vmod/chexample).  SW sees that there is a context switch interrupt and does
// the necessary operations to make the module ready to receive traffic from
// the new context.  It clears the context switch interrupt and writes
// CURR_CHANNEL/CLASS to the same value as NEXT_CHANNEL/CLASS, which causes a
// context switch acknowledge packet to be sent to the host.  This completes
// the context switch and allows the host to continue sending data to the
// module.
// Context switches can also be pre-loaded.  If CURR_CLASS/CHANNEL are written
// and updated to the next CLASS/CHANNEL before the context switch request
// occurs, an acknowledge will be generated by the module and no interrupt will
// be triggered.  This is one way for software to avoid dealing with context
// switch interrupts.
// Another way to avoid context switch interrupts is to set the AUTO_ACK bit.
// This bit tells the module to automatically acknowledge any incoming context
// switch requests without triggering an interrupt.  CURR_* and NEXT_* will be
// updated by the module so they will always be current.

// Register AR3D_CTL_CTXSW 
#define LIST_REG_FLD_AR3D_CTL_CTXSW(_) \
_(AR3D_CTL,CTXSW,CURR_CLASS) \
_(AR3D_CTL,CTXSW,AUTO_ACK) \
_(AR3D_CTL,CTXSW,CURR_CHANNEL) \
_(AR3D_CTL,CTXSW,NEXT_CLASS) \
_(AR3D_CTL,CTXSW,NEXT_CHANNEL)
#define REG_AR3D_CTL_CTXSW(_) _(AR3D_CTL,CTXSW,0xa,0xa,1,1,0xf3fffbff,0xf000f800,NOARY,FLD)
// Current working class
#define REG_FLD_AR3D_CTL_CTXSW_CURR_CLASS(_) _(AR3D_CTL,CTXSW,CURR_CLASS,10,9,0,23,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_CTXSW_CURR_CLASS(_)

// Automatically acknowledge any incoming context switch requests
#define REG_FLD_AR3D_CTL_CTXSW_AUTO_ACK(_) _(AR3D_CTL,CTXSW,AUTO_ACK,1,11,11,3,0x1,0x1,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_CTL_CTXSW_AUTO_ACK(_) \
_(AR3D_CTL,CTXSW,AUTO_ACK,MANUAL,0) \
_(AR3D_CTL,CTXSW,AUTO_ACK,AUTOACK,1)
#define AR3D_CTL_CTXSW_AUTO_ACK_MANUAL                  _MK_ENUM_CONST(0)
#define AR3D_CTL_CTXSW_AUTO_ACK_AUTOACK                 _MK_ENUM_CONST(1)

// Current working channel, reset to 'invalid'
#define REG_FLD_AR3D_CTL_CTXSW_CURR_CHANNEL(_) _(AR3D_CTL,CTXSW,CURR_CHANNEL,4,15,12,19,0xf,0xf,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_CTXSW_CURR_CHANNEL(_)

// Next requested class
#define REG_FLD_AR3D_CTL_CTXSW_NEXT_CLASS(_) _(AR3D_CTL,CTXSW,NEXT_CLASS,10,25,16,1,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_CTXSW_NEXT_CLASS(_)

// Next requested channel
#define REG_FLD_AR3D_CTL_CTXSW_NEXT_CHANNEL(_) _(AR3D_CTL,CTXSW,NEXT_CHANNEL,4,31,28,1,0xf,0xf,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_CTXSW_NEXT_CHANNEL(_)

// --------------------------------------------------------------------------
//
// Copyright (c) 2006, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
//
// STAT - statistics gathering control registers
//
// There are NV_GR3D_NUM_STAT_SETS independent sets of statistics counters.
// Each counter set collects information from a specified probe point about
// how many clocks have elapsed while counting was active, how many transfers
// happened (typically this means the downstream block was ready and the
// upstream block had valid data), how many clocks were spent waiting
// (typically this means the upstream block  had valid data available at its
// output but the downstream block was stalled), and how many times collection
// itself was enabled. Counters are controlled from two places, the STAT[]
// register's EN field and the last value of the global INSTRUMENT register's
// STAT_EN field which was seen passing the probe point (this could be used
// to track mode changes, e.g. if you think an app is toggling blending on
// and off too often instead of sorting by rendering mode, you can add a hook
// into the driver to enable INSTRUMENT STAT_EN only when blending is enabled,
// and then count the number of times you see it toggling inside the pipe.
// In combination with the pixel count being collected, you can see if the
// average length that a mode is enabled for seems efficient or not, i.e.
// pixels / times enabled == size of batches of pixels between mode changes,
// independent of how many triangles were sent).
//
// The STAT[i] register is written (through the command buffer) to control
// which statistics are being gathered. EN is used as a master gate to enable
// counting in conjunction with the last value of the STAT_EN field of the
// INSTRUMENT register which flowed past the probe point. BLK selects which
// point a given set of counters will be monitoring.
//
// Typical operation would be enable STAT[].EN, send an
// INSTRUMENT register down the pipeline (possibly correlated with API mode settings
// such as blend mode, etc.) with the STAT_EN field set, wait for rendering to
// complete and read back the counters. It is also possible to read the counters
// as they are actively counting, but be aware that counts read this way will not
// be atomic across the entire set. Also be aware that writing STAT[].EN through
// the command buffer is asynchronous to the read path, so flushing the command
// buffer is necessary if precise counts are desired.
//
// The _COUNT registers are read-write.  They can be context-switched if necessary.
// To reset the counter values, write a zero to them.
//
// ====== STAT PROBE POINT DOCUMENTATION ======
//
// The following table documents the use of the stat probe points.  In order to
// reduce needless repetition, the following rules apply:
//
// 1) If not otherwise noted, the STEN probe point counts the number of clocks that
//    the local copy of STAT_EN was enabled for that probe point.  This means that
//    the CLK_COUNT register will have the number of clocks that the stat was
//    enabled as seen by that probe point (and the EN_COUNT will have the number
//    of times STAT_EN was enabled).  Some probe points reuse the STEN signal to
//    communicate other information, which will be noted in the table.  For these
//    probe points, the EN_COUNT counter usually does not provide useful information.
//
// 2) If .XFER or .WAIT is omitted, then that signal isn't used by that probe point.
//
// 3) Some probe points measure traffic on bus interfaces between the modules.  For
//    these probe points, the probe signals are defined as follows:
//      XFER: number of transfers on that bus (upstream valid, downstream not stalled).
//      WAIT: number of stalls due to downstream busy (upstream valid, downstream stalled).
//      STEN: number of clocks that stat collection was enabled (STEN_EN = 1)
//    These probe points will be marked as BUS in the table below.
//
// 4) Some probe points redefine the three signals to count something that can increment
//    more than once per clock, like a count of bytes.  These probe points encode the
//    total count via the three signals by scaling the three counters.  For these signals,
//    software should gather the final count with
//      total = XFER_COUNT + 2 * WAIT_COUNT + 4 * CLK_COUNT
//    These probe points will be marked with TOTAL in the table below.
//
// 5) Some probe points come in pairs, for example VPE_THREAD0 and VPE_THREAD1.  These
//    are usually identical except for being duplicated.  In this instance, they correspond
//    to the two VPE threads.  In other instances, such as the FDC request busses, they
//    correspond to the ability to issue multiple requests in a single clock.  Typically,
//    these counters are uninteresting singly, and software must sum their values to
//    get an aggregate count.  For example, to see how many memory cache line read requests
//    QRAST made to FDC for Z, you would need to compute FDC_QZRD0.XFER + FDC_QZRD1.XFER.
//    These probe points will be marked by name as FDC_QZRD[01].  It should be understood
//    that this corresponds to two probe points that are meant to be accumulated as one.
//    Note that not all probe points that end with a number are necessarily meant to be
//    used this way, only ones marked as such below.
//
// 6) The notes below are somewhat terse - for example, VPE_INSTISSUE.XFER is described
//    as "instructions issued".  It should be inferred that this is a count of VPE
//    instructions issued (since this is a VPE stat).  Also in general, the words
//    "number of" have been removed from the descriptions.
//
// Probe point      Signal  Function
// ===========      ======  ========
// IDX_HRD:               : BUS host2idx (inbound host bus)
// IDX_HWR:               : BUS idx2host (outbound host bus)
// IDX_MEMRDREQ      .XFER: mem read line requests
//                   .WAIT: clocks waiting to issue mem request
// IDX_MEMRDRET      .XFER: mem read lines returned
//                   .WAIT: clocks stalled on mem read return
// IDX_DMAACC        .XFER: DMA cache accesses
//                   .WAIT: DMA cache misses
// IDX_IDXFETCH      .XFER: indices fetched
//                   .WAIT: clocks stalled on index fetch
// IDX_IDXLINES      .XFER: lines of memory fetched for indices
//                   .WAIT: clocks stalled on mem return for indices
// IDX_IDXCOUNTS     .XFER: 8-bit indices fetched
//                   .WAIT: 16-bit indices fetched
//                   .STEN: 32-bit indices fetched
// IDX_VTXFETCH      .XFER: vertices fetched
//                   .WAIT: clocks stalled on vertex fetch
// IDX_VTXWORDS           : TOTAL number of DWORDs of vertex data fetched
// IDX_VTXCACHE      .XFER: vertex cache accesses (or vertex count)
//                   .WAIT: vertex cache misses (or transform count)
// IDX_VTXSTALL      .XFER: clocks stalled because ibufs busy
//                   .WAIT: clocks stalled because obufs busy
// IDX_PRIMSTALL     .XFER: clocks stalled because prim fifo full
//                   .WAIT: clocks stalled because transform not ready
// IDX_PRIMS         .XFER: primitives (points + lines + tris)
//                   .WAIT: DRAW_PRIM commands
// IDX_POINTS        .XFER: points
//                   .WAIT: point DRAW_PRIM commands
// IDX_LINES         .XFER: lines
//                   .WAIT: line DRAW_PRIM commands
// IDX_TRIS          .XFER: triangles
//                   .WAIT: triangle DRAW_PRIM commands
// VPE_CLIPATADR     .XFER: attribute reads from clip
//                   .WAIT: attribute loads from idx
// VPE_INSTISSUE     .XFER: instructions issued
//                   .WAIT: clocks running but stalled
// VPE_STALL         .XFER: clocks of data stall
//                   .WAIT: clocks of other stall
// VPE_THREAD[01]    .XFER: threads run (n = thread_id)
//                   .WAIT: clocks waiting to launch thread (n = thread_id)
// CLIP                   : BUS idx2clip (clip primitive input)
// CLIP_QRETIRE      .XFER: trangles retired from qrast
//                   .WAIT: clocks waiting for tram
// CLIP_VPE          .XFER: transforms finished
// CLIP_ATRD         .XFER: attribute reads
// CLIP_TRIVREJ      .XFER: trivially-rejected triangles
//                   .WAIT: trivially-rejected lines
//                   .STEN: trivially-rejected points
// CLIP_DEGEN        .XFER: degenerate triangles
//                   .WAIT: degenerate lines
// CLIP_ZEROAREA     .XFER: zero-area triangles
//                   .WAIT: zero-area lines
//                   .STEN: zero-area points
// CLIP_REJECT       .XFER: clipped-away triangles
//                   .WAIT: clipped-away lines
//                   .STEN: clipped-away points
// CLIP_CULL         .XFER: face-culled triangles
//                   .WAIT: clip-generated face-culled triangles
// CLIP_NEWTRI       .XFER: new triangles generated by clipping
//                   .WAIT: triangles requiring clipping
// CLIP_NEWLINE      .XFER: new lines generated by clipping
//                   .WAIT: lines requiring clipping
// CLIP_LR           .XFER: left edges clipped
//                   .WAIT: right edges clipped
// CLIP_TB           .XFER: top edges clipped
//                   .WAIT: bottom edges clipped
// CLIP_NF           .XFER: near edges clipped
//                   .WAIT: far edges clipped
// CLIP_UC           .XFER: user clip edges clipped (SC25/AP15 only)
// SETUP_COV              : BUS clip2setup_cov
// SETUP_Z                : BUS clip2setup_z
// QRAST_SRDAT[01]        : BUS fdc2qrast_s[01]_rdat (stencil half-lines read)
// QRAST_SB          .XFER: quad scoreboard clears
//                   .WAIT: fully-covered quad scoreboard clears
// QRAST_VRDAT[01]        : BUS fdc2qrast_v[01]_rdat (vcaa half-lines read)
// QRAST_ZRDAT[01]        : BUS fdc2qrast_z[01]_rdat (depth half-lines read)
// QRAST_PSEQ             : BUS pseq2qrast (pseq input from qrast)
// QRAST                  : BUS setup2qrast (qrast input from setup)
// QRAST_SBPIX       .XFER: scoreboarded quads
//                   .WAIT: clocks stalled on scoreboard
// QRAST_QZCULL      .XFER: quads
//                   .WAIT: quads fully depth culled
// QRAST_QZKILL      .XFER: quads
//                   .WAIT: quads guard-band culled
// QRAST_QSCULL      .XFER: quads
//                   .WAIT: quads fully stencil culled
// QRAST_QVCULL      .XFER: quads
//                   .WAIT: quads fully non-center-covered quads (vcaa update)
// QRAST_COARSE      .XFER: corse quad lines processed
//                   .WAIT: empty quad lines (coarse dead clocks)
// QRAST_FINE        .XFER: coarse valid, fine not ready
//                   .WAIT: coarse not valid, fine ready
// QRAST_CACHE[01]   .XFER: count of qrast fetches for row 0 (n=col) (not particularly useful)
//                    WAIT: count of qrast fetches for row 1 (n=col) (not particularly useful)
//                    STEN: count of qrast fetches for row 2 (n=col) (not particularly useful)
// QRAST_PRIMS       .XFER: primitives
//                   .WAIT: culled primitives
// QRAST_FLUSH       .XFER: register/pixel boundaries
//                   .WAIT: output fifo empty flushes (synthesized PSEQ_FLUSH)
// PSEQ_DWR               : BUS dwr2pseq (recirculation) (untested)
// PSEQ_RDAT              : BUS fdc2pseq_[01]_rdat (half-lines read) (untested)
// PSEQ_RDATCMD      .XFER: non-pixel-related memory traffic (untested)
// PSEQ                   : BUS qrast2pseq (pseq input)
// PSEQ_QPKT         .XFER: register packets from qrast
//                   .WAIT: live pixels from qrast
//                   .STEN: non-center pixels from qrast
// PSEQ_QZS          .XFER: Z_FAIL pixels from qrast
//                   .WAIT: S_FAIL pixels from qrast
//                   .STEN: killed pixels from qrast
// PSEQ_PKT          .XFER: total register packets
//                   .WAIT: total live pixels
//                   .STEN: total killed pixels
// PSEQ_ZS           .XFER: total Z_FAIL pixels
//                   .WAIT: total S_FAIL pixels
//                   .STEN: total killed pixels
// PSEQ_NOP          .XFER: recirculated killed pixels
//                   .WAIT: recirculated conditionally non-executed pixels
//                   .STEN: early-killed recirculated quads
// PSEQ_CMD0         .XFER: clocks executing pixel packets
//                   .WAIT: clocks waiting on gather
//                   .STEN: clocks doing immediate writes
// PSEQ_CMD1         .XFER: gather mem requests
//                   .WAIT: fill requests
//                   .STEN: brances executed
// PSEQ_LOAD         .XFER: LD instructions
//                   .WAIT: R20 instructions
//                   .STEN: R80 instructions
// PSEQ_FETCH        .XFER: total pixels with LD instructions
//                   .WAIT: killed pixels with LD instructions and READ_KILLED
//                   .STEN: non-center pixels with LD instructions and READ_NON_CENTER
// PSEQ_FETCHNOEX    .XFER: total pixels with LD instructions and NO_EXECUTE
//                   .WAIT: killed pixels with LD instructions, READ_KILLED and NO_EXECUTE
//                   .STEN: non-ceenter pixels with LD instructions, READ_NON_CENTER and NO_EXECUTE
// PSEQ_CACHE        .XFER: instructions with CACHE_PERSISTENT
//                   .WAIT: gathers with CACHE_PERSISTENT
// PSEQ_RECIRC0      .XFER: high-water-mark events (MAX_OUT hit)
//                   .WAIT: recirc stalls due to MIN_OUT
//                   .STEN: flushes due to register write
// PSEQ_RECIRC1      .XFER: clocks recirc path stalled
//                   .WAIT: clocks recirc path stalled with no qrast input
//                   .STEN: clocks recirc path stalled while PSEQ command drains
// PSEQ_RECIRC2      .XFER: recirc caused by QUAD_ID aliasing
//                   .WAIT: clocks stalled by QUAD_ID aliasing
// PSEQ_EPOCH        .XFER: number of fills executed (number of epochs)
//                   .WAIT: PC writes from QRAST (number of shader bindings)
// PSEQ_REQWAIT      .XFER: clocks waiting for instruction mem req issue
//                   .WAIT: clocks waiting for gather mem req issue
//                   .STEN: clocks waiting for fill mem req issue
// PSEQ_RETWAIT      .XFER: clocks waiting for instruction mem read return
//                   .WAIT: clocks waiting for gather mem read return
//                   .STEN: clocks waiting for fill mem read return
// ATRAST_TRAM            : BUS clip2atrast_tram (untested)
// ATRAST_TOP             : BUS pseq2atrast (atrast input) (untested)
// ATRAST_BOT             : BUS atrast2tex (atrast output) (untested)
// ATRAST_SLOPE           : BUS setup2atrast_slopes (untested)
// TEX                    : unimplemented
// TEX_MEMRDREQ      .XFER: mem read line requests
//                   .WAIT: clocks waiting to issue mem request
// TEX_MEMRDRET      .XFER: mem read lines returned
//                   .WAIT: clocks stalled on mem read return
// TEX_CACHEACC           : TOTAL lines of cache access
// TEX_CACHEMISS          : TOTAL lines of cache miss
// TEX_FETCH         .XFER: pixels with texture ops
//                   .WAIT: pixels fetching textures
//                   .STEN: killed pixels fetching textures
// TEX_FETCHNOEX     .XFER: pixels with texture ops and NO_EXECUTE
//                   .WAIT: pixels that would have fetched textures but for NO_EXECUTE
//                   .STEN: killed pixes that would have fetched textures but for NO_EXECUTE
// TEX_FILTER0       .XFER: pixels fetching textures
//                   .WAIT: bilerps (or nearest) performed
//                   .STEN: quads trilinear optimized
// TEX_FILTER1       .XFER: magnified texture ops
//                   .WAIT: pixels fetching texture with aniso
//                   .STEN: aniso bilerps performed
// TEX_LODHIST0      .XFER: level 0 bilerps
//                   .WAIT: level 1 bilerps
//                   .STEN: level 2 bilerps
// TEX_LODHIST1      .XFER: level 3 bilerps
//                   .WAIT: level 4 bilerps
//                   .STEN: level 5 and greater bilerps
// TEX_ANISOHIST0    .XFER: 1x aniso (not including aniso-disabled) bilerps
//                   .WAIT: 2x aniso bilerps
//                   .STEN: 3x aniso bilerps
// TEX_ANISOHIST1    .XFER: 4x-5x aniso bilerps
//                   .WAIT: 6x-9x aniso bilerps
//                   .STEN: 10x and greater bilerps
// TEX_ANISOFINE0    .XFER: fine 1x aniso (not including aniso-disabled) bilerps
//                   .WAIT: fine 2x aniso bilerps
//                   .STEN: fine 3x aniso bilerps
// TEX_ANISOFINE1    .XFER: fine 4x-5x aniso bilerps
//                   .WAIT: fine 6x-9x aniso bilerps
//                   .STEN: fine 10x and greater bilerps
// TEX_LATHIDE       .XFER: cycles stalled on pix packet latency-hiding fifo (light testing)
//                   .WAIT: cycles stalled on mem latency-hiding fifo (light testing)
// TEX_PERFDEG       .XFER: bubbles inserted during 128b to 256b mem return expansion (light testing)
// ALU_BOT                : BUS alu2dwr (alu output)
// ALU_TOP                : BUS tex2alu (alu input)
// DWR                    : unimplemented
// DWR_STORE         .XFER: ST instructions (not including ST_R20, ST_R80)
//                   .WAIT: ST_R20 instructions
//                   .STEN: ST_R80 instructions
// DWR_WRITE         .XFER: pixels with ST instructions (not including ST_R20, ST_R80)
//                   .WAIT: pixels with ST_R20 instructions
//                   .STEN: pixels with ST_R80 instructions
// DWR_WRITENOEX     .XFER: pixels with ST instructions and NO_EXECUTE
//                   .WAIT: pixels with ST_R20 instructions and NO_EXECUTE
//                   .STEN: pixels with ST_R80 instructions and NO_EXECUTE
// DWR_SPILL         .XFER: pixel packets spilled
//                   .WAIT: clocks waiting for spill request grant
// DWR_FLUSH         .XFER: flushes issued to fdc
//                   .WAIT: clocks waiting for flush
// DWR_LATEOPS       .XFER: stencil ops performed (incl non-written packets)
//                   .WAIT: logic ops performed (incl non-written packets)
// DWR_CACHE         .XFER: ST instructions with CACHE_PERSISTENT
//                   .WAIT: ST instructions with CACHE_READ_CLEAN
// FDC_DWR[01]            : BUS dwr2fdc_[01]_wreq (dwr write requests to fdc)
// FDC_IMEMRDREQ     .XFER: internal mem read line requests
//                   .WAIT: internal mem read requests rejected
//                   .STEN: internal mem read data lines returned
// FDC_EMEMRDREQ     .XFER: external mem read line requests
//                   .WAIT: external mem read requests rejected
//                   .STEN: external mem read data lines returned
// FDC_IMEMWRREQ     .XFER: internal mem write line requests
//                   .WAIT: internal mem write requests rejected
//                   .STEN: internal mem write lines confirmed
// FDC_EMEMWRREQ     .XFER: external mem write line requests
//                   .WAIT: external mem write requests rejected
//                   .STEN: external mem write lines confirmed
// FDC_PSEQ[01]           : BUS pseq2fdc_[01]_rreq (pseq read request to fdc)
// FDC_SBPSEQ             : BUS pseq2fdc_sb (scoreboard packet from pseq)
// FDC_QSRD[01]           : BUS qrast2fdc_s[01]_rreq (qrast stencil read req to fdc)
// FDC_QSWR[01]           : BUS qrast2fdc_s[01]_wreq (qrast stencil write req to fdc)
// FDC_SBQRAST            : BUS qrast2fdc_sb (scoreboard packet from qrast)
// FDC_QVRD[01]           : BUS qrast2fdc_v[01]_rreq (qrast vcaa read req to fdc)
// FDC_QVWR[01]           : BUS qrast2fdc_v[01]_wreq (qrast vcaa write req to fdc)
// FDC_QZRD[01]           : BUS qrast2fdc_z[01]_rreq (qrast depth read req to fdc)
// FDC_QZWR[01]           : BUS qrast2fdc_z[01]_wreq (qrast depth write req to fdc)
// FDC_L2RD[0123]    .XFER: L2 lines read by non-mc clients from bank n (=0..3)
//                   .WAIT: clocks with one client stalled on bank n (=0..3) read
//                   .STEN: clocks with two or more clients stalled on bank n (=0..3) read
// FDC_L2RD[4567]         : as above, but for banks (4..7) (only SC25/AP15)
// FDC_L2WR[0123]    .XFER: L2 lines written by non-mc clients from bank n (=0..3)
//                   .WAIT: clocks with one client stalled on bank n (=0..3) write
//                   .STEN: clocks with two or more clients stalled on bank n (=0..3) write
// FDC_L2WR[4567]         : as above, but for banks (4..7) (only SC25/AP15)
// FDC_L2MC          .XFER: lines read by mc client from all banks
//                   .WAIT: lines written by mc client to all banks
//                   .STEN: read-clean lines evicted by mc (flushed to memory)
// FDC_L2RDEVICT     .XFER: L2 lines evicted on read (MG20 only)
//                   .WAIT: clocks waiting for read evict
//                   .STEN: persistent lines evicted by read
// FDC_L2RDEVICT[01]      : as above, but for two banks (SC25/AP15 only)
// FDC_L2WREVICT     .XFER: L2 lines evicted on write (MG20 only)
//                   .WAIT: clocks waiting for write evict
//                   .STEN: persistent lines evicted by write
// FDC_L2WREVICT[01]      : as above, but for two banks (SC25/AP15 only)
// FDC_WRSNOOP       .WAIT: write snoop hits
// FDC_SBSNOOP       .WAIT: scoreboard snoop hits
//                   .STEN: qrast scoreboard snoop hits
// FDC_RDTAGSTALL    .XFER: read clocks stalled on max count (MG20 only)
// FDC_RDTAGSTALL[01].XFER: read clocks stalled on max count (SC25/AP15 only)
// FDC_WRTAGSTALL    .XFER: write clocks stalled on max count (MG20 only)
// FDC_WRTAGSTALL[01].XFER: write clocks stalled on max count (SC25/AP15 only)
//

// Register AR3D_CTL_STAT 
#define LIST_REG_FLD_AR3D_CTL_STAT(_) \
_(AR3D_CTL,STAT,EN) \
_(AR3D_CTL,STAT,BLK) \
_(AR3D_CTL,STAT,OVF)
#define REG_AR3D_CTL_STAT(_) _(AR3D_CTL,STAT,0xc,0xc,2,1,0x800001ff,0x0,ARY,FLD)
// enable this counter set
#define REG_FLD_AR3D_CTL_STAT_EN(_) _(AR3D_CTL,STAT,EN,1,0,0,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_STAT_EN(_)

// select probe point
#define REG_FLD_AR3D_CTL_STAT_BLK(_) _(AR3D_CTL,STAT,BLK,8,8,1,3,0xff,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_CTL_STAT_BLK(_) \
_(AR3D_CTL,STAT,BLK,IDX_HRD,0) \
_(AR3D_CTL,STAT,BLK,IDX_HWR,1) \
_(AR3D_CTL,STAT,BLK,IDX_MEMRDREQ,2) \
_(AR3D_CTL,STAT,BLK,IDX_MEMRDRET,3) \
_(AR3D_CTL,STAT,BLK,IDX_DMAACC,4) \
_(AR3D_CTL,STAT,BLK,IDX_IDXFETCH,5) \
_(AR3D_CTL,STAT,BLK,IDX_IDXLINES,6) \
_(AR3D_CTL,STAT,BLK,IDX_IDXCOUNTS,7) \
_(AR3D_CTL,STAT,BLK,IDX_VTXFETCH,8) \
_(AR3D_CTL,STAT,BLK,IDX_VTXWORDS,9) \
_(AR3D_CTL,STAT,BLK,IDX_VTXCACHE,10) \
_(AR3D_CTL,STAT,BLK,IDX_VTXSTALL,11) \
_(AR3D_CTL,STAT,BLK,IDX_PRIMSTALL,12) \
_(AR3D_CTL,STAT,BLK,IDX_PRIMS,13) \
_(AR3D_CTL,STAT,BLK,IDX_POINTS,14) \
_(AR3D_CTL,STAT,BLK,IDX_LINES,15) \
_(AR3D_CTL,STAT,BLK,IDX_TRIS,16) \
_(AR3D_CTL,STAT,BLK,VPE_CLIPATADR,17) \
_(AR3D_CTL,STAT,BLK,VPE_INSTISSUE,18) \
_(AR3D_CTL,STAT,BLK,VPE_STALL,19) \
_(AR3D_CTL,STAT,BLK,VPE_THREAD0,20) \
_(AR3D_CTL,STAT,BLK,VPE_THREAD1,21) \
_(AR3D_CTL,STAT,BLK,CLIP,22) \
_(AR3D_CTL,STAT,BLK,CLIP_QRETIRE,23) \
_(AR3D_CTL,STAT,BLK,CLIP_VPE,24) \
_(AR3D_CTL,STAT,BLK,CLIP_ATRD,25) \
_(AR3D_CTL,STAT,BLK,CLIP_TRIVREJ,26) \
_(AR3D_CTL,STAT,BLK,CLIP_DEGEN,27) \
_(AR3D_CTL,STAT,BLK,CLIP_ZEROAREA,28) \
_(AR3D_CTL,STAT,BLK,CLIP_REJECT,29) \
_(AR3D_CTL,STAT,BLK,CLIP_CULL,30) \
_(AR3D_CTL,STAT,BLK,CLIP_NEWTRI,31) \
_(AR3D_CTL,STAT,BLK,CLIP_NEWLINE,32) \
_(AR3D_CTL,STAT,BLK,CLIP_LR,33) \
_(AR3D_CTL,STAT,BLK,CLIP_TB,34) \
_(AR3D_CTL,STAT,BLK,CLIP_NF,35) \
_(AR3D_CTL,STAT,BLK,CLIP_UC,36) \
_(AR3D_CTL,STAT,BLK,SETUP_COV,37) \
_(AR3D_CTL,STAT,BLK,SETUP_Z,38) \
_(AR3D_CTL,STAT,BLK,QRAST_SRDAT0,39) \
_(AR3D_CTL,STAT,BLK,QRAST_SRDAT1,40) \
_(AR3D_CTL,STAT,BLK,QRAST_SB,41) \
_(AR3D_CTL,STAT,BLK,QRAST_VRDAT0,42) \
_(AR3D_CTL,STAT,BLK,QRAST_VRDAT1,43) \
_(AR3D_CTL,STAT,BLK,QRAST_ZRDAT0,44) \
_(AR3D_CTL,STAT,BLK,QRAST_ZRDAT1,45) \
_(AR3D_CTL,STAT,BLK,QRAST_PSEQ,46) \
_(AR3D_CTL,STAT,BLK,QRAST,47) \
_(AR3D_CTL,STAT,BLK,QRAST_SBPIX,48) \
_(AR3D_CTL,STAT,BLK,QRAST_QZCULL,49) \
_(AR3D_CTL,STAT,BLK,QRAST_QZKILL,50) \
_(AR3D_CTL,STAT,BLK,QRAST_QSCULL,51) \
_(AR3D_CTL,STAT,BLK,QRAST_QVCULL,52) \
_(AR3D_CTL,STAT,BLK,QRAST_COARSE,53) \
_(AR3D_CTL,STAT,BLK,QRAST_FINE,54) \
_(AR3D_CTL,STAT,BLK,QRAST_CACHE0,55) \
_(AR3D_CTL,STAT,BLK,QRAST_CACHE1,56) \
_(AR3D_CTL,STAT,BLK,QRAST_PRIMS,57) \
_(AR3D_CTL,STAT,BLK,QRAST_FLUSH,58) \
_(AR3D_CTL,STAT,BLK,PSEQ_DWR,59) \
_(AR3D_CTL,STAT,BLK,PSEQ_RDAT,60) \
_(AR3D_CTL,STAT,BLK,PSEQ_RDATCMD,61) \
_(AR3D_CTL,STAT,BLK,PSEQ,62) \
_(AR3D_CTL,STAT,BLK,PSEQ_QPKT,63) \
_(AR3D_CTL,STAT,BLK,PSEQ_QZS,64) \
_(AR3D_CTL,STAT,BLK,PSEQ_PKT,65) \
_(AR3D_CTL,STAT,BLK,PSEQ_ZS,66) \
_(AR3D_CTL,STAT,BLK,PSEQ_NOP,67) \
_(AR3D_CTL,STAT,BLK,PSEQ_CMD0,68) \
_(AR3D_CTL,STAT,BLK,PSEQ_CMD1,69) \
_(AR3D_CTL,STAT,BLK,PSEQ_LOAD,70) \
_(AR3D_CTL,STAT,BLK,PSEQ_FETCH,71) \
_(AR3D_CTL,STAT,BLK,PSEQ_FETCHNOEX,72) \
_(AR3D_CTL,STAT,BLK,PSEQ_CACHE,73) \
_(AR3D_CTL,STAT,BLK,PSEQ_RECIRC0,74) \
_(AR3D_CTL,STAT,BLK,PSEQ_RECIRC1,75) \
_(AR3D_CTL,STAT,BLK,PSEQ_RECIRC2,76) \
_(AR3D_CTL,STAT,BLK,PSEQ_EPOCH,77) \
_(AR3D_CTL,STAT,BLK,PSEQ_REQWAIT,78) \
_(AR3D_CTL,STAT,BLK,PSEQ_RETWAIT,79) \
_(AR3D_CTL,STAT,BLK,ATRAST_TRAM,80) \
_(AR3D_CTL,STAT,BLK,ATRAST_SLOPE,81) \
_(AR3D_CTL,STAT,BLK,ATRAST_TOP,82) \
_(AR3D_CTL,STAT,BLK,ATRAST_BOT,83) \
_(AR3D_CTL,STAT,BLK,TEX,84) \
_(AR3D_CTL,STAT,BLK,TEX_MEMRDREQ,85) \
_(AR3D_CTL,STAT,BLK,TEX_MEMRDRET,86) \
_(AR3D_CTL,STAT,BLK,TEX_CACHEACC,87) \
_(AR3D_CTL,STAT,BLK,TEX_CACHEMISS,88) \
_(AR3D_CTL,STAT,BLK,TEX_FETCH,89) \
_(AR3D_CTL,STAT,BLK,TEX_FETCHNOEX,90) \
_(AR3D_CTL,STAT,BLK,TEX_FILTER0,91) \
_(AR3D_CTL,STAT,BLK,TEX_FILTER1,92) \
_(AR3D_CTL,STAT,BLK,TEX_LODHIST0,93) \
_(AR3D_CTL,STAT,BLK,TEX_LODHIST1,94) \
_(AR3D_CTL,STAT,BLK,TEX_ANISOHIST0,95) \
_(AR3D_CTL,STAT,BLK,TEX_ANISOHIST1,96) \
_(AR3D_CTL,STAT,BLK,TEX_ANISOFINE0,97) \
_(AR3D_CTL,STAT,BLK,TEX_ANISOFINE1,98) \
_(AR3D_CTL,STAT,BLK,TEX_LATHIDE,99) \
_(AR3D_CTL,STAT,BLK,TEX_PERFDEG,100) \
_(AR3D_CTL,STAT,BLK,ALU_TOP,101) \
_(AR3D_CTL,STAT,BLK,ALU_BOT,102) \
_(AR3D_CTL,STAT,BLK,DWR,103) \
_(AR3D_CTL,STAT,BLK,DWR_STORE,104) \
_(AR3D_CTL,STAT,BLK,DWR_WRITE,105) \
_(AR3D_CTL,STAT,BLK,DWR_WRITENOEX,106) \
_(AR3D_CTL,STAT,BLK,DWR_SPILL,107) \
_(AR3D_CTL,STAT,BLK,DWR_FLUSH,108) \
_(AR3D_CTL,STAT,BLK,DWR_LATEOPS,109) \
_(AR3D_CTL,STAT,BLK,DWR_CACHE,110) \
_(AR3D_CTL,STAT,BLK,FDC_DWR0,111) \
_(AR3D_CTL,STAT,BLK,FDC_DWR1,112) \
_(AR3D_CTL,STAT,BLK,FDC_IMEMRDREQ,113) \
_(AR3D_CTL,STAT,BLK,FDC_EMEMRDREQ,114) \
_(AR3D_CTL,STAT,BLK,FDC_IMEMWRREQ,115) \
_(AR3D_CTL,STAT,BLK,FDC_EMEMWRREQ,116) \
_(AR3D_CTL,STAT,BLK,FDC_PSEQ0,117) \
_(AR3D_CTL,STAT,BLK,FDC_PSEQ1,118) \
_(AR3D_CTL,STAT,BLK,FDC_SBPSEQ,119) \
_(AR3D_CTL,STAT,BLK,FDC_QSRD0,120) \
_(AR3D_CTL,STAT,BLK,FDC_QSRD1,121) \
_(AR3D_CTL,STAT,BLK,FDC_QSWR0,122) \
_(AR3D_CTL,STAT,BLK,FDC_QSWR1,123) \
_(AR3D_CTL,STAT,BLK,FDC_SBQRAST,124) \
_(AR3D_CTL,STAT,BLK,FDC_QVRD0,125) \
_(AR3D_CTL,STAT,BLK,FDC_QVRD1,126) \
_(AR3D_CTL,STAT,BLK,FDC_QVWR0,127) \
_(AR3D_CTL,STAT,BLK,FDC_QVWR1,128) \
_(AR3D_CTL,STAT,BLK,FDC_QZRD0,129) \
_(AR3D_CTL,STAT,BLK,FDC_QZRD1,130) \
_(AR3D_CTL,STAT,BLK,FDC_QZWR0,131) \
_(AR3D_CTL,STAT,BLK,FDC_QZWR1,132) \
_(AR3D_CTL,STAT,BLK,FDC_L2RD0,133) \
_(AR3D_CTL,STAT,BLK,FDC_L2RD1,134) \
_(AR3D_CTL,STAT,BLK,FDC_L2RD2,135) \
_(AR3D_CTL,STAT,BLK,FDC_L2RD3,136) \
_(AR3D_CTL,STAT,BLK,FDC_L2RD4,137) \
_(AR3D_CTL,STAT,BLK,FDC_L2RD5,138) \
_(AR3D_CTL,STAT,BLK,FDC_L2RD6,139) \
_(AR3D_CTL,STAT,BLK,FDC_L2RD7,140) \
_(AR3D_CTL,STAT,BLK,FDC_L2WR0,141) \
_(AR3D_CTL,STAT,BLK,FDC_L2WR1,142) \
_(AR3D_CTL,STAT,BLK,FDC_L2WR2,143) \
_(AR3D_CTL,STAT,BLK,FDC_L2WR3,144) \
_(AR3D_CTL,STAT,BLK,FDC_L2WR4,145) \
_(AR3D_CTL,STAT,BLK,FDC_L2WR5,146) \
_(AR3D_CTL,STAT,BLK,FDC_L2WR6,147) \
_(AR3D_CTL,STAT,BLK,FDC_L2WR7,148) \
_(AR3D_CTL,STAT,BLK,FDC_L2MC,149) \
_(AR3D_CTL,STAT,BLK,FDC_L2RDEVICT0,150) \
_(AR3D_CTL,STAT,BLK,FDC_L2RDEVICT1,151) \
_(AR3D_CTL,STAT,BLK,FDC_L2WREVICT0,152) \
_(AR3D_CTL,STAT,BLK,FDC_L2WREVICT1,153) \
_(AR3D_CTL,STAT,BLK,FDC_WRSNOOP,154) \
_(AR3D_CTL,STAT,BLK,FDC_SBSNOOP,155) \
_(AR3D_CTL,STAT,BLK,FDC_RDTAGSTALL0,156) \
_(AR3D_CTL,STAT,BLK,FDC_RDTAGSTALL1,157) \
_(AR3D_CTL,STAT,BLK,FDC_WRTAGSTALL0,158) \
_(AR3D_CTL,STAT,BLK,FDC_WRTAGSTALL1,159) \
_(AR3D_CTL,STAT,BLK,NUM_BLOCKS,160)
#define AR3D_CTL_STAT_BLK_IDX_HRD                       _MK_ENUM_CONST(0)
#define AR3D_CTL_STAT_BLK_IDX_HWR                       _MK_ENUM_CONST(1)
#define AR3D_CTL_STAT_BLK_IDX_MEMRDREQ                  _MK_ENUM_CONST(2)
#define AR3D_CTL_STAT_BLK_IDX_MEMRDRET                  _MK_ENUM_CONST(3)
#define AR3D_CTL_STAT_BLK_IDX_DMAACC                    _MK_ENUM_CONST(4)
#define AR3D_CTL_STAT_BLK_IDX_IDXFETCH                  _MK_ENUM_CONST(5)
#define AR3D_CTL_STAT_BLK_IDX_IDXLINES                  _MK_ENUM_CONST(6)
#define AR3D_CTL_STAT_BLK_IDX_IDXCOUNTS                 _MK_ENUM_CONST(7)
#define AR3D_CTL_STAT_BLK_IDX_VTXFETCH                  _MK_ENUM_CONST(8)
#define AR3D_CTL_STAT_BLK_IDX_VTXWORDS                  _MK_ENUM_CONST(9)
#define AR3D_CTL_STAT_BLK_IDX_VTXCACHE                  _MK_ENUM_CONST(10)
#define AR3D_CTL_STAT_BLK_IDX_VTXSTALL                  _MK_ENUM_CONST(11)
#define AR3D_CTL_STAT_BLK_IDX_PRIMSTALL                 _MK_ENUM_CONST(12)
#define AR3D_CTL_STAT_BLK_IDX_PRIMS                     _MK_ENUM_CONST(13)
#define AR3D_CTL_STAT_BLK_IDX_POINTS                    _MK_ENUM_CONST(14)
#define AR3D_CTL_STAT_BLK_IDX_LINES                     _MK_ENUM_CONST(15)
#define AR3D_CTL_STAT_BLK_IDX_TRIS                      _MK_ENUM_CONST(16)
#define AR3D_CTL_STAT_BLK_VPE_CLIPATADR                 _MK_ENUM_CONST(17)
#define AR3D_CTL_STAT_BLK_VPE_INSTISSUE                 _MK_ENUM_CONST(18)
#define AR3D_CTL_STAT_BLK_VPE_STALL                     _MK_ENUM_CONST(19)
#define AR3D_CTL_STAT_BLK_VPE_THREAD0                   _MK_ENUM_CONST(20)
#define AR3D_CTL_STAT_BLK_VPE_THREAD1                   _MK_ENUM_CONST(21)
#define AR3D_CTL_STAT_BLK_CLIP                  _MK_ENUM_CONST(22)
#define AR3D_CTL_STAT_BLK_CLIP_QRETIRE                  _MK_ENUM_CONST(23)
#define AR3D_CTL_STAT_BLK_CLIP_VPE                      _MK_ENUM_CONST(24)
#define AR3D_CTL_STAT_BLK_CLIP_ATRD                     _MK_ENUM_CONST(25)
#define AR3D_CTL_STAT_BLK_CLIP_TRIVREJ                  _MK_ENUM_CONST(26)
#define AR3D_CTL_STAT_BLK_CLIP_DEGEN                    _MK_ENUM_CONST(27)
#define AR3D_CTL_STAT_BLK_CLIP_ZEROAREA                 _MK_ENUM_CONST(28)
#define AR3D_CTL_STAT_BLK_CLIP_REJECT                   _MK_ENUM_CONST(29)
#define AR3D_CTL_STAT_BLK_CLIP_CULL                     _MK_ENUM_CONST(30)
#define AR3D_CTL_STAT_BLK_CLIP_NEWTRI                   _MK_ENUM_CONST(31)
#define AR3D_CTL_STAT_BLK_CLIP_NEWLINE                  _MK_ENUM_CONST(32)
#define AR3D_CTL_STAT_BLK_CLIP_LR                       _MK_ENUM_CONST(33)
#define AR3D_CTL_STAT_BLK_CLIP_TB                       _MK_ENUM_CONST(34)
#define AR3D_CTL_STAT_BLK_CLIP_NF                       _MK_ENUM_CONST(35)
#define AR3D_CTL_STAT_BLK_CLIP_UC                       _MK_ENUM_CONST(36)
#define AR3D_CTL_STAT_BLK_SETUP_COV                     _MK_ENUM_CONST(37)
#define AR3D_CTL_STAT_BLK_SETUP_Z                       _MK_ENUM_CONST(38)
#define AR3D_CTL_STAT_BLK_QRAST_SRDAT0                  _MK_ENUM_CONST(39)
#define AR3D_CTL_STAT_BLK_QRAST_SRDAT1                  _MK_ENUM_CONST(40)
#define AR3D_CTL_STAT_BLK_QRAST_SB                      _MK_ENUM_CONST(41)
#define AR3D_CTL_STAT_BLK_QRAST_VRDAT0                  _MK_ENUM_CONST(42)
#define AR3D_CTL_STAT_BLK_QRAST_VRDAT1                  _MK_ENUM_CONST(43)
#define AR3D_CTL_STAT_BLK_QRAST_ZRDAT0                  _MK_ENUM_CONST(44)
#define AR3D_CTL_STAT_BLK_QRAST_ZRDAT1                  _MK_ENUM_CONST(45)
#define AR3D_CTL_STAT_BLK_QRAST_PSEQ                    _MK_ENUM_CONST(46)
#define AR3D_CTL_STAT_BLK_QRAST                 _MK_ENUM_CONST(47)
#define AR3D_CTL_STAT_BLK_QRAST_SBPIX                   _MK_ENUM_CONST(48)
#define AR3D_CTL_STAT_BLK_QRAST_QZCULL                  _MK_ENUM_CONST(49)
#define AR3D_CTL_STAT_BLK_QRAST_QZKILL                  _MK_ENUM_CONST(50)
#define AR3D_CTL_STAT_BLK_QRAST_QSCULL                  _MK_ENUM_CONST(51)
#define AR3D_CTL_STAT_BLK_QRAST_QVCULL                  _MK_ENUM_CONST(52)
#define AR3D_CTL_STAT_BLK_QRAST_COARSE                  _MK_ENUM_CONST(53)
#define AR3D_CTL_STAT_BLK_QRAST_FINE                    _MK_ENUM_CONST(54)
#define AR3D_CTL_STAT_BLK_QRAST_CACHE0                  _MK_ENUM_CONST(55)
#define AR3D_CTL_STAT_BLK_QRAST_CACHE1                  _MK_ENUM_CONST(56)
#define AR3D_CTL_STAT_BLK_QRAST_PRIMS                   _MK_ENUM_CONST(57)
#define AR3D_CTL_STAT_BLK_QRAST_FLUSH                   _MK_ENUM_CONST(58)
#define AR3D_CTL_STAT_BLK_PSEQ_DWR                      _MK_ENUM_CONST(59)
#define AR3D_CTL_STAT_BLK_PSEQ_RDAT                     _MK_ENUM_CONST(60)
#define AR3D_CTL_STAT_BLK_PSEQ_RDATCMD                  _MK_ENUM_CONST(61)
#define AR3D_CTL_STAT_BLK_PSEQ                  _MK_ENUM_CONST(62)
#define AR3D_CTL_STAT_BLK_PSEQ_QPKT                     _MK_ENUM_CONST(63)
#define AR3D_CTL_STAT_BLK_PSEQ_QZS                      _MK_ENUM_CONST(64)
#define AR3D_CTL_STAT_BLK_PSEQ_PKT                      _MK_ENUM_CONST(65)
#define AR3D_CTL_STAT_BLK_PSEQ_ZS                       _MK_ENUM_CONST(66)
#define AR3D_CTL_STAT_BLK_PSEQ_NOP                      _MK_ENUM_CONST(67)
#define AR3D_CTL_STAT_BLK_PSEQ_CMD0                     _MK_ENUM_CONST(68)
#define AR3D_CTL_STAT_BLK_PSEQ_CMD1                     _MK_ENUM_CONST(69)
#define AR3D_CTL_STAT_BLK_PSEQ_LOAD                     _MK_ENUM_CONST(70)
#define AR3D_CTL_STAT_BLK_PSEQ_FETCH                    _MK_ENUM_CONST(71)
#define AR3D_CTL_STAT_BLK_PSEQ_FETCHNOEX                        _MK_ENUM_CONST(72)
#define AR3D_CTL_STAT_BLK_PSEQ_CACHE                    _MK_ENUM_CONST(73)
#define AR3D_CTL_STAT_BLK_PSEQ_RECIRC0                  _MK_ENUM_CONST(74)
#define AR3D_CTL_STAT_BLK_PSEQ_RECIRC1                  _MK_ENUM_CONST(75)
#define AR3D_CTL_STAT_BLK_PSEQ_RECIRC2                  _MK_ENUM_CONST(76)
#define AR3D_CTL_STAT_BLK_PSEQ_EPOCH                    _MK_ENUM_CONST(77)
#define AR3D_CTL_STAT_BLK_PSEQ_REQWAIT                  _MK_ENUM_CONST(78)
#define AR3D_CTL_STAT_BLK_PSEQ_RETWAIT                  _MK_ENUM_CONST(79)
#define AR3D_CTL_STAT_BLK_ATRAST_TRAM                   _MK_ENUM_CONST(80)
#define AR3D_CTL_STAT_BLK_ATRAST_SLOPE                  _MK_ENUM_CONST(81)
#define AR3D_CTL_STAT_BLK_ATRAST_TOP                    _MK_ENUM_CONST(82)
#define AR3D_CTL_STAT_BLK_ATRAST_BOT                    _MK_ENUM_CONST(83)
#define AR3D_CTL_STAT_BLK_TEX                   _MK_ENUM_CONST(84)
#define AR3D_CTL_STAT_BLK_TEX_MEMRDREQ                  _MK_ENUM_CONST(85)
#define AR3D_CTL_STAT_BLK_TEX_MEMRDRET                  _MK_ENUM_CONST(86)
#define AR3D_CTL_STAT_BLK_TEX_CACHEACC                  _MK_ENUM_CONST(87)
#define AR3D_CTL_STAT_BLK_TEX_CACHEMISS                 _MK_ENUM_CONST(88)
#define AR3D_CTL_STAT_BLK_TEX_FETCH                     _MK_ENUM_CONST(89)
#define AR3D_CTL_STAT_BLK_TEX_FETCHNOEX                 _MK_ENUM_CONST(90)
#define AR3D_CTL_STAT_BLK_TEX_FILTER0                   _MK_ENUM_CONST(91)
#define AR3D_CTL_STAT_BLK_TEX_FILTER1                   _MK_ENUM_CONST(92)
#define AR3D_CTL_STAT_BLK_TEX_LODHIST0                  _MK_ENUM_CONST(93)
#define AR3D_CTL_STAT_BLK_TEX_LODHIST1                  _MK_ENUM_CONST(94)
#define AR3D_CTL_STAT_BLK_TEX_ANISOHIST0                        _MK_ENUM_CONST(95)
#define AR3D_CTL_STAT_BLK_TEX_ANISOHIST1                        _MK_ENUM_CONST(96)
#define AR3D_CTL_STAT_BLK_TEX_ANISOFINE0                        _MK_ENUM_CONST(97)
#define AR3D_CTL_STAT_BLK_TEX_ANISOFINE1                        _MK_ENUM_CONST(98)
#define AR3D_CTL_STAT_BLK_TEX_LATHIDE                   _MK_ENUM_CONST(99)
#define AR3D_CTL_STAT_BLK_TEX_PERFDEG                   _MK_ENUM_CONST(100)
#define AR3D_CTL_STAT_BLK_ALU_TOP                       _MK_ENUM_CONST(101)
#define AR3D_CTL_STAT_BLK_ALU_BOT                       _MK_ENUM_CONST(102)
#define AR3D_CTL_STAT_BLK_DWR                   _MK_ENUM_CONST(103)
#define AR3D_CTL_STAT_BLK_DWR_STORE                     _MK_ENUM_CONST(104)
#define AR3D_CTL_STAT_BLK_DWR_WRITE                     _MK_ENUM_CONST(105)
#define AR3D_CTL_STAT_BLK_DWR_WRITENOEX                 _MK_ENUM_CONST(106)
#define AR3D_CTL_STAT_BLK_DWR_SPILL                     _MK_ENUM_CONST(107)
#define AR3D_CTL_STAT_BLK_DWR_FLUSH                     _MK_ENUM_CONST(108)
#define AR3D_CTL_STAT_BLK_DWR_LATEOPS                   _MK_ENUM_CONST(109)
#define AR3D_CTL_STAT_BLK_DWR_CACHE                     _MK_ENUM_CONST(110)
#define AR3D_CTL_STAT_BLK_FDC_DWR0                      _MK_ENUM_CONST(111)
#define AR3D_CTL_STAT_BLK_FDC_DWR1                      _MK_ENUM_CONST(112)
#define AR3D_CTL_STAT_BLK_FDC_IMEMRDREQ                 _MK_ENUM_CONST(113)
#define AR3D_CTL_STAT_BLK_FDC_EMEMRDREQ                 _MK_ENUM_CONST(114)
#define AR3D_CTL_STAT_BLK_FDC_IMEMWRREQ                 _MK_ENUM_CONST(115)
#define AR3D_CTL_STAT_BLK_FDC_EMEMWRREQ                 _MK_ENUM_CONST(116)
#define AR3D_CTL_STAT_BLK_FDC_PSEQ0                     _MK_ENUM_CONST(117)
#define AR3D_CTL_STAT_BLK_FDC_PSEQ1                     _MK_ENUM_CONST(118)
#define AR3D_CTL_STAT_BLK_FDC_SBPSEQ                    _MK_ENUM_CONST(119)
#define AR3D_CTL_STAT_BLK_FDC_QSRD0                     _MK_ENUM_CONST(120)
#define AR3D_CTL_STAT_BLK_FDC_QSRD1                     _MK_ENUM_CONST(121)
#define AR3D_CTL_STAT_BLK_FDC_QSWR0                     _MK_ENUM_CONST(122)
#define AR3D_CTL_STAT_BLK_FDC_QSWR1                     _MK_ENUM_CONST(123)
#define AR3D_CTL_STAT_BLK_FDC_SBQRAST                   _MK_ENUM_CONST(124)
#define AR3D_CTL_STAT_BLK_FDC_QVRD0                     _MK_ENUM_CONST(125)
#define AR3D_CTL_STAT_BLK_FDC_QVRD1                     _MK_ENUM_CONST(126)
#define AR3D_CTL_STAT_BLK_FDC_QVWR0                     _MK_ENUM_CONST(127)
#define AR3D_CTL_STAT_BLK_FDC_QVWR1                     _MK_ENUM_CONST(128)
#define AR3D_CTL_STAT_BLK_FDC_QZRD0                     _MK_ENUM_CONST(129)
#define AR3D_CTL_STAT_BLK_FDC_QZRD1                     _MK_ENUM_CONST(130)
#define AR3D_CTL_STAT_BLK_FDC_QZWR0                     _MK_ENUM_CONST(131)
#define AR3D_CTL_STAT_BLK_FDC_QZWR1                     _MK_ENUM_CONST(132)
#define AR3D_CTL_STAT_BLK_FDC_L2RD0                     _MK_ENUM_CONST(133)
#define AR3D_CTL_STAT_BLK_FDC_L2RD1                     _MK_ENUM_CONST(134)
#define AR3D_CTL_STAT_BLK_FDC_L2RD2                     _MK_ENUM_CONST(135)
#define AR3D_CTL_STAT_BLK_FDC_L2RD3                     _MK_ENUM_CONST(136)
#define AR3D_CTL_STAT_BLK_FDC_L2RD4                     _MK_ENUM_CONST(137)
#define AR3D_CTL_STAT_BLK_FDC_L2RD5                     _MK_ENUM_CONST(138)
#define AR3D_CTL_STAT_BLK_FDC_L2RD6                     _MK_ENUM_CONST(139)
#define AR3D_CTL_STAT_BLK_FDC_L2RD7                     _MK_ENUM_CONST(140)
#define AR3D_CTL_STAT_BLK_FDC_L2WR0                     _MK_ENUM_CONST(141)
#define AR3D_CTL_STAT_BLK_FDC_L2WR1                     _MK_ENUM_CONST(142)
#define AR3D_CTL_STAT_BLK_FDC_L2WR2                     _MK_ENUM_CONST(143)
#define AR3D_CTL_STAT_BLK_FDC_L2WR3                     _MK_ENUM_CONST(144)
#define AR3D_CTL_STAT_BLK_FDC_L2WR4                     _MK_ENUM_CONST(145)
#define AR3D_CTL_STAT_BLK_FDC_L2WR5                     _MK_ENUM_CONST(146)
#define AR3D_CTL_STAT_BLK_FDC_L2WR6                     _MK_ENUM_CONST(147)
#define AR3D_CTL_STAT_BLK_FDC_L2WR7                     _MK_ENUM_CONST(148)
#define AR3D_CTL_STAT_BLK_FDC_L2MC                      _MK_ENUM_CONST(149)
#define AR3D_CTL_STAT_BLK_FDC_L2RDEVICT0                        _MK_ENUM_CONST(150)
#define AR3D_CTL_STAT_BLK_FDC_L2RDEVICT1                        _MK_ENUM_CONST(151)
#define AR3D_CTL_STAT_BLK_FDC_L2WREVICT0                        _MK_ENUM_CONST(152)
#define AR3D_CTL_STAT_BLK_FDC_L2WREVICT1                        _MK_ENUM_CONST(153)
#define AR3D_CTL_STAT_BLK_FDC_WRSNOOP                   _MK_ENUM_CONST(154)
#define AR3D_CTL_STAT_BLK_FDC_SBSNOOP                   _MK_ENUM_CONST(155)
#define AR3D_CTL_STAT_BLK_FDC_RDTAGSTALL0                       _MK_ENUM_CONST(156)
#define AR3D_CTL_STAT_BLK_FDC_RDTAGSTALL1                       _MK_ENUM_CONST(157)
#define AR3D_CTL_STAT_BLK_FDC_WRTAGSTALL0                       _MK_ENUM_CONST(158)
#define AR3D_CTL_STAT_BLK_FDC_WRTAGSTALL1                       _MK_ENUM_CONST(159)
#define AR3D_CTL_STAT_BLK_NUM_BLOCKS                    _MK_ENUM_CONST(160)

// stat counter overflow
// Hardware sets this to one whenever one of
// counters overflows.  Cleared by software.
#define REG_FLD_AR3D_CTL_STAT_OVF(_) _(AR3D_CTL,STAT,OVF,1,31,31,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_STAT_OVF(_)


// Register AR3D_CTL_STAT_CLK_COUNT 
#define LIST_REG_FLD_AR3D_CTL_STAT_CLK_COUNT(_) \
_(AR3D_CTL,STAT_CLK_COUNT,VAL)
#define REG_AR3D_CTL_STAT_CLK_COUNT(_) _(AR3D_CTL,STAT_CLK_COUNT,0xe,0xe,2,1,0xffffffff,0x0,ARY,FLD)
// typically clocks which INSTRUMENT.STAT_EN at STAT.BLK were true
#define REG_FLD_AR3D_CTL_STAT_CLK_COUNT_VAL(_) _(AR3D_CTL,STAT_CLK_COUNT,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_STAT_CLK_COUNT_VAL(_)


// Register AR3D_CTL_STAT_XFER_COUNT 
#define LIST_REG_FLD_AR3D_CTL_STAT_XFER_COUNT(_) \
_(AR3D_CTL,STAT_XFER_COUNT,VAL)
#define REG_AR3D_CTL_STAT_XFER_COUNT(_) _(AR3D_CTL,STAT_XFER_COUNT,0x10,0x10,2,1,0xffffffff,0x0,ARY,FLD)
// typically count of valid & !stall for pipeline buses
#define REG_FLD_AR3D_CTL_STAT_XFER_COUNT_VAL(_) _(AR3D_CTL,STAT_XFER_COUNT,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_STAT_XFER_COUNT_VAL(_)


// Register AR3D_CTL_STAT_WAIT_COUNT 
#define LIST_REG_FLD_AR3D_CTL_STAT_WAIT_COUNT(_) \
_(AR3D_CTL,STAT_WAIT_COUNT,VAL)
#define REG_AR3D_CTL_STAT_WAIT_COUNT(_) _(AR3D_CTL,STAT_WAIT_COUNT,0x12,0x12,2,1,0xffffffff,0x0,ARY,FLD)
// typically count of valid & stall for pipeline buses
#define REG_FLD_AR3D_CTL_STAT_WAIT_COUNT_VAL(_) _(AR3D_CTL,STAT_WAIT_COUNT,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_STAT_WAIT_COUNT_VAL(_)


// Register AR3D_CTL_STAT_EN_COUNT 
#define LIST_REG_FLD_AR3D_CTL_STAT_EN_COUNT(_) \
_(AR3D_CTL,STAT_EN_COUNT,VAL)
#define REG_AR3D_CTL_STAT_EN_COUNT(_) _(AR3D_CTL,STAT_EN_COUNT,0x14,0x14,2,1,0xffffffff,0x0,ARY,FLD)
// typically number of times INSTRUMENT.STAT_EN at STAT.BLK went from false to true
#define REG_FLD_AR3D_CTL_STAT_EN_COUNT_VAL(_) _(AR3D_CTL,STAT_EN_COUNT,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_CTL_STAT_EN_COUNT_VAL(_)

// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// ar3d_idx.spec
#define NUM_ATTR        16
// This array sets the base address for each attribute, along with the format for each.
// It is an interleaved array with ATTR_BASE in the even words and the other fields in
// the odd words.  Attributes are fetched based on the index at an address specified by
// ATTR_BASE + index * ATTR_STRIDE.  The computed address can be arbitrarily aligned.
// Attributes are format-converted to 4x FP32 from their original format and size (1-4).
// Attributes with size less than 4 are padded with defaults of 0.0 for y/z and 1.0 for w.
//
// ATTR_[BASE|STRIDE|SIZE|FMT] are only used to describe the input attributes.  They have
// nothing to do with output attributes.

// Register AR3D_IDX_ATTRIBUTE // Attribute address and format
#define LIST_REG_FLD_AR3D_IDX_ATTRIBUTE(_) \
_(AR3D_IDX,ATTRIBUTE,ATTR_BASE) \
_(AR3D_IDX,ATTRIBUTE,ATTR_STRIDE) \
_(AR3D_IDX,ATTRIBUTE,ATTR_SIZE) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT)
#define REG_AR3D_IDX_ATTRIBUTE(_) _(AR3D_IDX,ATTRIBUTE,0x100,0x0,32,1,0xffffffff,0x0,ARY,FLD)
// Base address of attribute array
#define REG_FLD_AR3D_IDX_ATTRIBUTE_ATTR_BASE(_) _(AR3D_IDX,ATTRIBUTE,ATTR_BASE,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_ATTRIBUTE_ATTR_BASE(_)

// Unsigned attribute to attribute stride,
// in bytes.  A value of 0 means 0 (ie 0 does
// not mean ATTR_SIZE * sizeof(ATTR_FMT), as
// the GL API expects).
#define REG_FLD_AR3D_IDX_ATTRIBUTE_ATTR_STRIDE(_) _(AR3D_IDX,ATTRIBUTE,ATTR_STRIDE,12,19,8,3,0xfff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_ATTRIBUTE_ATTR_STRIDE(_)

// Number of components, 1-4
#define REG_FLD_AR3D_IDX_ATTRIBUTE_ATTR_SIZE(_) _(AR3D_IDX,ATTRIBUTE,ATTR_SIZE,3,6,4,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_ATTRIBUTE_ATTR_SIZE(_)

// Attribute format:
//      U8      unsigned byte, 0-255
//      U8N     normalized unsigned byte, 0.0-1.0
//      S8      signed byte, -128-127
//      S8N     normalized signed byte, -1.0-1.0
//      U16     unsigned short, 0-64K
//      U16N    normalized unsigned short, 0.0-1.0
//      S16     signed short, -32K-32K
//      S16N    normalized signed short, -1.0-1.0
//      U32     unsigned long, 0-4G
//      U32N    normalized unsigned long, 0.0-1.0
//      S32     signed long, -2G-2G
//      S32N    normalized signed long, -1.0-1.0
//      X32     Fixed-point S15.16, -32K-32K
//      F32     IEEE single float, -Inf..Inf
//      H16     Half float, s10e5, -131K..131K
#define REG_FLD_AR3D_IDX_ATTRIBUTE_ATTR_FMT(_) _(AR3D_IDX,ATTRIBUTE,ATTR_FMT,4,3,0,3,0xf,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_IDX_ATTRIBUTE_ATTR_FMT(_) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,U8,0) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,U8N,1) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,S8,2) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,S8N,3) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,U16,4) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,U16N,5) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,S16,6) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,S16N,7) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,U32,8) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,U32N,9) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,S32,10) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,S32N,11) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,X32,12) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,F32,13) \
_(AR3D_IDX,ATTRIBUTE,ATTR_FMT,H16,14)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_U8                  _MK_ENUM_CONST(0)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_U8N                 _MK_ENUM_CONST(1)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_S8                  _MK_ENUM_CONST(2)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_S8N                 _MK_ENUM_CONST(3)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_U16                 _MK_ENUM_CONST(4)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_U16N                        _MK_ENUM_CONST(5)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_S16                 _MK_ENUM_CONST(6)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_S16N                        _MK_ENUM_CONST(7)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_U32                 _MK_ENUM_CONST(8)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_U32N                        _MK_ENUM_CONST(9)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_S32                 _MK_ENUM_CONST(10)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_S32N                        _MK_ENUM_CONST(11)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_X32                 _MK_ENUM_CONST(12)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_F32                 _MK_ENUM_CONST(13)
#define AR3D_IDX_ATTRIBUTE_ATTR_FMT_H16                 _MK_ENUM_CONST(14)

// The attribute masks select which input attributes are present (for IDX to fetch and write
// to the VPE input buffers) and which output attributes are present (for VPE to write to
// the VPE output buffers).  They indirectly set the number of vertices in each buffer pool).
//
// Note that it is perfectly reasonable to have bits set in INPUT_ATTR_MASK that are not set
// in OUTPUT_ATTR_MASK (ex: skinning).  It is also perfectly reasonable to have bits set in
// OUTPUT_ATTR_MASK that are not set INPUT_ATTR_MASK (ex: texgen).

// Register AR3D_IDX_ATTR_MASK // Attribute input and output masks
#define LIST_REG_FLD_AR3D_IDX_ATTR_MASK(_) \
_(AR3D_IDX,ATTR_MASK,INPUT_ATTR_MASK) \
_(AR3D_IDX,ATTR_MASK,OUTPUT_ATTR_MASK)
#define REG_AR3D_IDX_ATTR_MASK(_) _(AR3D_IDX,ATTR_MASK,0x120,0x20,1,1,0xffffffff,0x0,NOARY,FLD)
// Input attribute mask
#define REG_FLD_AR3D_IDX_ATTR_MASK_INPUT_ATTR_MASK(_) _(AR3D_IDX,ATTR_MASK,INPUT_ATTR_MASK,16,31,16,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_ATTR_MASK_INPUT_ATTR_MASK(_)

// Output attribute mask
#define REG_FLD_AR3D_IDX_ATTR_MASK_OUTPUT_ATTR_MASK(_) _(AR3D_IDX,ATTR_MASK,OUTPUT_ATTR_MASK,16,15,0,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_ATTR_MASK_OUTPUT_ATTR_MASK(_)

// This sets the index base for DrawElements commands.  It must be natively aligned to the
// DRAW_MODE type.

// Register AR3D_IDX_INDEX_BASE // Index array base
#define LIST_REG_FLD_AR3D_IDX_INDEX_BASE(_) \
_(AR3D_IDX,INDEX_BASE,INDEX_BASE)
#define REG_AR3D_IDX_INDEX_BASE(_) _(AR3D_IDX,INDEX_BASE,0x121,0x21,1,1,0xffffffff,0x0,NOARY,FLD)
// Base address of index array for DrawElements
#define REG_FLD_AR3D_IDX_INDEX_BASE_INDEX_BASE(_) _(AR3D_IDX,INDEX_BASE,INDEX_BASE,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_INDEX_BASE_INDEX_BASE(_)

// This sets the primitive type and determines if the indices will be directly generated (ARRAY)
// or indirectly fetched from memory (ELE8 / ELE16 / ELE32).  If the mode is ARRAY, a subsequent
// DRAW_PRIM will use vertices in the range START_VTX to START_VTX+VTX_COUNT.  If the mode is
// ELE8/ELE16/ELE32, it will fetch the indices from INDEX_BASE[0] to INDEX_BASE[VTX_COUNT] and
// add the fetched result to START_VTX.  The fetched index size can be 8-, 16- or 32-bits.
//
// Internally, the computed vertex offsets are as wide as START_VTX and use unsigned modulo
// arithmetic.  That means (for example) setting START_VTX=MAX for a DrawElements() command is
// effectively the same as subtracting one from each index.
//
// In addition, an explicit pivot vertex is supplied for TRI_FAN and LINE_LOOP primitives.  For
// the TRI_FAN primitive, the pivot vertex is the first vertex in each triangle (and the DRAW_PRIM
// method should supply all the following vertices).  For LINE_LOOP, the line loop finishes by 
// drawing to the pivot vertex (and the DRAW_PRIM should supply the pivot as the first vertex to
// start the loop).  Note that for DrawElements operations, the PIVOT_VTX value must be the actual
// vertex, not the index offset (the hardware uses PIVOT_VTX directly - it does not fetch
// INDEX_BASE[PIVOT_VTX]).
//
// There are also two command bits, for invalidating the vertex cache and the dma cache.  The
// DMA cache should be flushed whenever the attribute data is changed.  The vertex cache should
// be flushed whenever the indices reference different attributes OR the attribute data is changed.

// Register AR3D_IDX_SET_PRIM // Set primitive type and drawing mode.
#define LIST_REG_FLD_AR3D_IDX_SET_PRIM(_) \
_(AR3D_IDX,SET_PRIM,INVALIDATE_VTXCACHE) \
_(AR3D_IDX,SET_PRIM,INVALIDATE_DMACACHE) \
_(AR3D_IDX,SET_PRIM,DRAW_MODE) \
_(AR3D_IDX,SET_PRIM,FLAT_VTX) \
_(AR3D_IDX,SET_PRIM,PRIM_TYPE) \
_(AR3D_IDX,SET_PRIM,PIVOT_VTX)
#define REG_AR3D_IDX_SET_PRIM(_) _(AR3D_IDX,SET_PRIM,0x122,0x22,1,1,0xff0fffff,0x0,NOARY,FLD)
// Set to "1" to invalidate vertex cache.  Always
// reads back as "0".
#define REG_FLD_AR3D_IDX_SET_PRIM_INVALIDATE_VTXCACHE(_) _(AR3D_IDX,SET_PRIM,INVALIDATE_VTXCACHE,1,31,31,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_SET_PRIM_INVALIDATE_VTXCACHE(_)

// Set to "1" to invalidate DMA cache.  Always reads
// back as "0".
#define REG_FLD_AR3D_IDX_SET_PRIM_INVALIDATE_DMACACHE(_) _(AR3D_IDX,SET_PRIM,INVALIDATE_DMACACHE,1,30,30,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_SET_PRIM_INVALIDATE_DMACACHE(_)

// Primitive mode:
//      ARRAY   DrawArray()
//      ELE8    DrawElements8()
//      ELE16   DrawElements16()
//      ELE32   DrawElements32()
#define REG_FLD_AR3D_IDX_SET_PRIM_DRAW_MODE(_) _(AR3D_IDX,SET_PRIM,DRAW_MODE,2,29,28,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_IDX_SET_PRIM_DRAW_MODE(_) \
_(AR3D_IDX,SET_PRIM,DRAW_MODE,ARRAY,0) \
_(AR3D_IDX,SET_PRIM,DRAW_MODE,ELE8,1) \
_(AR3D_IDX,SET_PRIM,DRAW_MODE,ELE16,2) \
_(AR3D_IDX,SET_PRIM,DRAW_MODE,ELE32,3)
#define AR3D_IDX_SET_PRIM_DRAW_MODE_ARRAY                       _MK_ENUM_CONST(0)
#define AR3D_IDX_SET_PRIM_DRAW_MODE_ELE8                        _MK_ENUM_CONST(1)
#define AR3D_IDX_SET_PRIM_DRAW_MODE_ELE16                       _MK_ENUM_CONST(2)
#define AR3D_IDX_SET_PRIM_DRAW_MODE_ELE32                       _MK_ENUM_CONST(3)

// Which vertex is flatshade vtx
#define REG_FLD_AR3D_IDX_SET_PRIM_FLAT_VTX(_) _(AR3D_IDX,SET_PRIM,FLAT_VTX,1,27,27,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_IDX_SET_PRIM_FLAT_VTX(_) \
_(AR3D_IDX,SET_PRIM,FLAT_VTX,FIRST,0) \
_(AR3D_IDX,SET_PRIM,FLAT_VTX,LAST,1)
#define AR3D_IDX_SET_PRIM_FLAT_VTX_FIRST                        _MK_ENUM_CONST(0)
#define AR3D_IDX_SET_PRIM_FLAT_VTX_LAST                 _MK_ENUM_CONST(1)

// Primitive type
#define REG_FLD_AR3D_IDX_SET_PRIM_PRIM_TYPE(_) _(AR3D_IDX,SET_PRIM,PRIM_TYPE,3,26,24,3,0x7,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_IDX_SET_PRIM_PRIM_TYPE(_) \
_(AR3D_IDX,SET_PRIM,PRIM_TYPE,POINTS,0) \
_(AR3D_IDX,SET_PRIM,PRIM_TYPE,LINES,1) \
_(AR3D_IDX,SET_PRIM,PRIM_TYPE,LINE_LOOP,2) \
_(AR3D_IDX,SET_PRIM,PRIM_TYPE,LINE_STRIP,3) \
_(AR3D_IDX,SET_PRIM,PRIM_TYPE,TRIS,4) \
_(AR3D_IDX,SET_PRIM,PRIM_TYPE,TRI_STRIP,5) \
_(AR3D_IDX,SET_PRIM,PRIM_TYPE,TRI_FAN,6)
#define AR3D_IDX_SET_PRIM_PRIM_TYPE_POINTS                      _MK_ENUM_CONST(0)
#define AR3D_IDX_SET_PRIM_PRIM_TYPE_LINES                       _MK_ENUM_CONST(1)
#define AR3D_IDX_SET_PRIM_PRIM_TYPE_LINE_LOOP                   _MK_ENUM_CONST(2)
#define AR3D_IDX_SET_PRIM_PRIM_TYPE_LINE_STRIP                  _MK_ENUM_CONST(3)
#define AR3D_IDX_SET_PRIM_PRIM_TYPE_TRIS                        _MK_ENUM_CONST(4)
#define AR3D_IDX_SET_PRIM_PRIM_TYPE_TRI_STRIP                   _MK_ENUM_CONST(5)
#define AR3D_IDX_SET_PRIM_PRIM_TYPE_TRI_FAN                     _MK_ENUM_CONST(6)

// Start vertex for TRI_FAN, or
// end vertex for LINE_LOOP
#define REG_FLD_AR3D_IDX_SET_PRIM_PIVOT_VTX(_) _(AR3D_IDX,SET_PRIM,PIVOT_VTX,20,19,0,3,0xfffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_SET_PRIM_PIVOT_VTX(_)

// This method draws the primitive as described above.  If a larger primitive is required, multiple
// DRAW_PRIM methods may be invoked (and context switching will be allowed between them).  Since
// context switching saves the state of SET_PRIM.PIVOT_VTX, anchored primitives can context switch).
// Note that DRAW_PRIM methods must be broken on whole-primitive boundaries, there is no state
// maintained in the hardware to continue a primitive across DRAW_PRIM methods. This means that:
//
// POINTS can be broken up on any boundary.
//
// LINES must have a multiple of two vertexes and must be broken on a modulo 2 boundary.
//
// LINE_LOOP must be broken into LINE_STRIPS followed by a LINE_LOOP, with each draw after
//   the first one resending the last vertex from the prior draw. Note that the first vertex
//   of the LINE_LOOP does NOT use PIVOT_VTX, only the automatic closing line segment uses it.
//
// LINE_STRIP must have at least two vertexes but can otherwise be broken on any boundary
//   with each subsequent draw resending the last vertex of the prior draw.
//
// TRIS must have a multiple of three vertexes and must be broken on a modulo 3 boundary.
//
// TRI_STRIP must have at least three vertexes and must be broken on a modulo 4 boundary
//   in order to maintain winding, with each subsequent draw resending the prior two vertexes
//   of the prior draw.
//
// TRI_FAN must have at least two vertexes (the third is implicit in the PIVOT_VTX) and can be
//   broken on any boundary, with each subsequent draw resending the last vertex of the prior
//   draw.
//
// Using a VTX_COUNT that is too small to generate a set of whole primitives for the current
// PRIM_TYPE will result in replication of the final vertex until a finishing triangle or
// line is produced.  This final trangle or line will be culled since it is degenerate.
//

// Register AR3D_IDX_DRAW_PRIM // Primitive draw command register
#define LIST_REG_FLD_AR3D_IDX_DRAW_PRIM(_) \
_(AR3D_IDX,DRAW_PRIM,VTX_COUNT) \
_(AR3D_IDX,DRAW_PRIM,START_VTX)
#define REG_AR3D_IDX_DRAW_PRIM(_) _(AR3D_IDX,DRAW_PRIM,0x123,0x23,1,1,0xffffffff,0x0,NOARY,FLD)
// Count of vertices, minus one
#define REG_FLD_AR3D_IDX_DRAW_PRIM_VTX_COUNT(_) _(AR3D_IDX,DRAW_PRIM,VTX_COUNT,12,31,20,2,0xfff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_DRAW_PRIM_VTX_COUNT(_)

// Starting offset
#define REG_FLD_AR3D_IDX_DRAW_PRIM_START_VTX(_) _(AR3D_IDX,DRAW_PRIM,START_VTX,20,19,0,2,0xfffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_DRAW_PRIM_START_VTX(_)

// IDX debug methods

// Register AR3D_IDX_IDX_CTL 
#define LIST_REG_FLD_AR3D_IDX_IDX_CTL(_) \
_(AR3D_IDX,IDX_CTL,INDEX_TOO_LARGE) \
_(AR3D_IDX,IDX_CTL,FORCE_TRANSFORM) \
_(AR3D_IDX,IDX_CTL,DMACACHE_DISABLE) \
_(AR3D_IDX,IDX_CTL,LATE_BINDING) \
_(AR3D_IDX,IDX_CTL,VAR_OBUF_SIZE) \
_(AR3D_IDX,IDX_CTL,VAR_IBUF_SIZE)
#define REG_AR3D_IDX_IDX_CTL(_) _(AR3D_IDX,IDX_CTL,0x124,0x24,1,1,0x3f,0x7,NOARY,FLD)
// Set to 1 by hw when an index
// is fetched in ELE32 mode that
// exceeds the max index value
#define REG_FLD_AR3D_IDX_IDX_CTL_INDEX_TOO_LARGE(_) _(AR3D_IDX,IDX_CTL,INDEX_TOO_LARGE,1,5,5,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_IDX_CTL_INDEX_TOO_LARGE(_)

// Force transform for every vertex
#define REG_FLD_AR3D_IDX_IDX_CTL_FORCE_TRANSFORM(_) _(AR3D_IDX,IDX_CTL,FORCE_TRANSFORM,1,4,4,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_IDX_CTL_FORCE_TRANSFORM(_)

// Disable DMA cache
#define REG_FLD_AR3D_IDX_IDX_CTL_DMACACHE_DISABLE(_) _(AR3D_IDX,IDX_CTL,DMACACHE_DISABLE,1,3,3,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_IDX_CTL_DMACACHE_DISABLE(_)

// Enable late binding
#define REG_FLD_AR3D_IDX_IDX_CTL_LATE_BINDING(_) _(AR3D_IDX,IDX_CTL,LATE_BINDING,1,2,2,3,0x1,0x1,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_IDX_CTL_LATE_BINDING(_)

// Enable OBUF compression
#define REG_FLD_AR3D_IDX_IDX_CTL_VAR_OBUF_SIZE(_) _(AR3D_IDX,IDX_CTL,VAR_OBUF_SIZE,1,1,1,3,0x1,0x1,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_IDX_CTL_VAR_OBUF_SIZE(_)

// Enable IBUF compression
#define REG_FLD_AR3D_IDX_IDX_CTL_VAR_IBUF_SIZE(_) _(AR3D_IDX,IDX_CTL,VAR_IBUF_SIZE,1,0,0,3,0x1,0x1,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_IDX_CTL_VAR_IBUF_SIZE(_)


// Register AR3D_IDX_IDX_STAT 
#define LIST_REG_FLD_AR3D_IDX_IDX_STAT(_) \
_(AR3D_IDX,IDX_STAT,IBUF_INUSE)
#define REG_AR3D_IDX_IDX_STAT(_) _(AR3D_IDX,IDX_STAT,0x125,0x25,1,1,0xff,0x0,NOARY,FLD)
// IBUF in-use status
#define REG_FLD_AR3D_IDX_IDX_STAT_IBUF_INUSE(_) _(AR3D_IDX,IDX_STAT,IBUF_INUSE,8,7,0,1,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_IDX_IDX_STAT_IBUF_INUSE(_)

//
// Memory Client Interface Async Fifo Optimization Register
// This can only be changed while the pipeline is completely idle.
// Read-Only Instance
//
// Memory Client Interface Fifo Control Register.
// The registers below allow to optimize the synchronization timing in
// the memory client asynchronous fifos. When they can be used depend on
// the client and memory controller clock ratio.
// Additionally, the RDMC_RDFAST/RDCL_RDFAST fields can increase power
// consumption if the asynchronous fifo is implemented as a real ram.
// There is no power impact on latch-based fifos. Flipflop-based fifos
// do not use these fields.
// See recommended settings below.
//
// !! IMPORTANT !!
// The register fields can only be changed when the memory client async
// fifos are empty.
//
// The register field ending with WRCL_MCLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one client clock cycle if
// the memory controller clock frequency is less or equal to twice the client
// clock frequency:
//
//      mcclk_freq <= 2 * clientclk_freq
//
// The register field ending with WRMC_CLLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one memory controller clock
// cycle if the client clock frequency is less or equal to twice the memory
// controller clock frequency:
//
//      clientclk_freq <= 2 * mcclk_freq
//
// The register field ending with RDMC_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one memory controller clock cycle.
//
// !! WARNING !!
// RDMC_RDFAST can be used along with WRCL_MCLE2X only when:
//
//       mcclk_freq <= clientclk_freq
//
// The register field ending with RDCL_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one client clock cycle.
//
// !! WARNING !!
// RDCL_RDFAST can be used along with WRMC_CLLE2X only when:
//
//       clientclk_freq <= mcclk_freq
//
// RECOMMENDED SETTINGS
// # Client writing to fifo, memory controller reading from fifo
// - mcclk_freq <= clientclk_freq
//     You can enable both RDMC_RDFAST and WRCL_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.
// - clientclk_freq < mcclk_freq <= 2 * clientclk_freq
//     You can enable RDMC_RDFAST or WRCL_MCLE2X, but because the client clock
//     is slower, you should enable only WRCL_MCLE2X.
// - 2 * clientclk_freq < mcclk_freq
//     You can only enable RDMC_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDMC_RDFAST.
//
// # Memory controller writing to fifo, client reading from fifo
// - clientclk_freq <= mcclk_freq
//     You can enable both RDCL_RDFAST and WRMC_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.
// - mcclk_freq < clientclk_freq <= 2 * mcclk_freq
//     You can enable RDCL_RDFAST or WRMC_CLLE2X, but because the memory controller
//     clock is slower, you should enable only WRMC_CLLE2X.
// - 2 * mcclk_freq < clientclk_freq
//     You can only enable RDCL_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDCL_RDFAST.
//

// Register AR3D_IDX_NV_MCCIF_FIFOCTRL_RO 
#define LIST_REG_FLD_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO(_) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST)
#define REG_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO(_) _(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,0x126,0x26,1,1,0xf,0x0,NOARY,FLD)
#define REG_FLD_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X(_) _(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X,1,0,0,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X(_) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X,DISABLE,0) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X,ENABLE,1)
#define AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST(_) _(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST,1,1,1,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST(_) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST,DISABLE,0) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST,ENABLE,1)
#define AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X(_) _(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X,1,2,2,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X(_) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X,DISABLE,0) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X,ENABLE,1)
#define AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST(_) _(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST,1,3,3,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST(_) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST,DISABLE,0) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST,ENABLE,1)
#define AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_IDX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST_ENABLE                       _MK_ENUM_CONST(1)

// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// ar3d_vpe.spec
#define NUM_IBUF        8
#define NUM_OBUF        16
#define IBUF_RAM_SIZE   64
#define OBUF_RAM_SIZE   64
// we inherit this from the class spec.  maybe we should default it?

// Register AR3D_VPE_MODE // VPE mode
#define LIST_REG_FLD_AR3D_VPE_MODE(_) \
_(AR3D_VPE,MODE,ZERO_MODE) \
_(AR3D_VPE,MODE,SHADER_VERSION)
#define REG_AR3D_VPE_MODE(_) _(AR3D_VPE,MODE,0x200,0x0,1,1,0x13,0x0,NOARY,FLD)
// Selects if -0 == +0
#define REG_FLD_AR3D_VPE_MODE_ZERO_MODE(_) _(AR3D_VPE,MODE,ZERO_MODE,1,4,4,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_VPE_MODE_ZERO_MODE(_) \
_(AR3D_VPE,MODE,ZERO_MODE,UNEQUAL,0) \
_(AR3D_VPE,MODE,ZERO_MODE,EQUAL,1)
#define AR3D_VPE_MODE_ZERO_MODE_UNEQUAL                 _MK_ENUM_CONST(0)
#define AR3D_VPE_MODE_ZERO_MODE_EQUAL                   _MK_ENUM_CONST(1)

// Selects shader version
#define REG_FLD_AR3D_VPE_MODE_SHADER_VERSION(_) _(AR3D_VPE,MODE,SHADER_VERSION,2,1,0,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_VPE_MODE_SHADER_VERSION(_) \
_(AR3D_VPE,MODE,SHADER_VERSION,V1,2) \
_(AR3D_VPE,MODE,SHADER_VERSION,V2,3) \
_(AR3D_VPE,MODE,SHADER_VERSION,V3,1)
#define AR3D_VPE_MODE_SHADER_VERSION_V1                 _MK_ENUM_CONST(2)
#define AR3D_VPE_MODE_SHADER_VERSION_V2                 _MK_ENUM_CONST(3)
#define AR3D_VPE_MODE_SHADER_VERSION_V3                 _MK_ENUM_CONST(1)

// VPE program instruction timeout
// This sets the maximum number of instructions executed before the the
// program is terminated.  If a program terminates due to timeout, the
// output is whatever results the program managed to write before
// termination.  The other outputs will be the output defaults (0, 0, 0, 1).
// There is no software-visible indication of this event (other than
// the program output).

// Register AR3D_VPE_TIMEOUT // VPE transform timeout
#define LIST_REG_FLD_AR3D_VPE_TIMEOUT(_) \
_(AR3D_VPE,TIMEOUT,MAX_INSN_COUNT)
#define REG_AR3D_VPE_TIMEOUT(_) _(AR3D_VPE,TIMEOUT,0x201,0x1,1,1,0xffff,0x0,NOARY,FLD)
// Max insns executed
#define REG_FLD_AR3D_VPE_TIMEOUT_MAX_INSN_COUNT(_) _(AR3D_VPE,TIMEOUT,MAX_INSN_COUNT,16,15,0,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_TIMEOUT_MAX_INSN_COUNT(_)

// Read limits for indexed constant reads.  Used to partition constant space
// between co-resident programs.  Out of range indexed reads return (0, 0, 0, 0).

// Register AR3D_VPE_CONST_READ_LIMIT // VPE constant read limits
#define LIST_REG_FLD_AR3D_VPE_CONST_READ_LIMIT(_) \
_(AR3D_VPE,CONST_READ_LIMIT,MAX_CONST_INDEX) \
_(AR3D_VPE,CONST_READ_LIMIT,MIN_CONST_INDEX)
#define REG_AR3D_VPE_CONST_READ_LIMIT(_) _(AR3D_VPE,CONST_READ_LIMIT,0x202,0x2,1,1,0xffffffff,0x0,NOARY,FLD)
// Upper bound for indexed const reads
#define REG_FLD_AR3D_VPE_CONST_READ_LIMIT_MAX_CONST_INDEX(_) _(AR3D_VPE,CONST_READ_LIMIT,MAX_CONST_INDEX,16,31,16,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_CONST_READ_LIMIT_MAX_CONST_INDEX(_)

// Lower bound for indexed const reads
#define REG_FLD_AR3D_VPE_CONST_READ_LIMIT_MIN_CONST_INDEX(_) _(AR3D_VPE,CONST_READ_LIMIT,MIN_CONST_INDEX,16,15,0,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_CONST_READ_LIMIT_MIN_CONST_INDEX(_)

// The branchbits (boolean) register is described in the VPE instruction set.
// However, here is a brief overview:
//
// The VPE supports branching, subroutine calls & looping; these are sideband
// registers that can be programmed for static flow control (i.e., branch based
// on a per-draw call boolean).  e.g, given an uber shader:
// 
//    if (g_hasLighting) {
//        normal_eye = mul(modelViewInverseTranspose, normal_object);
//        //..  lighting code
//     }
// 
// and then assign g_hasLighting to a branch bit so that you can enable/disable
// "lighting" without changing the shader program.  uber shaders are most relevant
// for OES1.X emulation, but these boolean branch bits can also be used for
// uniform booleans.
// The branch bits are used by the BRB (branch on boolean) and CLB (call on boolean)
// VPE instructions.   The branches are taken based on the state of these bits.

// Register AR3D_VPE_BRANCHBITS // VPE boolean branch bits
#define LIST_REG_FLD_AR3D_VPE_BRANCHBITS(_) \
_(AR3D_VPE,BRANCHBITS,BRANCHBITS)
#define REG_AR3D_VPE_BRANCHBITS(_) _(AR3D_VPE,BRANCHBITS,0x203,0x3,1,1,0xffffffff,0x0,NOARY,FLD)
// Boolean branch bits
#define REG_FLD_AR3D_VPE_BRANCHBITS_BRANCHBITS(_) _(AR3D_VPE,BRANCHBITS,BRANCHBITS,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_BRANCHBITS_BRANCHBITS(_)

// VPE program starting offset in instruction RAM.

// Register AR3D_VPE_START // VPE program start address
#define LIST_REG_FLD_AR3D_VPE_START(_) \
_(AR3D_VPE,START,START_ADDR)
#define REG_AR3D_VPE_START(_) _(AR3D_VPE,START,0x204,0x4,1,1,0xff,0x0,NOARY,FLD)
// VPE program start address
#define REG_FLD_AR3D_VPE_START_START_ADDR(_) _(AR3D_VPE,START,START_ADDR,8,7,0,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_START_START_ADDR(_)

//
// The VPE maps two resources: instructions and constants.
// These are both large, so we map them indirectly.  Writing to the base
// address sets the offset of the instruction word (128 bits) or the constant
// vector (4x32 bits) to be written or read.  This address should always be
// aligned to a four-DWORD boundary, since the VPE only supports reading and
// writing full 128-bit instructions and constant vectors even though
// INST_OFFSET and CONST_OFFSET address are DWORD-aligned.  Reads or writes
// of partial instructions or vectors is undefined.
// 
// It is the responsibility of s/w to feed the instructions and constants
// to the VPE (ie the VPE cannot pull instructions or constants).  The most
// efficient way for s/w to do this is using Host to GATHER the data.
//
// Every read or write to INST_DATA or CONST_DATA increments INST_OFFSET or
// CONST_OFFSET.  Every fourth write causes 128-bits of data to be written to
// the VPE; similarly, the first read of every four reads 128 bits and the
// next three reads return the remaining DWORDs.
// NOTE: VPE INST ram is a single ported ram and assumes that writes and reads
// do not happen in the same clock.  Since the reads and writes go through 
// different interfaces (with different latencies), a write  followed
// by a read in the next clock (or the subsequent clock) could result in the INSTR ram receiving read and
// write requests in the same clock.  This will result in wrong data being
// read out. To avoid this hazard writes and reads of the INST ram should
// be separated by atleast two clocks.

// Register AR3D_VPE_INST_OFFSET // VPE instruction indirect address
#define LIST_REG_FLD_AR3D_VPE_INST_OFFSET(_) \
_(AR3D_VPE,INST_OFFSET,INDEX)
#define REG_AR3D_VPE_INST_OFFSET(_) _(AR3D_VPE,INST_OFFSET,0x205,0x5,1,1,0x3ff,0x0,NOARY,FLD)
// Instruction offset (DWORDs)
// used by subsequent writes or
// reads of INST_DATA.  Each
// INST_DATA access increments
// this register.  Instructions
// should be written on 128-bit
// boundaries, so typically this
// register is written with the
// VPE instruction offset times four.
// Using INST_OFFSETs larger than
// NV_GR3D_VPE_NUM_INSNS * 4 is
// undefined.
#define REG_FLD_AR3D_VPE_INST_OFFSET_INDEX(_) _(AR3D_VPE,INST_OFFSET,INDEX,10,9,0,3,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_INST_OFFSET_INDEX(_)


// Register AR3D_VPE_INST_DATA // VPE instruction indirect data
#define LIST_REG_FLD_AR3D_VPE_INST_DATA(_) \
_(AR3D_VPE,INST_DATA,INST_DATA)
#define REG_AR3D_VPE_INST_DATA(_) _(AR3D_VPE,INST_DATA,0x206,0x6,1,1,0xffffffff,0x0,NOARY,FLD)
// Read or write data for the data
// word addressed by INST_OFFSET.
// Each read or write of this
// register increments INST_OFFSET.
// Instructions are 128 bits and
// must be completely read or written
// so typically this register must
// be accessed a multiple of four
// times.
#define REG_FLD_AR3D_VPE_INST_DATA_INST_DATA(_) _(AR3D_VPE,INST_DATA,INST_DATA,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_INST_DATA_INST_DATA(_)


// Register AR3D_VPE_CONST_OFFSET // VPE constant indirect address
#define LIST_REG_FLD_AR3D_VPE_CONST_OFFSET(_) \
_(AR3D_VPE,CONST_OFFSET,INDEX)
#define REG_AR3D_VPE_CONST_OFFSET(_) _(AR3D_VPE,CONST_OFFSET,0x207,0x7,1,1,0x3ff,0x0,NOARY,FLD)
// Constant vector offset (DWORDs)
// used by subsequent writes or
// reads of CONST_DATA.  Each
// CONST_DATA access increments
// this register.  Constant vectors
// should be written on 128-bit
// boundaries, so typically this
// register is written with the
// VPE constant offset times four.
// Using CONST_OFFSETs larger than
// NV_GR3D_VPE_NUM_CONST_VECS * 4
// is undefined.
#define REG_FLD_AR3D_VPE_CONST_OFFSET_INDEX(_) _(AR3D_VPE,CONST_OFFSET,INDEX,10,9,0,3,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_CONST_OFFSET_INDEX(_)


// Register AR3D_VPE_CONST_DATA // VPE constant indirect data
#define LIST_REG_FLD_AR3D_VPE_CONST_DATA(_) \
_(AR3D_VPE,CONST_DATA,CONST_DATA)
#define REG_AR3D_VPE_CONST_DATA(_) _(AR3D_VPE,CONST_DATA,0x208,0x8,1,1,0xffffffff,0x0,NOARY,FLD)
// Read or write data for the data
// word addressed by CONST_OFFSET.
// Each read or write of this
// register increments CONST_OFFSET.
// Constant vectors are 128 bits and
// must be completely read or written
// so typically this register must
// be accessed a multiple of four
// times.
#define REG_FLD_AR3D_VPE_CONST_DATA_CONST_DATA(_) _(AR3D_VPE,CONST_DATA,CONST_DATA,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_CONST_DATA_CONST_DATA(_)

// Debug and CYA methods

// Register AR3D_VPE_GEOM_STALL // Geometry stall
#define LIST_REG_FLD_AR3D_VPE_GEOM_STALL(_) \
_(AR3D_VPE,GEOM_STALL,VPE_STALL) \
_(AR3D_VPE,GEOM_STALL,VPE_FLUSH)
#define REG_AR3D_VPE_GEOM_STALL(_) _(AR3D_VPE,GEOM_STALL,0x209,0x9,1,1,0x100ff,0x0,NOARY,FLD)
// Number of stall cycles between
// thread launches
#define REG_FLD_AR3D_VPE_GEOM_STALL_VPE_STALL(_) _(AR3D_VPE,GEOM_STALL,VPE_STALL,8,7,0,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_GEOM_STALL_VPE_STALL(_)

// Cause a full flush between threads
#define REG_FLD_AR3D_VPE_GEOM_STALL_VPE_FLUSH(_) _(AR3D_VPE,GEOM_STALL,VPE_FLUSH,1,16,16,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_GEOM_STALL_VPE_FLUSH(_)

// Debug registers

// Register AR3D_VPE_VPE_CTRL // VPE control
#define LIST_REG_FLD_AR3D_VPE_VPE_CTRL(_) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEOR_CLKEN_OVR) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPERF_CLKEN_OVR) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEOD_CLKEN_OVR) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEOB_CLKEN_OVR) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEIB_CLKEN_OVR) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPECR_CLKEN_OVR) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEIR_CLKEN_OVR) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEDP_CLKEN_OVR) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_SPARE0) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_THR2_DISABLE) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_THR1_DISABLE) \
_(AR3D_VPE,VPE_CTRL,VPE_CTRL_THR0_DISABLE)
#define REG_AR3D_VPE_VPE_CTRL(_) _(AR3D_VPE,VPE_CTRL,0x20a,0xa,1,1,0xfff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEOR_CLKEN_OVR(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEOR_CLKEN_OVR,1,11,11,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEOR_CLKEN_OVR(_)

#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPERF_CLKEN_OVR(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPERF_CLKEN_OVR,1,10,10,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPERF_CLKEN_OVR(_)

#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEOD_CLKEN_OVR(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEOD_CLKEN_OVR,1,9,9,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEOD_CLKEN_OVR(_)

#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEOB_CLKEN_OVR(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEOB_CLKEN_OVR,1,8,8,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEOB_CLKEN_OVR(_)

#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEIB_CLKEN_OVR(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEIB_CLKEN_OVR,1,7,7,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEIB_CLKEN_OVR(_)

#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPECR_CLKEN_OVR(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPECR_CLKEN_OVR,1,6,6,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPECR_CLKEN_OVR(_)

#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEIR_CLKEN_OVR(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEIR_CLKEN_OVR,1,5,5,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEIR_CLKEN_OVR(_)

#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEDP_CLKEN_OVR(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_VPEDP_CLKEN_OVR,1,4,4,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_VPEDP_CLKEN_OVR(_)

#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_SPARE0(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_SPARE0,1,3,3,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_SPARE0(_)

// spare bit 1
#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_THR2_DISABLE(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_THR2_DISABLE,1,2,2,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_THR2_DISABLE(_)

// thread disables 
#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_THR1_DISABLE(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_THR1_DISABLE,1,1,1,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_THR1_DISABLE(_)

#define REG_FLD_AR3D_VPE_VPE_CTRL_VPE_CTRL_THR0_DISABLE(_) _(AR3D_VPE,VPE_CTRL,VPE_CTRL_THR0_DISABLE,1,0,0,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_CTRL_VPE_CTRL_THR0_DISABLE(_)


// Register AR3D_VPE_VPE_DEBUG // VPE debug
#define LIST_REG_FLD_AR3D_VPE_VPE_DEBUG(_) \
_(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_SPARE) \
_(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_VTF_SERIAL) \
_(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_THREAD_EXCLUSIVE) \
_(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_SERIAL_THREADS) \
_(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_OLDEST_FIRST) \
_(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_SERIALIZE_MODES) \
_(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_OBUF_SIZE) \
_(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_IBUF_SIZE)
#define REG_AR3D_VPE_VPE_DEBUG(_) _(AR3D_VPE,VPE_DEBUG,0x20b,0xb,1,1,0xff,0x3,NOARY,FLD)
#define REG_FLD_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_SPARE(_) _(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_SPARE,1,7,7,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_SPARE(_)

#define REG_FLD_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_VTF_SERIAL(_) _(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_VTF_SERIAL,1,6,6,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_VTF_SERIAL(_)

#define REG_FLD_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_THREAD_EXCLUSIVE(_) _(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_THREAD_EXCLUSIVE,1,5,5,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_THREAD_EXCLUSIVE(_)

#define REG_FLD_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_SERIAL_THREADS(_) _(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_SERIAL_THREADS,1,4,4,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_SERIAL_THREADS(_)

#define REG_FLD_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_OLDEST_FIRST(_) _(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_OLDEST_FIRST,1,3,3,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_OLDEST_FIRST(_)

#define REG_FLD_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_SERIALIZE_MODES(_) _(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_SERIALIZE_MODES,1,2,2,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_SERIALIZE_MODES(_)

// Obuf compression enable
#define REG_FLD_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_OBUF_SIZE(_) _(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_OBUF_SIZE,1,1,1,3,0x1,0x1,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_OBUF_SIZE(_)

// Ibuf compression enable
#define REG_FLD_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_IBUF_SIZE(_) _(AR3D_VPE,VPE_DEBUG,VPE_DEBUG_IBUF_SIZE,1,0,0,3,0x1,0x1,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_VPE_VPE_DEBUG_VPE_DEBUG_IBUF_SIZE(_)

// VPE microcode format
#define VPE_INSTR_REG_NOP       63
#define VPE_INSTR_OUT_NOP       31

// Packet VPE_4X_INSTR
#define LIST_PKT_FLD_VPE_4X_INSTR(_) \
_(VPE_4X_INSTR,LAST) \
_(VPE_4X_INSTR,CTX_INDX) \
_(VPE_4X_INSTR,OUT) \
_(VPE_4X_INSTR,SRT_ADDR) \
_(VPE_4X_INSTR,VWE) \
_(VPE_4X_INSTR,SWE) \
_(VPE_4X_INSTR,RC_TYPE) \
_(VPE_4X_INSTR,RC) \
_(VPE_4X_INSTR,RC_W_EXTR) \
_(VPE_4X_INSTR,RC_Z_EXTR) \
_(VPE_4X_INSTR,RC_Y_EXTR) \
_(VPE_4X_INSTR,RC_X_EXTR) \
_(VPE_4X_INSTR,RC_NEG) \
_(VPE_4X_INSTR,RB_TYPE) \
_(VPE_4X_INSTR,RB) \
_(VPE_4X_INSTR,RB_W_EXTR) \
_(VPE_4X_INSTR,RB_Z_EXTR) \
_(VPE_4X_INSTR,RB_Y_EXTR) \
_(VPE_4X_INSTR,RB_X_EXTR) \
_(VPE_4X_INSTR,RB_NEG) \
_(VPE_4X_INSTR,RA_TYPE) \
_(VPE_4X_INSTR,RA) \
_(VPE_4X_INSTR,RA_W_EXTR) \
_(VPE_4X_INSTR,RA_Z_EXTR) \
_(VPE_4X_INSTR,RA_Y_EXTR) \
_(VPE_4X_INSTR,RA_X_EXTR) \
_(VPE_4X_INSTR,RA_NEG) \
_(VPE_4X_INSTR,IBUF_ADDR) \
_(VPE_4X_INSTR,CTX_ADDR) \
_(VPE_4X_INSTR,OPCODE_V) \
_(VPE_4X_INSTR,OPCODE_S) \
_(VPE_4X_INSTR,SCALAR_SEL) \
_(VPE_4X_INSTR,RCC_W_EXTR) \
_(VPE_4X_INSTR,RCC_Z_EXTR) \
_(VPE_4X_INSTR,RCC_Y_EXTR) \
_(VPE_4X_INSTR,RCC_X_EXTR) \
_(VPE_4X_INSTR,RCC_COMPARE) \
_(VPE_4X_INSTR,MOD_WE) \
_(VPE_4X_INSTR,RCC_WEN) \
_(VPE_4X_INSTR,RT_ADDR) \
_(VPE_4X_INSTR,RA_ABS) \
_(VPE_4X_INSTR,RB_ABS) \
_(VPE_4X_INSTR,RC_ABS) \
_(VPE_4X_INSTR,OFFREG_RA) \
_(VPE_4X_INSTR,CC_SEL) \
_(VPE_4X_INSTR,SATURATE) \
_(VPE_4X_INSTR,IBUF_INDX) \
_(VPE_4X_INSTR,OBUF_INDX) \
_(VPE_4X_INSTR,CC_WR_SEL) \
_(VPE_4X_INSTR,OUT_SEL)
#define PKT_VPE_4X_INSTR(_) _(VPE_4X_INSTR,127,FLD)
// last instruction
#define PKT_FLD_VPE_4X_INSTR_LAST(_) _(VPE_4X_INSTR,LAST,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_LAST(_)
// const indexed addr
#define PKT_FLD_VPE_4X_INSTR_CTX_INDX(_) _(VPE_4X_INSTR,CTX_INDX,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_CTX_INDX(_)
// vertex output write addr
#define PKT_FLD_VPE_4X_INSTR_OUT(_) _(VPE_4X_INSTR,OUT,0,5,6,2,0x1f,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_OUT(_)
// scalar reg file write addr
#define PKT_FLD_VPE_4X_INSTR_SRT_ADDR(_) _(VPE_4X_INSTR,SRT_ADDR,0,6,12,7,0x3f,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_SRT_ADDR(_)
// vector write mask
#define PKT_FLD_VPE_4X_INSTR_VWE(_) _(VPE_4X_INSTR,VWE,0,4,16,13,0xf,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_VWE(_)
// scalar write mask
#define PKT_FLD_VPE_4X_INSTR_SWE(_) _(VPE_4X_INSTR,SWE,0,4,20,17,0xf,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_SWE(_)
// c mux (NA,r,v,c)
#define PKT_FLD_VPE_4X_INSTR_RC_TYPE(_) _(VPE_4X_INSTR,RC_TYPE,0,2,22,21,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RC_TYPE(_) \
_(VPE_4X_INSTR,RC_TYPE,INVAL,0) \
_(VPE_4X_INSTR,RC_TYPE,REG,1) \
_(VPE_4X_INSTR,RC_TYPE,BUF,2) \
_(VPE_4X_INSTR,RC_TYPE,CTX,3)
// c reg read
#define PKT_FLD_VPE_4X_INSTR_RC(_) _(VPE_4X_INSTR,RC,0,6,28,23,0x3f,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RC(_)
// c w swizzle
#define PKT_FLD_VPE_4X_INSTR_RC_W_EXTR(_) _(VPE_4X_INSTR,RC_W_EXTR,0,2,30,29,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RC_W_EXTR(_) \
_(VPE_4X_INSTR,RC_W_EXTR,X,0) \
_(VPE_4X_INSTR,RC_W_EXTR,Y,1) \
_(VPE_4X_INSTR,RC_W_EXTR,Z,2) \
_(VPE_4X_INSTR,RC_W_EXTR,W,3)
// c z swizzle
#define PKT_FLD_VPE_4X_INSTR_RC_Z_EXTR(_) _(VPE_4X_INSTR,RC_Z_EXTR,0,2,32,31,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RC_Z_EXTR(_) \
_(VPE_4X_INSTR,RC_Z_EXTR,X,0) \
_(VPE_4X_INSTR,RC_Z_EXTR,Y,1) \
_(VPE_4X_INSTR,RC_Z_EXTR,Z,2) \
_(VPE_4X_INSTR,RC_Z_EXTR,W,3)
// c y swizzle
#define PKT_FLD_VPE_4X_INSTR_RC_Y_EXTR(_) _(VPE_4X_INSTR,RC_Y_EXTR,0,2,34,33,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RC_Y_EXTR(_) \
_(VPE_4X_INSTR,RC_Y_EXTR,X,0) \
_(VPE_4X_INSTR,RC_Y_EXTR,Y,1) \
_(VPE_4X_INSTR,RC_Y_EXTR,Z,2) \
_(VPE_4X_INSTR,RC_Y_EXTR,W,3)
// c x swizzle
#define PKT_FLD_VPE_4X_INSTR_RC_X_EXTR(_) _(VPE_4X_INSTR,RC_X_EXTR,0,2,36,35,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RC_X_EXTR(_) \
_(VPE_4X_INSTR,RC_X_EXTR,X,0) \
_(VPE_4X_INSTR,RC_X_EXTR,Y,1) \
_(VPE_4X_INSTR,RC_X_EXTR,Z,2) \
_(VPE_4X_INSTR,RC_X_EXTR,W,3)
// c negate
#define PKT_FLD_VPE_4X_INSTR_RC_NEG(_) _(VPE_4X_INSTR,RC_NEG,0,1,37,37,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RC_NEG(_)
// b mux (NA,r,v,c)
#define PKT_FLD_VPE_4X_INSTR_RB_TYPE(_) _(VPE_4X_INSTR,RB_TYPE,0,2,39,38,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RB_TYPE(_) \
_(VPE_4X_INSTR,RB_TYPE,INVAL,0) \
_(VPE_4X_INSTR,RB_TYPE,REG,1) \
_(VPE_4X_INSTR,RB_TYPE,BUF,2) \
_(VPE_4X_INSTR,RB_TYPE,CTX,3)
// b reg read
#define PKT_FLD_VPE_4X_INSTR_RB(_) _(VPE_4X_INSTR,RB,0,6,45,40,0x3f,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RB(_)
// b w swizzle
#define PKT_FLD_VPE_4X_INSTR_RB_W_EXTR(_) _(VPE_4X_INSTR,RB_W_EXTR,0,2,47,46,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RB_W_EXTR(_) \
_(VPE_4X_INSTR,RB_W_EXTR,X,0) \
_(VPE_4X_INSTR,RB_W_EXTR,Y,1) \
_(VPE_4X_INSTR,RB_W_EXTR,Z,2) \
_(VPE_4X_INSTR,RB_W_EXTR,W,3)
// b z swizzle
#define PKT_FLD_VPE_4X_INSTR_RB_Z_EXTR(_) _(VPE_4X_INSTR,RB_Z_EXTR,0,2,49,48,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RB_Z_EXTR(_) \
_(VPE_4X_INSTR,RB_Z_EXTR,X,0) \
_(VPE_4X_INSTR,RB_Z_EXTR,Y,1) \
_(VPE_4X_INSTR,RB_Z_EXTR,Z,2) \
_(VPE_4X_INSTR,RB_Z_EXTR,W,3)
// b y swizzle
#define PKT_FLD_VPE_4X_INSTR_RB_Y_EXTR(_) _(VPE_4X_INSTR,RB_Y_EXTR,0,2,51,50,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RB_Y_EXTR(_) \
_(VPE_4X_INSTR,RB_Y_EXTR,X,0) \
_(VPE_4X_INSTR,RB_Y_EXTR,Y,1) \
_(VPE_4X_INSTR,RB_Y_EXTR,Z,2) \
_(VPE_4X_INSTR,RB_Y_EXTR,W,3)
// b x swizzle
#define PKT_FLD_VPE_4X_INSTR_RB_X_EXTR(_) _(VPE_4X_INSTR,RB_X_EXTR,0,2,53,52,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RB_X_EXTR(_) \
_(VPE_4X_INSTR,RB_X_EXTR,X,0) \
_(VPE_4X_INSTR,RB_X_EXTR,Y,1) \
_(VPE_4X_INSTR,RB_X_EXTR,Z,2) \
_(VPE_4X_INSTR,RB_X_EXTR,W,3)
// b negate
#define PKT_FLD_VPE_4X_INSTR_RB_NEG(_) _(VPE_4X_INSTR,RB_NEG,0,1,54,54,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RB_NEG(_)
// a mux (NA,r,v,c)
#define PKT_FLD_VPE_4X_INSTR_RA_TYPE(_) _(VPE_4X_INSTR,RA_TYPE,0,2,56,55,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RA_TYPE(_) \
_(VPE_4X_INSTR,RA_TYPE,INVAL,0) \
_(VPE_4X_INSTR,RA_TYPE,REG,1) \
_(VPE_4X_INSTR,RA_TYPE,BUF,2) \
_(VPE_4X_INSTR,RA_TYPE,CTX,3)
// a reg read
#define PKT_FLD_VPE_4X_INSTR_RA(_) _(VPE_4X_INSTR,RA,0,6,62,57,0x3f,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RA(_)
// a w swizzle
#define PKT_FLD_VPE_4X_INSTR_RA_W_EXTR(_) _(VPE_4X_INSTR,RA_W_EXTR,0,2,64,63,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RA_W_EXTR(_) \
_(VPE_4X_INSTR,RA_W_EXTR,X,0) \
_(VPE_4X_INSTR,RA_W_EXTR,Y,1) \
_(VPE_4X_INSTR,RA_W_EXTR,Z,2) \
_(VPE_4X_INSTR,RA_W_EXTR,W,3)
// a z swizzle
#define PKT_FLD_VPE_4X_INSTR_RA_Z_EXTR(_) _(VPE_4X_INSTR,RA_Z_EXTR,0,2,66,65,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RA_Z_EXTR(_) \
_(VPE_4X_INSTR,RA_Z_EXTR,X,0) \
_(VPE_4X_INSTR,RA_Z_EXTR,Y,1) \
_(VPE_4X_INSTR,RA_Z_EXTR,Z,2) \
_(VPE_4X_INSTR,RA_Z_EXTR,W,3)
// a y swizzle
#define PKT_FLD_VPE_4X_INSTR_RA_Y_EXTR(_) _(VPE_4X_INSTR,RA_Y_EXTR,0,2,68,67,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RA_Y_EXTR(_) \
_(VPE_4X_INSTR,RA_Y_EXTR,X,0) \
_(VPE_4X_INSTR,RA_Y_EXTR,Y,1) \
_(VPE_4X_INSTR,RA_Y_EXTR,Z,2) \
_(VPE_4X_INSTR,RA_Y_EXTR,W,3)
// a x swizzle
#define PKT_FLD_VPE_4X_INSTR_RA_X_EXTR(_) _(VPE_4X_INSTR,RA_X_EXTR,0,2,70,69,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RA_X_EXTR(_) \
_(VPE_4X_INSTR,RA_X_EXTR,X,0) \
_(VPE_4X_INSTR,RA_X_EXTR,Y,1) \
_(VPE_4X_INSTR,RA_X_EXTR,Z,2) \
_(VPE_4X_INSTR,RA_X_EXTR,W,3)
// a negate
#define PKT_FLD_VPE_4X_INSTR_RA_NEG(_) _(VPE_4X_INSTR,RA_NEG,0,1,71,71,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RA_NEG(_)
// vertex read addr
#define PKT_FLD_VPE_4X_INSTR_IBUF_ADDR(_) _(VPE_4X_INSTR,IBUF_ADDR,0,4,75,72,0xf,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_IBUF_ADDR(_)
// const read addr
#define PKT_FLD_VPE_4X_INSTR_CTX_ADDR(_) _(VPE_4X_INSTR,CTX_ADDR,0,10,85,76,0x3ff,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_CTX_ADDR(_)
// vector op
#define PKT_FLD_VPE_4X_INSTR_OPCODE_V(_) _(VPE_4X_INSTR,OPCODE_V,0,5,90,86,0x1f,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_OPCODE_V(_) \
_(VPE_4X_INSTR,OPCODE_V,NOP,0) \
_(VPE_4X_INSTR,OPCODE_V,MOV,1) \
_(VPE_4X_INSTR,OPCODE_V,MUL,2) \
_(VPE_4X_INSTR,OPCODE_V,ADD,3) \
_(VPE_4X_INSTR,OPCODE_V,MAD,4) \
_(VPE_4X_INSTR,OPCODE_V,DP3,5) \
_(VPE_4X_INSTR,OPCODE_V,DPH,6) \
_(VPE_4X_INSTR,OPCODE_V,DP4,7) \
_(VPE_4X_INSTR,OPCODE_V,DST,8) \
_(VPE_4X_INSTR,OPCODE_V,MIN,9) \
_(VPE_4X_INSTR,OPCODE_V,MAX,10) \
_(VPE_4X_INSTR,OPCODE_V,SLT,11) \
_(VPE_4X_INSTR,OPCODE_V,SGE,12) \
_(VPE_4X_INSTR,OPCODE_V,ARL,13) \
_(VPE_4X_INSTR,OPCODE_V,FRC,14) \
_(VPE_4X_INSTR,OPCODE_V,FLR,15) \
_(VPE_4X_INSTR,OPCODE_V,SEQ,16) \
_(VPE_4X_INSTR,OPCODE_V,SFL,17) \
_(VPE_4X_INSTR,OPCODE_V,SGT,18) \
_(VPE_4X_INSTR,OPCODE_V,SLE,19) \
_(VPE_4X_INSTR,OPCODE_V,SNE,20) \
_(VPE_4X_INSTR,OPCODE_V,STR,21) \
_(VPE_4X_INSTR,OPCODE_V,SSG,22) \
_(VPE_4X_INSTR,OPCODE_V,ARR,23) \
_(VPE_4X_INSTR,OPCODE_V,MVA,24) \
_(VPE_4X_INSTR,OPCODE_V,TXL,25) \
_(VPE_4X_INSTR,OPCODE_V,PSH,26) \
_(VPE_4X_INSTR,OPCODE_V,POP,27) \
_(VPE_4X_INSTR,OPCODE_V,RSV0,28) \
_(VPE_4X_INSTR,OPCODE_V,RSV1,29) \
_(VPE_4X_INSTR,OPCODE_V,RSV2,30) \
_(VPE_4X_INSTR,OPCODE_V,RSV3,31)
// scalar op
#define PKT_FLD_VPE_4X_INSTR_OPCODE_S(_) _(VPE_4X_INSTR,OPCODE_S,0,5,95,91,0x1f,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_OPCODE_S(_) \
_(VPE_4X_INSTR,OPCODE_S,NOP,0) \
_(VPE_4X_INSTR,OPCODE_S,MOV,1) \
_(VPE_4X_INSTR,OPCODE_S,RCP,2) \
_(VPE_4X_INSTR,OPCODE_S,RCC,3) \
_(VPE_4X_INSTR,OPCODE_S,RSQ,4) \
_(VPE_4X_INSTR,OPCODE_S,EXP,5) \
_(VPE_4X_INSTR,OPCODE_S,LOG,6) \
_(VPE_4X_INSTR,OPCODE_S,LIT,7) \
_(VPE_4X_INSTR,OPCODE_S,BRA,8) \
_(VPE_4X_INSTR,OPCODE_S,BRI,9) \
_(VPE_4X_INSTR,OPCODE_S,CLA,10) \
_(VPE_4X_INSTR,OPCODE_S,CLI,11) \
_(VPE_4X_INSTR,OPCODE_S,RET,12) \
_(VPE_4X_INSTR,OPCODE_S,LG2,13) \
_(VPE_4X_INSTR,OPCODE_S,EX2,14) \
_(VPE_4X_INSTR,OPCODE_S,SIN,15) \
_(VPE_4X_INSTR,OPCODE_S,COS,16) \
_(VPE_4X_INSTR,OPCODE_S,BRB,17) \
_(VPE_4X_INSTR,OPCODE_S,CLB,18) \
_(VPE_4X_INSTR,OPCODE_S,PSH,19) \
_(VPE_4X_INSTR,OPCODE_S,POP,20) \
_(VPE_4X_INSTR,OPCODE_S,RSV0,21)
// address scalar select
#define PKT_FLD_VPE_4X_INSTR_SCALAR_SEL(_) _(VPE_4X_INSTR,SCALAR_SEL,0,2,97,96,0x3,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_SCALAR_SEL(_)
// cc w swizzle
#define PKT_FLD_VPE_4X_INSTR_RCC_W_EXTR(_) _(VPE_4X_INSTR,RCC_W_EXTR,0,2,99,98,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RCC_W_EXTR(_) \
_(VPE_4X_INSTR,RCC_W_EXTR,X,0) \
_(VPE_4X_INSTR,RCC_W_EXTR,Y,1) \
_(VPE_4X_INSTR,RCC_W_EXTR,Z,2) \
_(VPE_4X_INSTR,RCC_W_EXTR,W,3)
// cc z swizzle
#define PKT_FLD_VPE_4X_INSTR_RCC_Z_EXTR(_) _(VPE_4X_INSTR,RCC_Z_EXTR,0,2,101,100,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RCC_Z_EXTR(_) \
_(VPE_4X_INSTR,RCC_Z_EXTR,X,0) \
_(VPE_4X_INSTR,RCC_Z_EXTR,Y,1) \
_(VPE_4X_INSTR,RCC_Z_EXTR,Z,2) \
_(VPE_4X_INSTR,RCC_Z_EXTR,W,3)
// cc y swizzle
#define PKT_FLD_VPE_4X_INSTR_RCC_Y_EXTR(_) _(VPE_4X_INSTR,RCC_Y_EXTR,0,2,103,102,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RCC_Y_EXTR(_) \
_(VPE_4X_INSTR,RCC_Y_EXTR,X,0) \
_(VPE_4X_INSTR,RCC_Y_EXTR,Y,1) \
_(VPE_4X_INSTR,RCC_Y_EXTR,Z,2) \
_(VPE_4X_INSTR,RCC_Y_EXTR,W,3)
// cc x swizzle
#define PKT_FLD_VPE_4X_INSTR_RCC_X_EXTR(_) _(VPE_4X_INSTR,RCC_X_EXTR,0,2,105,104,0x3,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RCC_X_EXTR(_) \
_(VPE_4X_INSTR,RCC_X_EXTR,X,0) \
_(VPE_4X_INSTR,RCC_X_EXTR,Y,1) \
_(VPE_4X_INSTR,RCC_X_EXTR,Z,2) \
_(VPE_4X_INSTR,RCC_X_EXTR,W,3)
// cc compare
#define PKT_FLD_VPE_4X_INSTR_RCC_COMPARE(_) _(VPE_4X_INSTR,RCC_COMPARE,0,3,108,106,0x7,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RCC_COMPARE(_) \
_(VPE_4X_INSTR,RCC_COMPARE,FALSE,0) \
_(VPE_4X_INSTR,RCC_COMPARE,LT,1) \
_(VPE_4X_INSTR,RCC_COMPARE,EQ,2) \
_(VPE_4X_INSTR,RCC_COMPARE,LE,3) \
_(VPE_4X_INSTR,RCC_COMPARE,GT,4) \
_(VPE_4X_INSTR,RCC_COMPARE,NE,5) \
_(VPE_4X_INSTR,RCC_COMPARE,GE,6) \
_(VPE_4X_INSTR,RCC_COMPARE,TRUE,7)
// writemask mod
#define PKT_FLD_VPE_4X_INSTR_MOD_WE(_) _(VPE_4X_INSTR,MOD_WE,0,1,109,109,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_MOD_WE(_)
// cc write enable
#define PKT_FLD_VPE_4X_INSTR_RCC_WEN(_) _(VPE_4X_INSTR,RCC_WEN,0,1,110,110,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RCC_WEN(_)
// vector reg write addr
#define PKT_FLD_VPE_4X_INSTR_RT_ADDR(_) _(VPE_4X_INSTR,RT_ADDR,0,6,116,111,0x3f,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RT_ADDR(_)
// a abs val
#define PKT_FLD_VPE_4X_INSTR_RA_ABS(_) _(VPE_4X_INSTR,RA_ABS,0,1,117,117,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RA_ABS(_)
// b abs val
#define PKT_FLD_VPE_4X_INSTR_RB_ABS(_) _(VPE_4X_INSTR,RB_ABS,0,1,118,118,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RB_ABS(_)
// c abs val
#define PKT_FLD_VPE_4X_INSTR_RC_ABS(_) _(VPE_4X_INSTR,RC_ABS,0,1,119,119,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_RC_ABS(_)
// addr reg read addr
#define PKT_FLD_VPE_4X_INSTR_OFFREG_RA(_) _(VPE_4X_INSTR,OFFREG_RA,0,1,120,120,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_OFFREG_RA(_)
// condition code sel
#define PKT_FLD_VPE_4X_INSTR_CC_SEL(_) _(VPE_4X_INSTR,CC_SEL,0,1,121,121,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_CC_SEL(_)
// saturate output
#define PKT_FLD_VPE_4X_INSTR_SATURATE(_) _(VPE_4X_INSTR,SATURATE,0,1,122,122,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_SATURATE(_)
// vertex read indexed addr
#define PKT_FLD_VPE_4X_INSTR_IBUF_INDX(_) _(VPE_4X_INSTR,IBUF_INDX,0,1,123,123,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_IBUF_INDX(_)
// vertex write indexed addr
#define PKT_FLD_VPE_4X_INSTR_OBUF_INDX(_) _(VPE_4X_INSTR,OBUF_INDX,0,1,124,124,0x1,NOENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_OBUF_INDX(_)
// cc write source/mask sel
#define PKT_FLD_VPE_4X_INSTR_CC_WR_SEL(_) _(VPE_4X_INSTR,CC_WR_SEL,0,1,125,125,0x1,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_CC_WR_SEL(_) \
_(VPE_4X_INSTR,CC_WR_SEL,SCALAR,0) \
_(VPE_4X_INSTR,CC_WR_SEL,VECTOR,1)
// vertex write source/mask sel
#define PKT_FLD_VPE_4X_INSTR_OUT_SEL(_) _(VPE_4X_INSTR,OUT_SEL,0,1,126,126,0x1,ENM)
#define LIST_PKT_ENM_VPE_4X_INSTR_OUT_SEL(_) \
_(VPE_4X_INSTR,OUT_SEL,SCALAR,0) \
_(VPE_4X_INSTR,OUT_SEL,VECTOR,1)
// --------------------------------------------------------------------------
//
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// This file has all the reg/packet definitions related to Setup unit in AR
// This file is included in ar3d.spec
//
//
// clip/setup instruction format
//
// The primary function of these instructions is to link vertex shader outputs with fragment shader inputs.  They direct the clip block to 
// copy VPE OBUF attributes to atrast TRAM rows, where they are read by IPA instructions in the fragment shader.  A secondary function is to 
// provide Z to atrast for late Z processing (i.e., when qrast cannot perform early Z.)
//
// Instructions are 64 bits wide; each is divided into two 32-bit halves called EVEN and ODD.
// The EVEN halves are written to even addresses (0x300, 0x302, ...) and ODD halves to odd addresses (0x301, 0x303, ...).
// Two overlapping sets of fields are given below; EVEN words contain SRC, VC_ROW, TRAM_ROW, Px_LINE_WIDTH, Px_LINE_LENGTH, and Px_POINT.
// ODD words contain Px_TRAM_COL, Px_TRAM_FMT, and Px_TRI_SHADE_MODE.
//
// If SRC is VPE,
// Each VPE attribute (row) maps to exactly one TRAM row, but to arbitrary
// columns.  VC_ROW gives the VPE attribute number. Each P<N>_TRAM_FMT/COL specifies the destination format 
// and location for VPE column N.  VC_ROW uses post-obuf-compression attribute number.  idx's OUTPUT_ATTR_MASK gives the set of valid
// pre-compression obuf attributes; idx and vpe then compress that mask to remove unused slots.  For example, of OUTPUT_ATTR_MASK is 0x9, then
// the valid pre-compression attributes are 0 and 3.  The valid post-compression attributes are 0 and 1.  Clip's VC_ROW uses the latter
// numbering.   Obuf compression reduces the size of each vertex, while allowing vpe shader program to use fixed attribute numbering.
// It permits more vertices to remain cached in obuf, improving performance.
//
// If SRC is not VPE, then only P0_* are used.  A special internal value is used rather than a VPE OBUF attribute.
//
// LINE and POINT primitives are special: they are composed of four corner vertices which are 
// synthesized from 1 or 2 input vertices.  Attributes must likewise be synthesized.  
// Each attribute can be held constant across width and/or height, or interpolated.
// If constant, the input vertex attribute(s) are used unchanged.
//   For points: if "S", attribute is varied from 0 to 1 in X direction.
//               if "T", attribute is varied from 0 to 1 in Y direction. (*)
//               if "DISABLE", attribute is constant (from vertex value)
//   For lines: When LINE_LENGTH is VARYING, attribute is interpolated between V0 and V1 values along length (and LINE_WIDTH is ignored).
//              Else if LINE_LENGTH is CONST and  LINE_WIDTH is VARYING, then attribute is varied from 0 to LINE_MAX_ATTR_W across width.
//              Else if both CONST, then V1 value is used.
//
// Examples:
// 1. for point sprites, texture coordinate S attribute should be Px_POINT=S, and T Px_POINT=T.
//    but other attributes should be set to Px_POINT=DISABLE.  POINT_MAX_S and POINT_MAX_T are 1.0.
//    The texture coordinates will be generated as [0, POINT_MAX_S].
// 2. for antialiased smooth-shaded lines, all attributes should probably be set to LINE_LENGTH=VARYING,
//    and LINE_WIDTH=CONST
//    except the antialiasing texture which should be LINE_WIDTH=VARYING.
//    The minumum value in T can be changed from 0.0 using LINE_MIN_ATTR_W register (sc25 only).
//
// (*) when POINT_PARAM.SCALE_MODE is SHEARED, the "x" and "y" directions are not necessary aligned with X and Y axis,
//     but rather are aligned with the shearing vectors.
//     The maximum value in S and T can be changed from 1.0 using the POINT_MAX_S and POINT_MAX_T registers.
//     The minimum value in S and T can be changed from 0.0 using the POINT_MIN_S and POINT_MIN_T registers (sc25 only).
//

// Register AR3D_SU_INST 
#define LIST_REG_FLD_AR3D_SU_INST(_) \
_(AR3D_SU,INST,SRC) \
_(AR3D_SU,INST,VC_ROW) \
_(AR3D_SU,INST,TRAM_ROW) \
_(AR3D_SU,INST,P0_LINE_WIDTH) \
_(AR3D_SU,INST,P0_LINE_LENGTH) \
_(AR3D_SU,INST,P0_POINT) \
_(AR3D_SU,INST,P1_LINE_WIDTH) \
_(AR3D_SU,INST,P1_LINE_LENGTH) \
_(AR3D_SU,INST,P1_POINT) \
_(AR3D_SU,INST,P2_LINE_WIDTH) \
_(AR3D_SU,INST,P2_LINE_LENGTH) \
_(AR3D_SU,INST,P2_POINT) \
_(AR3D_SU,INST,P3_LINE_WIDTH) \
_(AR3D_SU,INST,P3_LINE_LENGTH) \
_(AR3D_SU,INST,P3_POINT) \
_(AR3D_SU,INST,P0_TRAM_COL) \
_(AR3D_SU,INST,P0_TRAM_FMT) \
_(AR3D_SU,INST,P1_TRAM_COL) \
_(AR3D_SU,INST,P1_TRAM_FMT) \
_(AR3D_SU,INST,P2_TRAM_COL) \
_(AR3D_SU,INST,P2_TRAM_FMT) \
_(AR3D_SU,INST,P3_TRAM_COL) \
_(AR3D_SU,INST,P3_TRAM_FMT) \
_(AR3D_SU,INST,P0_TRI_SHADE_MODE) \
_(AR3D_SU,INST,P1_TRI_SHADE_MODE) \
_(AR3D_SU,INST,P2_TRI_SHADE_MODE) \
_(AR3D_SU,INST,P3_TRI_SHADE_MODE)
#define REG_AR3D_SU_INST(_) _(AR3D_SU,INST,0x300,0x0,64,1,0xffffffff,0x0,ARY,FLD)
// source of attribute for TRAM
#define REG_FLD_AR3D_SU_INST_SRC(_) _(AR3D_SU,INST,SRC,2,1,0,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_SRC(_) \
_(AR3D_SU,INST,SRC,VPE,0) \
_(AR3D_SU,INST,SRC,Z,1)
#define AR3D_SU_INST_SRC_VPE                    _MK_ENUM_CONST(0)    // // from a VPE attribute

#define AR3D_SU_INST_SRC_Z                      _MK_ENUM_CONST(1)    // // from vertex Z (post-viewport/depthrange): only P0 is valid


// VPE OBUF attribute row (when SRC=VPE)
#define REG_FLD_AR3D_SU_INST_VC_ROW(_) _(AR3D_SU,INST,VC_ROW,4,6,3,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_INST_VC_ROW(_)

// TRAM destination row
#define REG_FLD_AR3D_SU_INST_TRAM_ROW(_) _(AR3D_SU,INST,TRAM_ROW,6,14,9,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_INST_TRAM_ROW(_)

// How attribute 0 is generated across a line's width
#define REG_FLD_AR3D_SU_INST_P0_LINE_WIDTH(_) _(AR3D_SU,INST,P0_LINE_WIDTH,1,16,16,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P0_LINE_WIDTH(_) \
_(AR3D_SU,INST,P0_LINE_WIDTH,CONST,0) \
_(AR3D_SU,INST,P0_LINE_WIDTH,VARYING,1)
#define AR3D_SU_INST_P0_LINE_WIDTH_CONST                        _MK_ENUM_CONST(0)    // // constant across width (the typical case)

#define AR3D_SU_INST_P0_LINE_WIDTH_VARYING                      _MK_ENUM_CONST(1)    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 0 is generated along a line's length
#define REG_FLD_AR3D_SU_INST_P0_LINE_LENGTH(_) _(AR3D_SU,INST,P0_LINE_LENGTH,1,17,17,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P0_LINE_LENGTH(_) \
_(AR3D_SU,INST,P0_LINE_LENGTH,VARYING,0) \
_(AR3D_SU,INST,P0_LINE_LENGTH,CONST,1)
#define AR3D_SU_INST_P0_LINE_LENGTH_VARYING                     _MK_ENUM_CONST(0)    // // Interpolated between two vertices' attributes (the typical case)

#define AR3D_SU_INST_P0_LINE_LENGTH_CONST                       _MK_ENUM_CONST(1)    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 0 is generated across point
#define REG_FLD_AR3D_SU_INST_P0_POINT(_) _(AR3D_SU,INST,P0_POINT,2,19,18,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P0_POINT(_) \
_(AR3D_SU,INST,P0_POINT,DISABLE,0) \
_(AR3D_SU,INST,P0_POINT,S,1) \
_(AR3D_SU,INST,P0_POINT,T,2)
#define AR3D_SU_INST_P0_POINT_DISABLE                   _MK_ENUM_CONST(0)    // // constant (typical case for traditional points)

#define AR3D_SU_INST_P0_POINT_S                 _MK_ENUM_CONST(1)    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define AR3D_SU_INST_P0_POINT_T                 _MK_ENUM_CONST(2)    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 1 is generated across a line's width (if LINE_LENGTH=CONST).
#define REG_FLD_AR3D_SU_INST_P1_LINE_WIDTH(_) _(AR3D_SU,INST,P1_LINE_WIDTH,1,20,20,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P1_LINE_WIDTH(_) \
_(AR3D_SU,INST,P1_LINE_WIDTH,CONST,0) \
_(AR3D_SU,INST,P1_LINE_WIDTH,VARYING,1)
#define AR3D_SU_INST_P1_LINE_WIDTH_CONST                        _MK_ENUM_CONST(0)    // // constant across width (the typical case)

#define AR3D_SU_INST_P1_LINE_WIDTH_VARYING                      _MK_ENUM_CONST(1)    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 1 is generated along a line's length
#define REG_FLD_AR3D_SU_INST_P1_LINE_LENGTH(_) _(AR3D_SU,INST,P1_LINE_LENGTH,1,21,21,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P1_LINE_LENGTH(_) \
_(AR3D_SU,INST,P1_LINE_LENGTH,VARYING,0) \
_(AR3D_SU,INST,P1_LINE_LENGTH,CONST,1)
#define AR3D_SU_INST_P1_LINE_LENGTH_VARYING                     _MK_ENUM_CONST(0)    // // Interpolated between two vertices' attributes (the typical case)

#define AR3D_SU_INST_P1_LINE_LENGTH_CONST                       _MK_ENUM_CONST(1)    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 1 is generated across point
#define REG_FLD_AR3D_SU_INST_P1_POINT(_) _(AR3D_SU,INST,P1_POINT,2,23,22,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P1_POINT(_) \
_(AR3D_SU,INST,P1_POINT,DISABLE,0) \
_(AR3D_SU,INST,P1_POINT,S,1) \
_(AR3D_SU,INST,P1_POINT,T,2)
#define AR3D_SU_INST_P1_POINT_DISABLE                   _MK_ENUM_CONST(0)    // // constant (typical case for traditional points)

#define AR3D_SU_INST_P1_POINT_S                 _MK_ENUM_CONST(1)    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define AR3D_SU_INST_P1_POINT_T                 _MK_ENUM_CONST(2)    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 2 is generated across a line's width
#define REG_FLD_AR3D_SU_INST_P2_LINE_WIDTH(_) _(AR3D_SU,INST,P2_LINE_WIDTH,1,24,24,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P2_LINE_WIDTH(_) \
_(AR3D_SU,INST,P2_LINE_WIDTH,CONST,0) \
_(AR3D_SU,INST,P2_LINE_WIDTH,VARYING,1)
#define AR3D_SU_INST_P2_LINE_WIDTH_CONST                        _MK_ENUM_CONST(0)    // // constant across width (the typical case)

#define AR3D_SU_INST_P2_LINE_WIDTH_VARYING                      _MK_ENUM_CONST(1)    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 2 is generated along a line's length
#define REG_FLD_AR3D_SU_INST_P2_LINE_LENGTH(_) _(AR3D_SU,INST,P2_LINE_LENGTH,1,25,25,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P2_LINE_LENGTH(_) \
_(AR3D_SU,INST,P2_LINE_LENGTH,VARYING,0) \
_(AR3D_SU,INST,P2_LINE_LENGTH,CONST,1)
#define AR3D_SU_INST_P2_LINE_LENGTH_VARYING                     _MK_ENUM_CONST(0)    // // Interpolated between two vertices' attributes (the typical case)

#define AR3D_SU_INST_P2_LINE_LENGTH_CONST                       _MK_ENUM_CONST(1)    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 2 is generated across point
#define REG_FLD_AR3D_SU_INST_P2_POINT(_) _(AR3D_SU,INST,P2_POINT,2,27,26,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P2_POINT(_) \
_(AR3D_SU,INST,P2_POINT,DISABLE,0) \
_(AR3D_SU,INST,P2_POINT,S,1) \
_(AR3D_SU,INST,P2_POINT,T,2)
#define AR3D_SU_INST_P2_POINT_DISABLE                   _MK_ENUM_CONST(0)    // // constant (typical case for traditional points)

#define AR3D_SU_INST_P2_POINT_S                 _MK_ENUM_CONST(1)    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define AR3D_SU_INST_P2_POINT_T                 _MK_ENUM_CONST(2)    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// How attribute 3 is generated across a line's width
#define REG_FLD_AR3D_SU_INST_P3_LINE_WIDTH(_) _(AR3D_SU,INST,P3_LINE_WIDTH,1,28,28,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P3_LINE_WIDTH(_) \
_(AR3D_SU,INST,P3_LINE_WIDTH,CONST,0) \
_(AR3D_SU,INST,P3_LINE_WIDTH,VARYING,1)
#define AR3D_SU_INST_P3_LINE_WIDTH_CONST                        _MK_ENUM_CONST(0)    // // constant across width (the typical case)

#define AR3D_SU_INST_P3_LINE_WIDTH_VARYING                      _MK_ENUM_CONST(1)    // // varies from 0 .. LINE_MAX_ATTR_W


// How attribute 3 is generated along a line's length
#define REG_FLD_AR3D_SU_INST_P3_LINE_LENGTH(_) _(AR3D_SU,INST,P3_LINE_LENGTH,1,29,29,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P3_LINE_LENGTH(_) \
_(AR3D_SU,INST,P3_LINE_LENGTH,VARYING,0) \
_(AR3D_SU,INST,P3_LINE_LENGTH,CONST,1)
#define AR3D_SU_INST_P3_LINE_LENGTH_VARYING                     _MK_ENUM_CONST(0)    // // Interpolated between two vertices' attributes (the typical case)

#define AR3D_SU_INST_P3_LINE_LENGTH_CONST                       _MK_ENUM_CONST(1)    // // constant (flat shaded) based on trigger (evoking) vertex


// How attribute 3 is generated across point
#define REG_FLD_AR3D_SU_INST_P3_POINT(_) _(AR3D_SU,INST,P3_POINT,2,31,30,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P3_POINT(_) \
_(AR3D_SU,INST,P3_POINT,DISABLE,0) \
_(AR3D_SU,INST,P3_POINT,S,1) \
_(AR3D_SU,INST,P3_POINT,T,2)
#define AR3D_SU_INST_P3_POINT_DISABLE                   _MK_ENUM_CONST(0)    // // constant (typical case for traditional points)

#define AR3D_SU_INST_P3_POINT_S                 _MK_ENUM_CONST(1)    // // S-like, for point sprites: varies 0.. POINT_MAX_S left to right

#define AR3D_SU_INST_P3_POINT_T                 _MK_ENUM_CONST(2)    // // T-like, for point sprites: varies 0.. POINT_MAX_T top to bottom


// TRAM destination column, for VPE attribute column 0 ("x")
#define REG_FLD_AR3D_SU_INST_P0_TRAM_COL(_) _(AR3D_SU,INST,P0_TRAM_COL,2,1,0,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_INST_P0_TRAM_COL(_)

// TRAM column format
#define REG_FLD_AR3D_SU_INST_P0_TRAM_FMT(_) _(AR3D_SU,INST,P0_TRAM_FMT,2,3,2,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P0_TRAM_FMT(_) \
_(AR3D_SU,INST,P0_TRAM_FMT,NOP,0) \
_(AR3D_SU,INST,P0_TRAM_FMT,LP_LO,1) \
_(AR3D_SU,INST,P0_TRAM_FMT,LP_HI,2) \
_(AR3D_SU,INST,P0_TRAM_FMT,HP,3)
#define AR3D_SU_INST_P0_TRAM_FMT_NOP                    _MK_ENUM_CONST(0)    // // TRAM column is not written (VPE attr. column 0 ignored)

#define AR3D_SU_INST_P0_TRAM_FMT_LP_LO                  _MK_ENUM_CONST(1)    // // TRAM column lower half is written in low-precision

#define AR3D_SU_INST_P0_TRAM_FMT_LP_HI                  _MK_ENUM_CONST(2)    // // TRAM column upper half is written in low-precision

#define AR3D_SU_INST_P0_TRAM_FMT_HP                     _MK_ENUM_CONST(3)    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 1 ("y")
#define REG_FLD_AR3D_SU_INST_P1_TRAM_COL(_) _(AR3D_SU,INST,P1_TRAM_COL,2,5,4,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_INST_P1_TRAM_COL(_)

// TRAM column format
#define REG_FLD_AR3D_SU_INST_P1_TRAM_FMT(_) _(AR3D_SU,INST,P1_TRAM_FMT,2,7,6,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P1_TRAM_FMT(_) \
_(AR3D_SU,INST,P1_TRAM_FMT,NOP,0) \
_(AR3D_SU,INST,P1_TRAM_FMT,LP_LO,1) \
_(AR3D_SU,INST,P1_TRAM_FMT,LP_HI,2) \
_(AR3D_SU,INST,P1_TRAM_FMT,HP,3)
#define AR3D_SU_INST_P1_TRAM_FMT_NOP                    _MK_ENUM_CONST(0)    // // TRAM column is not written (VPE attr. column 0 ignored)

#define AR3D_SU_INST_P1_TRAM_FMT_LP_LO                  _MK_ENUM_CONST(1)    // // TRAM column lower half is written in low-precision

#define AR3D_SU_INST_P1_TRAM_FMT_LP_HI                  _MK_ENUM_CONST(2)    // // TRAM column upper half is written in low-precision

#define AR3D_SU_INST_P1_TRAM_FMT_HP                     _MK_ENUM_CONST(3)    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 2 ("z")
#define REG_FLD_AR3D_SU_INST_P2_TRAM_COL(_) _(AR3D_SU,INST,P2_TRAM_COL,2,9,8,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_INST_P2_TRAM_COL(_)

// TRAM column format
#define REG_FLD_AR3D_SU_INST_P2_TRAM_FMT(_) _(AR3D_SU,INST,P2_TRAM_FMT,2,11,10,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P2_TRAM_FMT(_) \
_(AR3D_SU,INST,P2_TRAM_FMT,NOP,0) \
_(AR3D_SU,INST,P2_TRAM_FMT,LP_LO,1) \
_(AR3D_SU,INST,P2_TRAM_FMT,LP_HI,2) \
_(AR3D_SU,INST,P2_TRAM_FMT,HP,3)
#define AR3D_SU_INST_P2_TRAM_FMT_NOP                    _MK_ENUM_CONST(0)    // // TRAM column is not written (VPE attr. column 0 ignored)

#define AR3D_SU_INST_P2_TRAM_FMT_LP_LO                  _MK_ENUM_CONST(1)    // // TRAM column lower half is written in low-precision

#define AR3D_SU_INST_P2_TRAM_FMT_LP_HI                  _MK_ENUM_CONST(2)    // // TRAM column upper half is written in low-precision

#define AR3D_SU_INST_P2_TRAM_FMT_HP                     _MK_ENUM_CONST(3)    // // TRAM column (both halves) is written in high-precision


// TRAM destination column, for VPE attribute column 3 ("w")
#define REG_FLD_AR3D_SU_INST_P3_TRAM_COL(_) _(AR3D_SU,INST,P3_TRAM_COL,2,13,12,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_INST_P3_TRAM_COL(_)

// TRAM column format format
#define REG_FLD_AR3D_SU_INST_P3_TRAM_FMT(_) _(AR3D_SU,INST,P3_TRAM_FMT,2,15,14,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P3_TRAM_FMT(_) \
_(AR3D_SU,INST,P3_TRAM_FMT,NOP,0) \
_(AR3D_SU,INST,P3_TRAM_FMT,LP_LO,1) \
_(AR3D_SU,INST,P3_TRAM_FMT,LP_HI,2) \
_(AR3D_SU,INST,P3_TRAM_FMT,HP,3)
#define AR3D_SU_INST_P3_TRAM_FMT_NOP                    _MK_ENUM_CONST(0)    // // TRAM column is not written (VPE attr. column 0 ignored)

#define AR3D_SU_INST_P3_TRAM_FMT_LP_LO                  _MK_ENUM_CONST(1)    // // TRAM column lower half is written in low-precision

#define AR3D_SU_INST_P3_TRAM_FMT_LP_HI                  _MK_ENUM_CONST(2)    // // TRAM column upper half is written in low-precision

#define AR3D_SU_INST_P3_TRAM_FMT_HP                     _MK_ENUM_CONST(3)    // // TRAM column (both halves) is written in high-precision


// triangle shading mode
#define REG_FLD_AR3D_SU_INST_P0_TRI_SHADE_MODE(_) _(AR3D_SU,INST,P0_TRI_SHADE_MODE,1,16,16,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P0_TRI_SHADE_MODE(_) \
_(AR3D_SU,INST,P0_TRI_SHADE_MODE,SMOOTH,0) \
_(AR3D_SU,INST,P0_TRI_SHADE_MODE,FLAT,1)
#define AR3D_SU_INST_P0_TRI_SHADE_MODE_SMOOTH                   _MK_ENUM_CONST(0)    // // attribute interpolated among the three vertices

#define AR3D_SU_INST_P0_TRI_SHADE_MODE_FLAT                     _MK_ENUM_CONST(1)    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define REG_FLD_AR3D_SU_INST_P1_TRI_SHADE_MODE(_) _(AR3D_SU,INST,P1_TRI_SHADE_MODE,1,17,17,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P1_TRI_SHADE_MODE(_) \
_(AR3D_SU,INST,P1_TRI_SHADE_MODE,SMOOTH,0) \
_(AR3D_SU,INST,P1_TRI_SHADE_MODE,FLAT,1)
#define AR3D_SU_INST_P1_TRI_SHADE_MODE_SMOOTH                   _MK_ENUM_CONST(0)    // // attribute interpolated among the three vertices

#define AR3D_SU_INST_P1_TRI_SHADE_MODE_FLAT                     _MK_ENUM_CONST(1)    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define REG_FLD_AR3D_SU_INST_P2_TRI_SHADE_MODE(_) _(AR3D_SU,INST,P2_TRI_SHADE_MODE,1,18,18,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P2_TRI_SHADE_MODE(_) \
_(AR3D_SU,INST,P2_TRI_SHADE_MODE,SMOOTH,0) \
_(AR3D_SU,INST,P2_TRI_SHADE_MODE,FLAT,1)
#define AR3D_SU_INST_P2_TRI_SHADE_MODE_SMOOTH                   _MK_ENUM_CONST(0)    // // attribute interpolated among the three vertices

#define AR3D_SU_INST_P2_TRI_SHADE_MODE_FLAT                     _MK_ENUM_CONST(1)    // // attribute is constant, from trigger (evoking) vertex.


// triangle shading mode
#define REG_FLD_AR3D_SU_INST_P3_TRI_SHADE_MODE(_) _(AR3D_SU,INST,P3_TRI_SHADE_MODE,1,19,19,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_INST_P3_TRI_SHADE_MODE(_) \
_(AR3D_SU,INST,P3_TRI_SHADE_MODE,SMOOTH,0) \
_(AR3D_SU,INST,P3_TRI_SHADE_MODE,FLAT,1)
#define AR3D_SU_INST_P3_TRI_SHADE_MODE_SMOOTH                   _MK_ENUM_CONST(0)    // // attribute interpolated among the three vertices

#define AR3D_SU_INST_P3_TRI_SHADE_MODE_FLAT                     _MK_ENUM_CONST(1)    // // attribute is constant, from trigger (evoking) vertex.


//
// NOTE: DRAW_POINT is used internally between IDX and CLIP; Software should not write this register.
//
// The load flag defines if the vertex has been loaded since the last use, or if this is a
// (cacheable) reference reuse.
//

// Register AR3D_SU_DRAW_POINT 
#define LIST_REG_FLD_AR3D_SU_DRAW_POINT(_) \
_(AR3D_SU,DRAW_POINT,V0_LOAD) \
_(AR3D_SU,DRAW_POINT,V0)
#define REG_AR3D_SU_DRAW_POINT(_) _(AR3D_SU,DRAW_POINT,0x340,0x40,1,1,0x100000f,0x0,NOARY,FLD)
#define REG_FLD_AR3D_SU_DRAW_POINT_V0_LOAD(_) _(AR3D_SU,DRAW_POINT,V0_LOAD,1,24,24,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_POINT_V0_LOAD(_)

#define REG_FLD_AR3D_SU_DRAW_POINT_V0(_) _(AR3D_SU,DRAW_POINT,V0,4,3,0,2,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_POINT_V0(_)

//
// NOTE: DRAW_LINE is used internally between IDX and CLIP; Software should not write this register.
//
// The load flag defines if the vertex has been loaded since the last use, or if this is a
// (cacheable) reference reuse.
//

// Register AR3D_SU_DRAW_LINE 
#define LIST_REG_FLD_AR3D_SU_DRAW_LINE(_) \
_(AR3D_SU,DRAW_LINE,V1_LOAD) \
_(AR3D_SU,DRAW_LINE,V0_LOAD) \
_(AR3D_SU,DRAW_LINE,V1) \
_(AR3D_SU,DRAW_LINE,V0)
#define REG_AR3D_SU_DRAW_LINE(_) _(AR3D_SU,DRAW_LINE,0x341,0x41,1,1,0x3000f0f,0x0,NOARY,FLD)
#define REG_FLD_AR3D_SU_DRAW_LINE_V1_LOAD(_) _(AR3D_SU,DRAW_LINE,V1_LOAD,1,25,25,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_LINE_V1_LOAD(_)

#define REG_FLD_AR3D_SU_DRAW_LINE_V0_LOAD(_) _(AR3D_SU,DRAW_LINE,V0_LOAD,1,24,24,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_LINE_V0_LOAD(_)

#define REG_FLD_AR3D_SU_DRAW_LINE_V1(_) _(AR3D_SU,DRAW_LINE,V1,4,11,8,2,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_LINE_V1(_)

#define REG_FLD_AR3D_SU_DRAW_LINE_V0(_) _(AR3D_SU,DRAW_LINE,V0,4,3,0,2,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_LINE_V0(_)

//
// NOTE: DRAW_TRI is used internally between IDX and CLIP; Software should not write this register.
//
// The load flag defines if the vertex has been loaded since the last use, or if this is a
// (cacheable) reference reuse.
//

// Register AR3D_SU_DRAW_TRI 
#define LIST_REG_FLD_AR3D_SU_DRAW_TRI(_) \
_(AR3D_SU,DRAW_TRI,V2_LOAD) \
_(AR3D_SU,DRAW_TRI,V1_LOAD) \
_(AR3D_SU,DRAW_TRI,V0_LOAD) \
_(AR3D_SU,DRAW_TRI,V2) \
_(AR3D_SU,DRAW_TRI,V1) \
_(AR3D_SU,DRAW_TRI,V0)
#define REG_AR3D_SU_DRAW_TRI(_) _(AR3D_SU,DRAW_TRI,0x342,0x42,1,1,0x70f0f0f,0x0,NOARY,FLD)
#define REG_FLD_AR3D_SU_DRAW_TRI_V2_LOAD(_) _(AR3D_SU,DRAW_TRI,V2_LOAD,1,26,26,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_TRI_V2_LOAD(_)

#define REG_FLD_AR3D_SU_DRAW_TRI_V1_LOAD(_) _(AR3D_SU,DRAW_TRI,V1_LOAD,1,25,25,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_TRI_V1_LOAD(_)

#define REG_FLD_AR3D_SU_DRAW_TRI_V0_LOAD(_) _(AR3D_SU,DRAW_TRI,V0_LOAD,1,24,24,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_TRI_V0_LOAD(_)

#define REG_FLD_AR3D_SU_DRAW_TRI_V2(_) _(AR3D_SU,DRAW_TRI,V2,4,19,16,2,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_TRI_V2(_)

#define REG_FLD_AR3D_SU_DRAW_TRI_V1(_) _(AR3D_SU,DRAW_TRI,V1,4,11,8,2,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_TRI_V1(_)

#define REG_FLD_AR3D_SU_DRAW_TRI_V0(_) _(AR3D_SU,DRAW_TRI,V0,4,3,0,2,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_DRAW_TRI_V0(_)

//
// PARAM Register:
// FIRST_INST: first setup instruction to execute
// LAST_INST: last setup instruction to execute (must be >= FIRST_INST, count does NOT wrap around!)
//   This implies that 0 instructions are not supported.  If 0 are desired, program one instruction that
//   reads from arbitrary obuf row and does 4 NOPs.
// FRONT_FACE: which triangle direction is considered front, for downstream (two-sided stencil two-sided lighting, ...). This has no effect on culling.
// CULL: culling control
// SUBPIX_XOFF: subpix adjustment for X. 
// SUBPIX_YOFF: subpix adjustment for Y.
//
// SUBPIX_XOFF and YOFF are added after viewport transform, and hence are screen-space.  
// The format is 2's complement S1.4, meaning bits 0..3 are fraction, bit 4 is integer, and bit 5 is sign bit.  The 6 bits [5:0] have weights
// of -2^1, 2^0, 2^-1, 2^-2, 2^-3, 2^-4 respectively.  The range is therefore [-2, 1.9375].  Common encoded values include:
// 0: 0x0
// -0.5: 0x38
// -1.0: 0x30
// 0.5: 0x08
// 1.0: 0x10
//

// Register AR3D_SU_PARAM 
#define LIST_REG_FLD_AR3D_SU_PARAM(_) \
_(AR3D_SU,PARAM,FIRST_INST) \
_(AR3D_SU,PARAM,LAST_INST) \
_(AR3D_SU,PARAM,FRONT_FACE) \
_(AR3D_SU,PARAM,CULL) \
_(AR3D_SU,PARAM,SUBPIX_XOFF) \
_(AR3D_SU,PARAM,SUBPIX_YOFF) \
_(AR3D_SU,PARAM,TRANSPOSE_XY) \
_(AR3D_SU,PARAM,CLIP_ENABLE)
#define REG_AR3D_SU_PARAM(_) _(AR3D_SU,PARAM,0x343,0x43,1,1,0xffff83ff,0x80000000,NOARY,FLD)
// first setup instruction to execute
#define REG_FLD_AR3D_SU_PARAM_FIRST_INST(_) _(AR3D_SU,PARAM,FIRST_INST,5,4,0,3,0x1f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_PARAM_FIRST_INST(_)

// last setup instruction to execute (count does NOT wrap around!)
#define REG_FLD_AR3D_SU_PARAM_LAST_INST(_) _(AR3D_SU,PARAM,LAST_INST,5,9,5,3,0x1f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_PARAM_LAST_INST(_)

// which triangle direction is considered FRONT facing (vs. BACK facing).  Does not affect culling.
#define REG_FLD_AR3D_SU_PARAM_FRONT_FACE(_) _(AR3D_SU,PARAM,FRONT_FACE,1,15,15,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_PARAM_FRONT_FACE(_) \
_(AR3D_SU,PARAM,FRONT_FACE,POS,0) \
_(AR3D_SU,PARAM,FRONT_FACE,NEG,1)
#define AR3D_SU_PARAM_FRONT_FACE_POS                    _MK_ENUM_CONST(0)    // // positive-area triangles are FRONT facing

#define AR3D_SU_PARAM_FRONT_FACE_NEG                    _MK_ENUM_CONST(1)    // // negative-area triangles are FRONT facing


// culling control for triangles.  Has no affect on lines or points.
#define REG_FLD_AR3D_SU_PARAM_CULL(_) _(AR3D_SU,PARAM,CULL,2,17,16,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_PARAM_CULL(_) \
_(AR3D_SU,PARAM,CULL,NONE,0) \
_(AR3D_SU,PARAM,CULL,POS,1) \
_(AR3D_SU,PARAM,CULL,NEG,2) \
_(AR3D_SU,PARAM,CULL,BOTH,3)
#define AR3D_SU_PARAM_CULL_NONE                 _MK_ENUM_CONST(0)    // // culling disabled, draw all triangles

#define AR3D_SU_PARAM_CULL_POS                  _MK_ENUM_CONST(1)    // // cull positive area triangles

#define AR3D_SU_PARAM_CULL_NEG                  _MK_ENUM_CONST(2)    // // cull negative area triangles

#define AR3D_SU_PARAM_CULL_BOTH                 _MK_ENUM_CONST(3)    // // cull all triangles


// subpixel adjustment S1.4 (Typically, D3D = 0x00 (0), OGL = 0x38 (-0.5))
#define REG_FLD_AR3D_SU_PARAM_SUBPIX_XOFF(_) _(AR3D_SU,PARAM,SUBPIX_XOFF,6,23,18,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_PARAM_SUBPIX_XOFF(_)

// subpixel adjustment S1.4 (Typically, D3D = 0x00 (0), OGL = 0x38 (-0.5))
#define REG_FLD_AR3D_SU_PARAM_SUBPIX_YOFF(_) _(AR3D_SU,PARAM,SUBPIX_YOFF,6,29,24,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_PARAM_SUBPIX_YOFF(_)

// swaps X and Y coordinates, generating a rotated mirror image.  P1 for mg20.
#define REG_FLD_AR3D_SU_PARAM_TRANSPOSE_XY(_) _(AR3D_SU,PARAM,TRANSPOSE_XY,1,30,30,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_PARAM_TRANSPOSE_XY(_) \
_(AR3D_SU,PARAM,TRANSPOSE_XY,DISABLE,0) \
_(AR3D_SU,PARAM,TRANSPOSE_XY,ENABLE,1)
#define AR3D_SU_PARAM_TRANSPOSE_XY_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_SU_PARAM_TRANSPOSE_XY_ENABLE                       _MK_ENUM_CONST(1)

// frustum clip enable control.
#define REG_FLD_AR3D_SU_PARAM_CLIP_ENABLE(_) _(AR3D_SU,PARAM,CLIP_ENABLE,1,31,31,3,0x1,0x1,ENABLE,ENM)
#define LIST_REG_ENM_AR3D_SU_PARAM_CLIP_ENABLE(_) \
_(AR3D_SU,PARAM,CLIP_ENABLE,DISABLE,0) \
_(AR3D_SU,PARAM,CLIP_ENABLE,ENABLE,1)
#define AR3D_SU_PARAM_CLIP_ENABLE_DISABLE                       _MK_ENUM_CONST(0)    // // Frustum clipping not performaed - all primitives are accepted. Software must ensure vertices are within device coordinate range.  Viewport transform, user clipping (if enabled) and area cull is still performed.

#define AR3D_SU_PARAM_CLIP_ENABLE_ENABLE                        _MK_ENUM_CONST(1)    // // Frustum clipping is performed as usual


//
// ZBIAS: device-coordinate value added to iterated Z. Each 16 units or fewer (depending on Z surface format) of bias
// guarentees 1 LSB of Z offset, with no z-fighting assuming identical triangulation
// (see ZFACTOR for the other half of the PolygonOffset implementation).
//
// NOTE: software is responsible for disabling this and ZFACTOR for points and lines;
// hardware does not disable it automatically.
//
// The encoding of this register is signed fixed-point integer with 1 sign bit, 1 integer bit, and 20 fraction bits. The range is
// [-2, 2).  Bits 21..0 have weight -2^1, 2^0, 2^-1, ... 2^-20 respectively.
// To convert an IEEE floating point value to this format, do something like:
//   int int_val = (int)lrintf(fp_bias * (float)(1<<20));    // convert to int with 20-bit "fraction"
//   zbias.val = min((2 << 20) - 1, max(-2 << 20, int_val)) & 0x3fffff;    // clamp to [-2, 2), and mask to 22 bits.
//
// Note that the range of Z within the chip is [-4, 4) but pixels with Z outside that range are either 
// clamped to [0, 1), or killed, before being written to Z buffer. 
// The purpose of the wider [-4, 4) range is to permit guardband frustum clipping at near and far planes.
// 

// Register AR3D_SU_ZBIAS 
#define LIST_REG_FLD_AR3D_SU_ZBIAS(_) \
_(AR3D_SU,ZBIAS,VAL)
#define REG_AR3D_SU_ZBIAS(_) _(AR3D_SU,ZBIAS,0x344,0x44,1,1,0x3fffff,0x0,NOARY,FLD)
// S1.20 device-coordinate value
#define REG_FLD_AR3D_SU_ZBIAS_VAL(_) _(AR3D_SU,ZBIAS,VAL,22,21,0,3,0x3fffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_ZBIAS_VAL(_)

//
// ZFACTOR is the 32-bit IEEE FP PolygonOffset z-slope factor.
// Each N will result in a z-bias of N LSB's of the iterated Z
// for each unit of max(|dz/dx|,|dz/dy|) worth of z-slope.
// (see ZBIAS for the other half of the PolygonOffset implementation).
// Note that up to 16 iterated Z units may be required to change Z surface by one unit, since Z surfaces have as few as 16 bits, 
// whereas itereated Z is 20 bits of precision.
//
// NOTE: software is responsible for disabling this and ZBIAS for points and lines;
// hardware does not disable it automatically.
//

// Register AR3D_SU_ZFACTOR 
#define LIST_REG_FLD_AR3D_SU_ZFACTOR(_) \
_(AR3D_SU,ZFACTOR,VAL)
#define REG_AR3D_SU_ZFACTOR(_) _(AR3D_SU,ZFACTOR,0x345,0x45,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE float value
#define REG_FLD_AR3D_SU_ZFACTOR_VAL(_) _(AR3D_SU,ZFACTOR,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_ZFACTOR_VAL(_)

//
// POINT_PARAM controls various aspects of DRAW_POINT operation
//
// When POINT_SIZE_MODE is FIXED, point size comes from the POINT_WIDTH_2 register.
//      Calling that 'pw2', the four corners of generated point are computed as
//               (X0, Y0) = (X - pw2, Y - pw2)
//               (X1, Y1) = (X + pw2, Y + pw2)
//               (X2, Y2) = (X - pw2, Y + pw2)
//               (X3, Y3) = (X + pw2, Y - pw2)
//
// When POINT_SIZE_MODE is PSIZE, point size comes from a component of attribute at obuf[VTX_OFFS].ATTR_COMP.
//      Calling that 'a.x', the four corners of generated point are computed as
//               (X0, Y0) = (X - a.x, Y - a.x)
//               (X1, Y1) = (X + a.x, Y + a.x)
//               (X2, Y2) = (X - a.x, Y + a.x)
//               (X3, Y3) = (X + a.x, Y - a.x)
//
// When POINT_SIZE_MODE is SHEAR, point sizes comes from attribute obuf[VTX_OFFS].
//      Calling that attribute 'a', the four corners of generated point are computed as
//               (X0, Y0) = (X - a.x - a.z, Y - a.y - a.w)
//               (X1, Y1) = (X + a.x + a.z, Y + a.y + a.w)
//               (X2, Y2) = (X - a.x + a.z, Y - a.y + a.w)
//               (X3, Y3) = (X + a.x - a.z, Y + a.y - a.w)
//

// Register AR3D_SU_POINT_PARAM 
#define LIST_REG_FLD_AR3D_SU_POINT_PARAM(_) \
_(AR3D_SU,POINT_PARAM,VTX_OFFS) \
_(AR3D_SU,POINT_PARAM,ATTR_COMP) \
_(AR3D_SU,POINT_PARAM,POINT_SIZE_MODE) \
_(AR3D_SU,POINT_PARAM,CLIP_MODE)
#define REG_AR3D_SU_POINT_PARAM(_) _(AR3D_SU,POINT_PARAM,0x346,0x46,1,1,0x1f0f,0x0,NOARY,FLD)
// offset of attribute in obuf for size and/or 
#define REG_FLD_AR3D_SU_POINT_PARAM_VTX_OFFS(_) _(AR3D_SU,POINT_PARAM,VTX_OFFS,4,3,0,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_POINT_PARAM_VTX_OFFS(_)

// which component of obuf attribute (for PSIZE)
#define REG_FLD_AR3D_SU_POINT_PARAM_ATTR_COMP(_) _(AR3D_SU,POINT_PARAM,ATTR_COMP,2,9,8,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_POINT_PARAM_ATTR_COMP(_) \
_(AR3D_SU,POINT_PARAM,ATTR_COMP,X,0) \
_(AR3D_SU,POINT_PARAM,ATTR_COMP,Y,1) \
_(AR3D_SU,POINT_PARAM,ATTR_COMP,Z,2) \
_(AR3D_SU,POINT_PARAM,ATTR_COMP,W,3)
#define AR3D_SU_POINT_PARAM_ATTR_COMP_X                 _MK_ENUM_CONST(0)
#define AR3D_SU_POINT_PARAM_ATTR_COMP_Y                 _MK_ENUM_CONST(1)
#define AR3D_SU_POINT_PARAM_ATTR_COMP_Z                 _MK_ENUM_CONST(2)
#define AR3D_SU_POINT_PARAM_ATTR_COMP_W                 _MK_ENUM_CONST(3)

// control over whether and how the VTX_OFFS vectors are used in point generation
#define REG_FLD_AR3D_SU_POINT_PARAM_POINT_SIZE_MODE(_) _(AR3D_SU,POINT_PARAM,POINT_SIZE_MODE,2,11,10,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_POINT_PARAM_POINT_SIZE_MODE(_) \
_(AR3D_SU,POINT_PARAM,POINT_SIZE_MODE,FIXED,0) \
_(AR3D_SU,POINT_PARAM,POINT_SIZE_MODE,PSIZE,1) \
_(AR3D_SU,POINT_PARAM,POINT_SIZE_MODE,SHEAR,2)
#define AR3D_SU_POINT_PARAM_POINT_SIZE_MODE_FIXED                       _MK_ENUM_CONST(0)
#define AR3D_SU_POINT_PARAM_POINT_SIZE_MODE_PSIZE                       _MK_ENUM_CONST(1)
#define AR3D_SU_POINT_PARAM_POINT_SIZE_MODE_SHEAR                       _MK_ENUM_CONST(2)

// clip points/pointsprites to inner (screen) vs. outer (guardband) frustum.
// In either case, the center of point(sprite) is used.
#define REG_FLD_AR3D_SU_POINT_PARAM_CLIP_MODE(_) _(AR3D_SU,POINT_PARAM,CLIP_MODE,1,12,12,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_POINT_PARAM_CLIP_MODE(_) \
_(AR3D_SU,POINT_PARAM,CLIP_MODE,SCREEN,0) \
_(AR3D_SU,POINT_PARAM,CLIP_MODE,GUARDBAND,1)
#define AR3D_SU_POINT_PARAM_CLIP_MODE_SCREEN                    _MK_ENUM_CONST(0)    // // clip to screen edge; wide points may pop in or out.

#define AR3D_SU_POINT_PARAM_CLIP_MODE_GUARDBAND                 _MK_ENUM_CONST(1)    // // clip to guardband; the guardband_w/_h registers must be inset enough to accomodate
// points' expansion by point_size.


//
// POINT_WIDTH_2 is a 32-bit IEEE FP value representing 1/2 the point width.
// For mg20, the requirement is to support up to glPointSize() of up to 256, and up to 2048x2048 surface size.
// SW should insure that points and lines do not expand beyond 128 pixels past the 2048 boundary.
//

// Register AR3D_SU_POINT_WIDTH_2 
#define LIST_REG_FLD_AR3D_SU_POINT_WIDTH_2(_) \
_(AR3D_SU,POINT_WIDTH_2,VAL)
#define REG_AR3D_SU_POINT_WIDTH_2(_) _(AR3D_SU,POINT_WIDTH_2,0x347,0x47,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE float value
#define REG_FLD_AR3D_SU_POINT_WIDTH_2_VAL(_) _(AR3D_SU,POINT_WIDTH_2,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_POINT_WIDTH_2_VAL(_)

//
// When Px_POINT is S, this value is used for the maximum S value (typically should be 1.0)
//

// Register AR3D_SU_POINT_MAX_S 
#define LIST_REG_FLD_AR3D_SU_POINT_MAX_S(_) \
_(AR3D_SU,POINT_MAX_S,VAL)
#define REG_AR3D_SU_POINT_MAX_S(_) _(AR3D_SU,POINT_MAX_S,0x348,0x48,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE float value
#define REG_FLD_AR3D_SU_POINT_MAX_S_VAL(_) _(AR3D_SU,POINT_MAX_S,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_POINT_MAX_S_VAL(_)

//
// When Px_POINT is T, this value is used for the maximum T value (typically should be 1.0)
//

// Register AR3D_SU_POINT_MAX_T 
#define LIST_REG_FLD_AR3D_SU_POINT_MAX_T(_) \
_(AR3D_SU,POINT_MAX_T,VAL)
#define REG_AR3D_SU_POINT_MAX_T(_) _(AR3D_SU,POINT_MAX_T,0x349,0x49,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE float value
#define REG_FLD_AR3D_SU_POINT_MAX_T_VAL(_) _(AR3D_SU,POINT_MAX_T,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_POINT_MAX_T_VAL(_)

//
// When Px_POINT is S, this value is used for the minimum S value (typically should be 0.0)
//

// Register AR3D_SU_POINT_MIN_S 
#define LIST_REG_FLD_AR3D_SU_POINT_MIN_S(_) \
_(AR3D_SU,POINT_MIN_S,VAL)
#define REG_AR3D_SU_POINT_MIN_S(_) _(AR3D_SU,POINT_MIN_S,0x34a,0x4a,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE float value
#define REG_FLD_AR3D_SU_POINT_MIN_S_VAL(_) _(AR3D_SU,POINT_MIN_S,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_POINT_MIN_S_VAL(_)

//
// When Px_POINT is T, this value is used for the minimum T value (typically should be 0.0)
//

// Register AR3D_SU_POINT_MIN_T 
#define LIST_REG_FLD_AR3D_SU_POINT_MIN_T(_) \
_(AR3D_SU,POINT_MIN_T,VAL)
#define REG_AR3D_SU_POINT_MIN_T(_) _(AR3D_SU,POINT_MIN_T,0x34b,0x4b,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE float value
#define REG_FLD_AR3D_SU_POINT_MIN_T_VAL(_) _(AR3D_SU,POINT_MIN_T,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_POINT_MIN_T_VAL(_)

//
// LINE_PARAM controls various aspects of DRAW_LINE operation.
//
// SQUARE-cut lines tend to be slower to draw than FRENCH-cut lines.
// CLIP_MODE of SCREEN may result in more clipping and thus slower performance.
//

// Register AR3D_SU_LINE_PARAM 
#define LIST_REG_FLD_AR3D_SU_LINE_PARAM(_) \
_(AR3D_SU,LINE_PARAM,CUT) \
_(AR3D_SU,LINE_PARAM,CLIP_MODE)
#define REG_AR3D_SU_LINE_PARAM(_) _(AR3D_SU,LINE_PARAM,0x34c,0x4c,1,1,0x3,0x0,NOARY,FLD)
// style of line end-caps to draw
#define REG_FLD_AR3D_SU_LINE_PARAM_CUT(_) _(AR3D_SU,LINE_PARAM,CUT,1,0,0,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_LINE_PARAM_CUT(_) \
_(AR3D_SU,LINE_PARAM,CUT,FRENCH,0) \
_(AR3D_SU,LINE_PARAM,CUT,SQUARE,1)
#define AR3D_SU_LINE_PARAM_CUT_FRENCH                   _MK_ENUM_CONST(0)    // // line ends are parallel to either X or Y axis

#define AR3D_SU_LINE_PARAM_CUT_SQUARE                   _MK_ENUM_CONST(1)    // // line ends are perpendicular to line


// clip lines to inner (screen) vs. outer (guardband) frustum.  
// in either case, the center of line is used.
#define REG_FLD_AR3D_SU_LINE_PARAM_CLIP_MODE(_) _(AR3D_SU,LINE_PARAM,CLIP_MODE,1,1,1,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_LINE_PARAM_CLIP_MODE(_) \
_(AR3D_SU,LINE_PARAM,CLIP_MODE,SCREEN,0) \
_(AR3D_SU,LINE_PARAM,CLIP_MODE,GUARDBAND,1)
#define AR3D_SU_LINE_PARAM_CLIP_MODE_SCREEN                     _MK_ENUM_CONST(0)    // // clipped to screen edge, so that ends may be visible.  

#define AR3D_SU_LINE_PARAM_CLIP_MODE_GUARDBAND                  _MK_ENUM_CONST(1)    // // if GUARDBAND selected, the guardband_w/_h registers must be inset enough to accomodate
// lines' expandion by line_width_2.


//
// LINE_WIDTH_2 is a 32-bit IEEE FP value representing 1/2 the line width
//

// Register AR3D_SU_LINE_WIDTH_2 
#define LIST_REG_FLD_AR3D_SU_LINE_WIDTH_2(_) \
_(AR3D_SU,LINE_WIDTH_2,VAL)
#define REG_AR3D_SU_LINE_WIDTH_2(_) _(AR3D_SU,LINE_WIDTH_2,0x34d,0x4d,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision float value
#define REG_FLD_AR3D_SU_LINE_WIDTH_2_VAL(_) _(AR3D_SU,LINE_WIDTH_2,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_LINE_WIDTH_2_VAL(_)

//
// LINE_MAX_ATTR_W controls the maximum autogenerated attribute value across line width
// (when INST.Px_LINE_WIDTH is VARYING)
//

// Register AR3D_SU_LINE_MAX_ATTR_W 
#define LIST_REG_FLD_AR3D_SU_LINE_MAX_ATTR_W(_) \
_(AR3D_SU,LINE_MAX_ATTR_W,VAL)
#define REG_AR3D_SU_LINE_MAX_ATTR_W(_) _(AR3D_SU,LINE_MAX_ATTR_W,0x34e,0x4e,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision float value
#define REG_FLD_AR3D_SU_LINE_MAX_ATTR_W_VAL(_) _(AR3D_SU,LINE_MAX_ATTR_W,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_LINE_MAX_ATTR_W_VAL(_)

//
// LINE_MIN_ATTR_W controls the minimum autogenerated attribute value across line width
// (when INST.Px_LINE_WIDTH is VARYING).
//

// Register AR3D_SU_LINE_MIN_ATTR_W 
#define LIST_REG_FLD_AR3D_SU_LINE_MIN_ATTR_W(_) \
_(AR3D_SU,LINE_MIN_ATTR_W,VAL)
#define REG_AR3D_SU_LINE_MIN_ATTR_W(_) _(AR3D_SU,LINE_MIN_ATTR_W,0x34f,0x4f,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision float value
#define REG_FLD_AR3D_SU_LINE_MIN_ATTR_W_VAL(_) _(AR3D_SU,LINE_MIN_ATTR_W,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_LINE_MIN_ATTR_W_VAL(_)

// maxiumum drawable dimension
#define AR3D_SETUP_VTX_XY_WIDTH 12
//
// Scissor max and min in X, in whole pixels.    
// These values are unsigned.  The min value is inclusive whereas the max
// value is exclusive.  A scissor rectangle of width 240, at 0, would be 
// encoded as MIN=0, MAX=240. Note that if MIN==MAX, the scissor width is 0. 
//

// Register AR3D_SU_SCISSOR_X 
#define LIST_REG_FLD_AR3D_SU_SCISSOR_X(_) \
_(AR3D_SU,SCISSOR_X,MAX) \
_(AR3D_SU,SCISSOR_X,MIN)
#define REG_AR3D_SU_SCISSOR_X(_) _(AR3D_SU,SCISSOR_X,0x350,0x50,1,1,0xfff1fff,0x0,NOARY,FLD)
// unsigned maximum X value (exclusive)
#define REG_FLD_AR3D_SU_SCISSOR_X_MAX(_) _(AR3D_SU,SCISSOR_X,MAX,13,12,0,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_SCISSOR_X_MAX(_)

// unsigned minimum Y value (inclusive)
#define REG_FLD_AR3D_SU_SCISSOR_X_MIN(_) _(AR3D_SU,SCISSOR_X,MIN,12,27,16,3,0xfff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_SCISSOR_X_MIN(_)

//
// Scissor max and min in Y, in whole pixels 
// NOTE: Y is measured from the top of the frame buffer (i.e., lower
// address of surface).  This is the opposite of the glScissor() point of
// reference, which is the lower left corner.  These values are unsigned.
// The min value is inclusive whereas the max value is exclusive. A scissor 
// rectangle of height 320, at 0, would be encoded as MIN=0, MAX=320.  Note 
// that if MIN==MAX, the scissor height is 0.
//

// Register AR3D_SU_SCISSOR_Y 
#define LIST_REG_FLD_AR3D_SU_SCISSOR_Y(_) \
_(AR3D_SU,SCISSOR_Y,MAX) \
_(AR3D_SU,SCISSOR_Y,MIN)
#define REG_AR3D_SU_SCISSOR_Y(_) _(AR3D_SU,SCISSOR_Y,0x351,0x51,1,1,0xfff1fff,0x0,NOARY,FLD)
// unsigned maximum Y value (exclusive)
#define REG_FLD_AR3D_SU_SCISSOR_Y_MAX(_) _(AR3D_SU,SCISSOR_Y,MAX,13,12,0,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_SCISSOR_Y_MAX(_)

// unsigned minimum Y value (inclusive)
#define REG_FLD_AR3D_SU_SCISSOR_Y_MIN(_) _(AR3D_SU,SCISSOR_Y,MIN,12,27,16,3,0xfff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_SCISSOR_Y_MIN(_)

//
// Viewport/depth-range registers for XYZWHD (32-bit IEEE floats)
//
// NOTE:
//
// The X and Y viewport transforms should map [-1, 1] to [viewport_min, viewport_size+viewport_min).  For example,
// a 240x320 viewport should map X from [-1,1] to [0,240) and Y from [-1,1] to [0,320).
// The X/Y/W/H values must be scaled by NV_GR3D_SNAP_ONE since the output of the viewport
// transformation is assumed to be at subpixel resolution by the hardware.  I.e., the X and Y 
// viewport transforms should yield X in range [0 .. WIDTH*NV_GR3D_SNAP_ONE) (for viewable area - not including guardband)
// and Y in range [0 .. HEIGHT*WIDTH*NV_GR3D_SNAP_ONE].
//
// VIEWPORT_Y gives offset in lines from top (lowest address) of frame buffer; this is different than OpenGL.
//
// The Z viewport transform should map [-1, 1] to [0, 1).  If Z guardband is enabled, the output range can be as large
// as [-4, 4), depending on GUARDBAND_D register.  The output of viewport transform (z * VIEWPORT_D + VIEWPORT_Z) is converteed
// in hardware to a fixed-point integer value with 1 sign bit, 2 integer bits, and 20 fractional bits.  The range is [-4, 4).
// Pixels with Z outside of [0,1) are clamped to [0,1) or killed. 
// An example setting is:
//      view_d = (z_far - z_near) / 2.0 
//      view_z = view_d + z_near
//      z_scale = (float)((1 << 20) - 1) / (float)(1 << 20); // map 1 to 1-epsilon
//      VIEWPORT_D = view_d * z_scale
//      VIEWPORT_Z = view_z * z_scale
//

// Register AR3D_SU_VIEWPORT_X // horizontal viewport offset (must be scaled by NV_GR3D_SNAP_ONE)
#define LIST_REG_FLD_AR3D_SU_VIEWPORT_X(_) \
_(AR3D_SU,VIEWPORT_X,VAL)
#define REG_AR3D_SU_VIEWPORT_X(_) _(AR3D_SU,VIEWPORT_X,0x352,0x52,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision floating point
#define REG_FLD_AR3D_SU_VIEWPORT_X_VAL(_) _(AR3D_SU,VIEWPORT_X,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_VIEWPORT_X_VAL(_)


// Register AR3D_SU_VIEWPORT_Y // vertical viewport offset (must be scaled by NV_GR3D_SNAP_ONE)
#define LIST_REG_FLD_AR3D_SU_VIEWPORT_Y(_) \
_(AR3D_SU,VIEWPORT_Y,VAL)
#define REG_AR3D_SU_VIEWPORT_Y(_) _(AR3D_SU,VIEWPORT_Y,0x353,0x53,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision floating point
#define REG_FLD_AR3D_SU_VIEWPORT_Y_VAL(_) _(AR3D_SU,VIEWPORT_Y,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_VIEWPORT_Y_VAL(_)


// Register AR3D_SU_VIEWPORT_Z // depth viewport offset
#define LIST_REG_FLD_AR3D_SU_VIEWPORT_Z(_) \
_(AR3D_SU,VIEWPORT_Z,VAL)
#define REG_AR3D_SU_VIEWPORT_Z(_) _(AR3D_SU,VIEWPORT_Z,0x354,0x54,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision floating point
#define REG_FLD_AR3D_SU_VIEWPORT_Z_VAL(_) _(AR3D_SU,VIEWPORT_Z,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_VIEWPORT_Z_VAL(_)


// Register AR3D_SU_VIEWPORT_W // horizontal viewport scale factor (must be scaled by NV_GR3D_SNAP_ONE)
#define LIST_REG_FLD_AR3D_SU_VIEWPORT_W(_) \
_(AR3D_SU,VIEWPORT_W,VAL)
#define REG_AR3D_SU_VIEWPORT_W(_) _(AR3D_SU,VIEWPORT_W,0x355,0x55,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision floating point
#define REG_FLD_AR3D_SU_VIEWPORT_W_VAL(_) _(AR3D_SU,VIEWPORT_W,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_VIEWPORT_W_VAL(_)


// Register AR3D_SU_VIEWPORT_H // vertical viewport scale factor (must be scaled by NV_GR3D_SNAP_ONE)
#define LIST_REG_FLD_AR3D_SU_VIEWPORT_H(_) \
_(AR3D_SU,VIEWPORT_H,VAL)
#define REG_AR3D_SU_VIEWPORT_H(_) _(AR3D_SU,VIEWPORT_H,0x356,0x56,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision floating point
#define REG_FLD_AR3D_SU_VIEWPORT_H_VAL(_) _(AR3D_SU,VIEWPORT_H,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_VIEWPORT_H_VAL(_)


// Register AR3D_SU_VIEWPORT_D // depth viewport scale factor
#define LIST_REG_FLD_AR3D_SU_VIEWPORT_D(_) \
_(AR3D_SU,VIEWPORT_D,VAL)
#define REG_AR3D_SU_VIEWPORT_D(_) _(AR3D_SU,VIEWPORT_D,0x357,0x57,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision floating point
#define REG_FLD_AR3D_SU_VIEWPORT_D_VAL(_) _(AR3D_SU,VIEWPORT_D,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_VIEWPORT_D_VAL(_)

//
// guardband width/height/depth clipcode generation registers (32-bit IEEE floats)
//
// 1.0 == no guardband, > 1.0 results in a guardband that's
// that much bigger than the extent of the device coordinates
// post-viewport, i.e. if you're rendering to 320 wide viewport and hardware handles
// coordinates up to NV_GR3D_XRES, you may compute:
//
//  GUARDBAND_W = NV_GR3D_XRES / (320/2)
//
// But since the viewport is not centered in the guardband frustum, a tighter
// value is given by:
//
//  GUARDBAND_W = (NV_GR3D_XRES - 320/2) / (320/2)
//
// Further, to permit wide points and lines to clip offscreen (rather than pop in/out at screen edge), guardband should be adjusted 
// outword a bit.  The hardware provides adequate headroom for this:
//
//  GUARDBAND_W = MAX(NV_GR3D_XRES + NV_GR3D_MAX_POINT_LINE_SIZE/2 - 320/2, NV_GR3D_XRES + NV_GR3D_MAX_POINT_LINE_SIZE/2) / (320/2)
//
// These equations assume that viewport performs the operation:
//    Xd = 320/2 * Xc + 320/2
// where Xd is device X coordinate, and Xc is clip space coordinate.
//
// The above discussion applies to GUARDBAND_W and GUARDBAND_Y.  For Z guardband:
//
//    GUARDBAND_Z = (pow(2.0, (float)NV_GR3D_Z_INT_BITS) - .5) / .5 - pow(2.0, -(float)NV_GR3D_XRES_LOG2)
//
// inner clipcodes are generated by comparing post-transform
// x,y,z to -/+ the transformed w, while the outer clipcodes
// compare against -/+ GUARDBAND_<DIMENSION> * w. Hardware will
// trivial-reject things completely outside the inner -/+w
// rectangle, and trivial accept things completely inside the
// outer -/+GUARDBAND_<DIMENSION>*w rectangle. Complex clipping cases
// are be handled entirely in hardware.  In cases where the vertex
// coordinates are very far apart (> 8,000 screen diameters), the
// intercepts may start losing precision due to the fact that all
// clipping is done in single precision float arithmetic.  Clipping
// cases where the vertices have W's of opposite sign may produce
// non-obvious results.
//

// Register AR3D_SU_GUARDBAND_W // width (x) guardband factor 
#define LIST_REG_FLD_AR3D_SU_GUARDBAND_W(_) \
_(AR3D_SU,GUARDBAND_W,VAL)
#define REG_AR3D_SU_GUARDBAND_W(_) _(AR3D_SU,GUARDBAND_W,0x358,0x58,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision floating point
#define REG_FLD_AR3D_SU_GUARDBAND_W_VAL(_) _(AR3D_SU,GUARDBAND_W,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_GUARDBAND_W_VAL(_)


// Register AR3D_SU_GUARDBAND_H // height (Y) guardband factor
#define LIST_REG_FLD_AR3D_SU_GUARDBAND_H(_) \
_(AR3D_SU,GUARDBAND_H,VAL)
#define REG_AR3D_SU_GUARDBAND_H(_) _(AR3D_SU,GUARDBAND_H,0x359,0x59,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision floating point
#define REG_FLD_AR3D_SU_GUARDBAND_H_VAL(_) _(AR3D_SU,GUARDBAND_H,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_GUARDBAND_H_VAL(_)


// Register AR3D_SU_GUARDBAND_D // depth (Z) guardband factor
#define LIST_REG_FLD_AR3D_SU_GUARDBAND_D(_) \
_(AR3D_SU,GUARDBAND_D,VAL)
#define REG_AR3D_SU_GUARDBAND_D(_) _(AR3D_SU,GUARDBAND_D,0x35a,0x5a,1,1,0xffffffff,0x0,NOARY,FLD)
// IEEE single-precision floating point
#define REG_FLD_AR3D_SU_GUARDBAND_D_VAL(_) _(AR3D_SU,GUARDBAND_D,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_GUARDBAND_D_VAL(_)

//
// User Clip Plane
//
// This register controls the user clip plane.  When enabled,
// clip will fetch a scalar value from the OBUF based on the
// VTX_OFFS and ATTR_COMP parameters.  This value should be
// a plane distance computed by the VPE via a DP4 of the
// homogenous position and a plane equation, which is typically
// computed as ( Nx, Ny, Nz, - P dot N ) for a plane with unit
// normal N and a point on the plane P.  The plane defines a half-
// space where values of the plane distance < 0.0 are clipped.
//
// Note that user clip enable is independent of frustum clip enable.
//

// Register AR3D_SU_UCPLANE 
#define LIST_REG_FLD_AR3D_SU_UCPLANE(_) \
_(AR3D_SU,UCPLANE,VTX_OFFS) \
_(AR3D_SU,UCPLANE,ATTR_COMP) \
_(AR3D_SU,UCPLANE,ENABLE)
#define REG_AR3D_SU_UCPLANE(_) _(AR3D_SU,UCPLANE,0x35b,0x5b,1,1,0x70f,0x0,ARY,FLD)
// OBUF slot for user plane 0 distance
#define REG_FLD_AR3D_SU_UCPLANE_VTX_OFFS(_) _(AR3D_SU,UCPLANE,VTX_OFFS,4,3,0,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_SU_UCPLANE_VTX_OFFS(_)

// component for user plane 0 distance
#define REG_FLD_AR3D_SU_UCPLANE_ATTR_COMP(_) _(AR3D_SU,UCPLANE,ATTR_COMP,2,9,8,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_SU_UCPLANE_ATTR_COMP(_) \
_(AR3D_SU,UCPLANE,ATTR_COMP,X,0) \
_(AR3D_SU,UCPLANE,ATTR_COMP,Y,1) \
_(AR3D_SU,UCPLANE,ATTR_COMP,Z,2) \
_(AR3D_SU,UCPLANE,ATTR_COMP,W,3)
#define AR3D_SU_UCPLANE_ATTR_COMP_X                     _MK_ENUM_CONST(0)
#define AR3D_SU_UCPLANE_ATTR_COMP_Y                     _MK_ENUM_CONST(1)
#define AR3D_SU_UCPLANE_ATTR_COMP_Z                     _MK_ENUM_CONST(2)
#define AR3D_SU_UCPLANE_ATTR_COMP_W                     _MK_ENUM_CONST(3)

// enable or disable user clip plane 0
#define REG_FLD_AR3D_SU_UCPLANE_ENABLE(_) _(AR3D_SU,UCPLANE,ENABLE,1,10,10,3,0x1,0x0,DISABLED,ENM)
#define LIST_REG_ENM_AR3D_SU_UCPLANE_ENABLE(_) \
_(AR3D_SU,UCPLANE,ENABLE,DISABLED,0) \
_(AR3D_SU,UCPLANE,ENABLE,ENABLED,1)
#define AR3D_SU_UCPLANE_ENABLE_DISABLED                 _MK_ENUM_CONST(0)
#define AR3D_SU_UCPLANE_ENABLE_ENABLED                  _MK_ENUM_CONST(1)

// reserved space for future expansion
// Second-level clock enable override register
//
// This can override the 2nd level clock enables in case of malfunction.
// Only exposed to software when needed.
//

// Register AR3D_SU_CLKEN_OVERRIDE 
#define LIST_REG_FLD_AR3D_SU_CLKEN_OVERRIDE(_) \
_(AR3D_SU,CLKEN_OVERRIDE,GR3D_SETUPDPCLK_CLKEN_OVR)
#define REG_AR3D_SU_CLKEN_OVERRIDE(_) _(AR3D_SU,CLKEN_OVERRIDE,0x363,0x63,1,1,0x1,0x0,NOARY,FLD)
#define REG_FLD_AR3D_SU_CLKEN_OVERRIDE_GR3D_SETUPDPCLK_CLKEN_OVR(_) _(AR3D_SU,CLKEN_OVERRIDE,GR3D_SETUPDPCLK_CLKEN_OVR,1,0,0,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLKEN_OVERRIDE_GR3D_SETUPDPCLK_CLKEN_OVR(_) \
_(AR3D_SU,CLKEN_OVERRIDE,GR3D_SETUPDPCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLKEN_OVERRIDE,GR3D_SETUPDPCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLKEN_OVERRIDE_GR3D_SETUPDPCLK_CLKEN_OVR_CLK_GATED                      _MK_ENUM_CONST(0)
#define AR3D_SU_CLKEN_OVERRIDE_GR3D_SETUPDPCLK_CLKEN_OVR_CLK_ALWAYS_ON                  _MK_ENUM_CONST(1)


// Register AR3D_SU_CLIP_CLKEN_OVERRIDE 
#define LIST_REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCGCLK_CLKEN_OVR) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCCCLK_CLKEN_OVR) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCPCLK_CLKEN_OVR) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPVPCLK_CLKEN_OVR) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPARCLK_CLKEN_OVR) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPPACLK_CLKEN_OVR) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPDZCLK_CLKEN_OVR) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPTICLK_CLKEN_OVR) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPSICLK_CLKEN_OVR)
#define REG_AR3D_SU_CLIP_CLKEN_OVERRIDE(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,0x364,0x64,1,1,0x1ff,0x0,NOARY,FLD)
// Fine Grain override for the gr3dclipcgclk
#define REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCGCLK_CLKEN_OVR(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCGCLK_CLKEN_OVR,1,0,0,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCGCLK_CLKEN_OVR(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCGCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCGCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCGCLK_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCGCLK_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipccclk
#define REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCCCLK_CLKEN_OVR(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCCCLK_CLKEN_OVR,1,1,1,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCCCLK_CLKEN_OVR(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCCCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCCCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCCCLK_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCCCLK_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipcpclk
#define REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCPCLK_CLKEN_OVR(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCPCLK_CLKEN_OVR,1,2,2,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCPCLK_CLKEN_OVR(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCPCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPCPCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCPCLK_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPCPCLK_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipvpclk
#define REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPVPCLK_CLKEN_OVR(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPVPCLK_CLKEN_OVR,1,3,3,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPVPCLK_CLKEN_OVR(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPVPCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPVPCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPVPCLK_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPVPCLK_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dcliparclk
#define REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPARCLK_CLKEN_OVR(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPARCLK_CLKEN_OVR,1,4,4,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPARCLK_CLKEN_OVR(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPARCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPARCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPARCLK_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPARCLK_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclippaclk
#define REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPPACLK_CLKEN_OVR(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPPACLK_CLKEN_OVR,1,5,5,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPPACLK_CLKEN_OVR(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPPACLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPPACLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPPACLK_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPPACLK_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipdzclk
#define REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPDZCLK_CLKEN_OVR(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPDZCLK_CLKEN_OVR,1,6,6,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPDZCLK_CLKEN_OVR(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPDZCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPDZCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPDZCLK_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPDZCLK_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipticlk
#define REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPTICLK_CLKEN_OVR(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPTICLK_CLKEN_OVR,1,7,7,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPTICLK_CLKEN_OVR(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPTICLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPTICLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPTICLK_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPTICLK_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipsiclk
#define REG_FLD_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPSICLK_CLKEN_OVR(_) _(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPSICLK_CLKEN_OVR,1,8,8,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPSICLK_CLKEN_OVR(_) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPSICLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,CLIPSICLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPSICLK_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_SU_CLIP_CLKEN_OVERRIDE_CLIPSICLK_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// This file has all the reg/packet definitions related to Raster unit in AR20
// This file is included by ar3d.spec
#define QRAST_SCOREBOARD_DEPTH  64
#define QRAST_SCOREBOARD_WIDTH  64
#define QRAST_QUAD_COUNT_WIDTH  22
#define QRAST_NUM_EDGES_PER_TRIANGLE    4
#define QRAST_NUM_SAMPLES_PER_PIXEL     5
#define QRAST_NUM_VIRT_SAMPLES_PER_PIXEL        4
#define QRAST_NUM_PIXEL_ROWS_PER_QUAD   2
#define QRAST_NUM_PIXEL_COLS_PER_QUAD   2
#define QRAST_NUM_PIXEL_ROWS_PER_FINE_STAMP     3
#define QRAST_NUM_PIXEL_COLS_PER_FINE_STAMP     3
#define QRAST_FDC_CACHE_LINE_LEN        8
#define QRAST_TILE_HEIGHT_IN_PIXELS     16
#define QRAST_SCOREBOARD_TILE_X_SIZE    16
#define QRAST_SCOREBOARD_TILE_Y_SIZE    16
#define QRAST_SCOREBOARD_SIZE   2048
#define QRAST_SCOREBOARD_CACHEA_SIZE    7
#define QRAST_SCOREBOARD_CACHEB_SIZE    2
#define QRAST_NUM_QRAST_FDC_READ_PORTS  2
#define QRAST_NUM_QRAST_FDC_WRITE_PORTS 2
#define QRAST_ZSER_FIFO_DEPTH   64
// There's no way to define an array in the spec system, so just list out the sample
// points here.
#define QRAST_REAL_SAMP_X       0
#define QRAST_REAL_SAMP_Y       0
#define QRAST_VIRT_A_SAMP_X     6
#define QRAST_VIRT_A_SAMP_Y     2
#define QRAST_VIRT_B_SAMP_X     14
#define QRAST_VIRT_B_SAMP_Y     6
#define QRAST_VIRT_C_SAMP_X     2
#define QRAST_VIRT_C_SAMP_Y     10
#define QRAST_VIRT_D_SAMP_X     10
#define QRAST_VIRT_D_SAMP_Y     14
// General Qrast Programming
//
// There are 4 basic operating modes in QRast: Early mode, Late mode,
// CtoA mode, and OVG mode. Early mode refers to programming QRast to
// perform the depth, stencil, and VCAA operations which update those
// surfaces. Late mode refers to programming QRast to not touch the
// depth, stencil, and VCAA surfaces because the pixel shader is
// modifying the coverage information. In Late mode, the pixel shader
// writes the depth, stencil, and VCAA surfaces. CtoA is an abbreviation
// of Coverage-To-Alpha. In this mode, QRast is computing the fragment
// coverage and passing that information to the shader to use as the
// alpha value in rendering. This is distinct from Late mode in that
// there is no VCAA surface involved in CtoA. OVG is the mode where 2
// passes occur: the first pass renders the coverage information into the
// stencil buffer, and the second pass takes the stencil-coverage data
// and sends it to the shader.
//
// In Early mode, only pixels which pass the pixel tests (e.g. stencil
// test) are sent to the shader. Thus, this mode is synonymous with
// setting OUTPUT_TO_SHADER.PASS_ONLY to ENABLE. When in early mode,
// where QRast is updating the depth, stencil and/or VCAA surfaces, the
// following constraints must be met:
//       It is illegal to set OUTPUT_TO_SHADER.VCAA_OUTPUT to MERGE.
//
// In Late mode, pixels which fail the pixel tests (e.g. stencil test)
// are sent to the shader in addition to pixels which pass the pixel
// tests. This mode is synonymous with setting OUTPUT_TO_SHADER.PASS_ONLY
// to DISABLE. When in late mode where the shader is updating the depth,
// stencil, and/or VCAA surfaces, the following constraints must also be
// met:
//       It is illegal to set OUTPUT_TO_SHADER.SWALLOW_QUADS to ALL.
//
// In OVG mode there are two passes. The first pass writes the coverage
// information into the stencil buffer. The second pass reads the
// stencil-coverage data and sends it down to shader. This mode is
// synonymous with OUTPUT_TO_SHADER.VCAA_OUTPUT set to
// STENCIL_COVERAGE. In this mode there are several additional
// requirements:
//       VCAA_OPERATION.VIRTUAL_AS_REAL must be ENABLED
//       VCAA_OPERATION.SILHOUETTE must be DISABLED.
//       VCAA_OPERATION.TRANSPARENCY must be DISABLED.
//       VCAA_OPERATION.VCAA_ENABLE must be DISABLED.
//       S_ENABLE must be DISABLED (no stencil operations!)
//       OUTPUT_TO_SHADER.PASS_ONLY must be ENABLED.
//
// In CtoA mode, QRast computes the virtual coverage values and treats
// pixels which have virtual-only coverage in the same manner as pixels
// with real coverage. In other words, a pixel with virtual-only coverage
// which passes the depth test will update the depth buffer. Hence this
// mode is synonymous with VCAA_OPERATION.VIRTUAL_AS_REAL is ENABLE with
// OUTPUT_TO_SHADER.VCAA_OUTPUT not set to STENCIL_COVERAGE (see OVG
// above). In CtoA mode, the following constraints must be met:
//       VCAA_OPERATION.SILHOUETTE must be DISABLED
//       VCAA_OPERATION.TRANSPARENCY must be DISABLED
//       OUTPUT_TO_SHADER.SWALLOW_QUADS cannot be VIRTUAL
//
// Finally, independent of the operating mode, two additional rules exist
// for programming QRast:
//       OUTPUT_TO_SHADER.VCAA_OUTPUT can only be set to MERGE when 
//        VCAA_ENABLE is ENABLE.
//       VCAA_OPERATION.SILHOUETTE can only be ENABLED when VCAA_ENABLE 
//        is ENABLE.
//
// S_TEST contains the per-face stencil test operations.  This
// includes the MASK and FUNCTION parameters from the StencilFunc()
// call.  The REF value from StencilFunc() is contained in the
// S_OPERATION register because it is needed by multiple units (as
// opposed to the data here which is needed only by QRAST).

// Register AR3D_QR_S_TEST 
#define LIST_REG_FLD_AR3D_QR_S_TEST(_) \
_(AR3D_QR,S_TEST,S_MASK) \
_(AR3D_QR,S_TEST,S_FUNC)
#define REG_AR3D_QR_S_TEST(_) _(AR3D_QR,S_TEST,0x400,0x0,2,1,0x7ff,0x0,ARY,FLD)
// Stencil test mask from StencilFunc()
#define REG_FLD_AR3D_QR_S_TEST_S_MASK(_) _(AR3D_QR,S_TEST,S_MASK,8,7,0,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_S_TEST_S_MASK(_)

// Stencil function from StencilFunc()
#define REG_FLD_AR3D_QR_S_TEST_S_FUNC(_) _(AR3D_QR,S_TEST,S_FUNC,3,10,8,3,0x7,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_S_TEST_S_FUNC(_) \
_(AR3D_QR,S_TEST,S_FUNC,NEVER,0) \
_(AR3D_QR,S_TEST,S_FUNC,LESS,1) \
_(AR3D_QR,S_TEST,S_FUNC,EQUAL,2) \
_(AR3D_QR,S_TEST,S_FUNC,LEQUAL,3) \
_(AR3D_QR,S_TEST,S_FUNC,GREATER,4) \
_(AR3D_QR,S_TEST,S_FUNC,NOTEQUAL,5) \
_(AR3D_QR,S_TEST,S_FUNC,GEQUAL,6) \
_(AR3D_QR,S_TEST,S_FUNC,ALWAYS,7)
#define AR3D_QR_S_TEST_S_FUNC_NEVER                     _MK_ENUM_CONST(0)
#define AR3D_QR_S_TEST_S_FUNC_LESS                      _MK_ENUM_CONST(1)
#define AR3D_QR_S_TEST_S_FUNC_EQUAL                     _MK_ENUM_CONST(2)
#define AR3D_QR_S_TEST_S_FUNC_LEQUAL                    _MK_ENUM_CONST(3)
#define AR3D_QR_S_TEST_S_FUNC_GREATER                   _MK_ENUM_CONST(4)
#define AR3D_QR_S_TEST_S_FUNC_NOTEQUAL                  _MK_ENUM_CONST(5)
#define AR3D_QR_S_TEST_S_FUNC_GEQUAL                    _MK_ENUM_CONST(6)
#define AR3D_QR_S_TEST_S_FUNC_ALWAYS                    _MK_ENUM_CONST(7)

// S_CTRL contains the universal stencil controls.  These are values
// that are not per-face, but rather have a single value that applies
// to all faces.  COVERAGE_MERGE is for OVG functionality -- it allows
// the coverage data to be merged with the stencil value.  The
// coverage data is formed by concatenating the virtual coverage bits
// into a 5 bit value (real sample is in bit 0, virtual samples are in
// bits 1-4).

// Register AR3D_QR_S_CTRL 
#define LIST_REG_FLD_AR3D_QR_S_CTRL(_) \
_(AR3D_QR,S_CTRL,COVERAGE_MERGE) \
_(AR3D_QR,S_CTRL,S_SURF_PTR) \
_(AR3D_QR,S_CTRL,S_ENABLE) \
_(AR3D_QR,S_CTRL,QRAST_FB_WRITE)
#define REG_AR3D_QR_S_CTRL(_) _(AR3D_QR,S_CTRL,0x402,0x2,1,1,0x7f,0x0,NOARY,FLD)
// NONE: Do not modify the stencil value with coverage.
// Bitwise OR the coverage bits with the stencil value.
// Bitwise XOR the coverage bits with the stencil value.
// Bitwise OR the coverage bits with the INVERTED stencil value.
#define REG_FLD_AR3D_QR_S_CTRL_COVERAGE_MERGE(_) _(AR3D_QR,S_CTRL,COVERAGE_MERGE,2,1,0,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_S_CTRL_COVERAGE_MERGE(_) \
_(AR3D_QR,S_CTRL,COVERAGE_MERGE,NONE,0) \
_(AR3D_QR,S_CTRL,COVERAGE_MERGE,OR,1) \
_(AR3D_QR,S_CTRL,COVERAGE_MERGE,XOR,2) \
_(AR3D_QR,S_CTRL,COVERAGE_MERGE,OR_NOT,3)
#define AR3D_QR_S_CTRL_COVERAGE_MERGE_NONE                      _MK_ENUM_CONST(0)
#define AR3D_QR_S_CTRL_COVERAGE_MERGE_OR                        _MK_ENUM_CONST(1)
#define AR3D_QR_S_CTRL_COVERAGE_MERGE_XOR                       _MK_ENUM_CONST(2)
#define AR3D_QR_S_CTRL_COVERAGE_MERGE_OR_NOT                    _MK_ENUM_CONST(3)

// Pointer to the stencil surface in the surface tables.  Note that the only
// allowed value for this field is currently NV_GR3D_S_SURF_PTR.
#define REG_FLD_AR3D_QR_S_CTRL_S_SURF_PTR(_) _(AR3D_QR,S_CTRL,S_SURF_PTR,3,4,2,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_S_CTRL_S_SURF_PTR(_)

// DISABLE: The stencil test is disabled.  All pixels pass.
// ENABLE:  The stencil test is enabled.
#define REG_FLD_AR3D_QR_S_CTRL_S_ENABLE(_) _(AR3D_QR,S_CTRL,S_ENABLE,1,5,5,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_S_CTRL_S_ENABLE(_) \
_(AR3D_QR,S_CTRL,S_ENABLE,DISABLE,0) \
_(AR3D_QR,S_CTRL,S_ENABLE,ENABLE,1)
#define AR3D_QR_S_CTRL_S_ENABLE_DISABLE                 _MK_ENUM_CONST(0)
#define AR3D_QR_S_CTRL_S_ENABLE_ENABLE                  _MK_ENUM_CONST(1)

// DISABLE: QRAST does not write to the stencil surface (with the
// assumption being that the shader has been modified to
// do it).
// ENABLE: QRAST updates the stencil surface with the result of
// the stencil operation.
#define REG_FLD_AR3D_QR_S_CTRL_QRAST_FB_WRITE(_) _(AR3D_QR,S_CTRL,QRAST_FB_WRITE,1,6,6,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_S_CTRL_QRAST_FB_WRITE(_) \
_(AR3D_QR,S_CTRL,QRAST_FB_WRITE,DISABLE,0) \
_(AR3D_QR,S_CTRL,QRAST_FB_WRITE,ENABLE,1)
#define AR3D_QR_S_CTRL_QRAST_FB_WRITE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_QR_S_CTRL_QRAST_FB_WRITE_ENABLE                    _MK_ENUM_CONST(1)

// Z_TEST defines the depth surface and the associated depth test
// operation.  This includes Z_FUNC from DepthFunc(), and depth
// test enable from Enable().

// Register AR3D_QR_Z_TEST 
#define LIST_REG_FLD_AR3D_QR_Z_TEST(_) \
_(AR3D_QR,Z_TEST,Z_SURF_PTR) \
_(AR3D_QR,Z_TEST,Z_ENABLE) \
_(AR3D_QR,Z_TEST,Z_FUNC) \
_(AR3D_QR,Z_TEST,QRAST_FB_WRITE) \
_(AR3D_QR,Z_TEST,Z_CLAMP) \
_(AR3D_QR,Z_TEST,Z_CLAMP_OVERRIDE)
#define REG_AR3D_QR_Z_TEST(_) _(AR3D_QR,Z_TEST,0x403,0x3,1,1,0x7ff,0x0,NOARY,FLD)
// Z surface pointer to fetch through.  Note that the only
// allowed value for this field is NV_GR3D_Z_SURF_PTR.
#define REG_FLD_AR3D_QR_Z_TEST_Z_SURF_PTR(_) _(AR3D_QR,Z_TEST,Z_SURF_PTR,3,2,0,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_Z_TEST_Z_SURF_PTR(_)

// DISABLE: The depth test is disabled.  All pixels pass.
// ENABLE:The depth test is enabled.
#define REG_FLD_AR3D_QR_Z_TEST_Z_ENABLE(_) _(AR3D_QR,Z_TEST,Z_ENABLE,1,3,3,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_Z_TEST_Z_ENABLE(_) \
_(AR3D_QR,Z_TEST,Z_ENABLE,DISABLE,0) \
_(AR3D_QR,Z_TEST,Z_ENABLE,ENABLE,1)
#define AR3D_QR_Z_TEST_Z_ENABLE_DISABLE                 _MK_ENUM_CONST(0)
#define AR3D_QR_Z_TEST_Z_ENABLE_ENABLE                  _MK_ENUM_CONST(1)

// Z function
#define REG_FLD_AR3D_QR_Z_TEST_Z_FUNC(_) _(AR3D_QR,Z_TEST,Z_FUNC,4,7,4,3,0xf,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_Z_TEST_Z_FUNC(_) \
_(AR3D_QR,Z_TEST,Z_FUNC,NEVER,0) \
_(AR3D_QR,Z_TEST,Z_FUNC,LESS,1) \
_(AR3D_QR,Z_TEST,Z_FUNC,EQUAL,2) \
_(AR3D_QR,Z_TEST,Z_FUNC,LEQUAL,3) \
_(AR3D_QR,Z_TEST,Z_FUNC,GREATER,4) \
_(AR3D_QR,Z_TEST,Z_FUNC,NOTEQUAL,5) \
_(AR3D_QR,Z_TEST,Z_FUNC,GEQUAL,6) \
_(AR3D_QR,Z_TEST,Z_FUNC,ALWAYS,7)
#define AR3D_QR_Z_TEST_Z_FUNC_NEVER                     _MK_ENUM_CONST(0)
#define AR3D_QR_Z_TEST_Z_FUNC_LESS                      _MK_ENUM_CONST(1)
#define AR3D_QR_Z_TEST_Z_FUNC_EQUAL                     _MK_ENUM_CONST(2)
#define AR3D_QR_Z_TEST_Z_FUNC_LEQUAL                    _MK_ENUM_CONST(3)
#define AR3D_QR_Z_TEST_Z_FUNC_GREATER                   _MK_ENUM_CONST(4)
#define AR3D_QR_Z_TEST_Z_FUNC_NOTEQUAL                  _MK_ENUM_CONST(5)
#define AR3D_QR_Z_TEST_Z_FUNC_GEQUAL                    _MK_ENUM_CONST(6)
#define AR3D_QR_Z_TEST_Z_FUNC_ALWAYS                    _MK_ENUM_CONST(7)

// DISABLE: QRAST does not write to the depth surface (with the
// assumption being that the shader has been modified to
// do it).
// ENABLE QRAST updates the depth surface with the result of
// the depth operation.
#define REG_FLD_AR3D_QR_Z_TEST_QRAST_FB_WRITE(_) _(AR3D_QR,Z_TEST,QRAST_FB_WRITE,1,8,8,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_Z_TEST_QRAST_FB_WRITE(_) \
_(AR3D_QR,Z_TEST,QRAST_FB_WRITE,DISABLE,0) \
_(AR3D_QR,Z_TEST,QRAST_FB_WRITE,ENABLE,1)
#define AR3D_QR_Z_TEST_QRAST_FB_WRITE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_QR_Z_TEST_QRAST_FB_WRITE_ENABLE                    _MK_ENUM_CONST(1)

// CLAMP: Depth values which are out of range are clamped.
// KILL: Depth values which are out of range kill the pixel.
#define REG_FLD_AR3D_QR_Z_TEST_Z_CLAMP(_) _(AR3D_QR,Z_TEST,Z_CLAMP,1,9,9,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_Z_TEST_Z_CLAMP(_) \
_(AR3D_QR,Z_TEST,Z_CLAMP,CLAMP,0) \
_(AR3D_QR,Z_TEST,Z_CLAMP,KILL,1)
#define AR3D_QR_Z_TEST_Z_CLAMP_CLAMP                    _MK_ENUM_CONST(0)
#define AR3D_QR_Z_TEST_Z_CLAMP_KILL                     _MK_ENUM_CONST(1)

// Normally, Z_CLAMP is performed whenever depth test is enabled. 
// When Z_CLAMP_OVERRIDE is set to ENABLE, the depth computation
// and depth clamp are performed even if the depth test is disabled.
// This is used to clip pixels outside of the [0, 1] range in conjunction
// with clip's z-guard-band.
// Setting Z_CLAMP_OVERRIDE to ENABLE when depth test is enabled 
// (read nvbug:401697) causes extra reads to be issued from qrast
// scoreboard logic.  In order to work-around this, s/w must set
// Z_CLAMP_OVERRIDE to enable only when depth test is disabled.
#define REG_FLD_AR3D_QR_Z_TEST_Z_CLAMP_OVERRIDE(_) _(AR3D_QR,Z_TEST,Z_CLAMP_OVERRIDE,1,10,10,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_Z_TEST_Z_CLAMP_OVERRIDE(_) \
_(AR3D_QR,Z_TEST,Z_CLAMP_OVERRIDE,DISABLE,0) \
_(AR3D_QR,Z_TEST,Z_CLAMP_OVERRIDE,ENABLE,1)
#define AR3D_QR_Z_TEST_Z_CLAMP_OVERRIDE_DISABLE                 _MK_ENUM_CONST(0)
#define AR3D_QR_Z_TEST_Z_CLAMP_OVERRIDE_ENABLE                  _MK_ENUM_CONST(1)

// Z_MIN is used to implement the DepthRange functionality.  QRast compares this value against
// the fixed point per fragment Z value, and kills or clamps fragments based on the setting of
// Z_CLAMP above.  The comparison is done prior to Z compression, and hence is performed on the
// 20 bit fixed point Z value computed for the pixel.  SW should program this value based on 
// the smaller of the near and far values provided by the application in DepthRange(n, f) as
// given in the following formula:
//
//      float z_min_float = MIN( n, f );
//      Z_MIN = (floor)(z_min_float * (2^20 - 1) + 0.5f)
//
// Note that I assume here that n and f are [0.0 .. 1.0].

// Register AR3D_QR_Z_MIN 
#define LIST_REG_FLD_AR3D_QR_Z_MIN(_) \
_(AR3D_QR,Z_MIN,VALUE)
#define REG_AR3D_QR_Z_MIN(_) _(AR3D_QR,Z_MIN,0x404,0x4,1,1,0xfffff,0x0,NOARY,FLD)
// Depth values below this value are killed or clamped.
#define REG_FLD_AR3D_QR_Z_MIN_VALUE(_) _(AR3D_QR,Z_MIN,VALUE,20,19,0,3,0xfffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_Z_MIN_VALUE(_)

// Z_MAX is used to implement the DepthRange functionality.  QRast compares this value against
// the fixed point per fragment Z value, and kills or clamps fragments based on the setting of
// Z_CLAMP above.  The comparison is done prior to Z compression, and hence is performed on the
// 20 bit fixed point Z value computed for the pixel.  SW should program this value based on 
// the smaller of the near and far values provided by the application in DepthRange(n, f) as
// given in the following formula:
//
//      float z_max_float = MAX( n, f );
//      Z_MAX = (floor)(z_max_float * (2^20 - 1) + 0.5f)
//
// Note that I assume here that n and f are [0.0 .. 1.0].

// Register AR3D_QR_Z_MAX 
#define LIST_REG_FLD_AR3D_QR_Z_MAX(_) \
_(AR3D_QR,Z_MAX,VALUE)
#define REG_AR3D_QR_Z_MAX(_) _(AR3D_QR,Z_MAX,0x405,0x5,1,1,0xfffff,0x0,NOARY,FLD)
// Depth values above this value are killed or clamped.
#define REG_FLD_AR3D_QR_Z_MAX_VALUE(_) _(AR3D_QR,Z_MAX,VALUE,20,19,0,3,0xfffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_Z_MAX_VALUE(_)

// RAST_OPERATION controls the rasterization order in QRAST.  Note
// that due to the number of delta bits, swathing at more than 16
// pixels wide is going to cause span starts to be inserted, so at
// that point, we should just do the whole line.

// Register AR3D_QR_RAST_OPERATION 
#define LIST_REG_FLD_AR3D_QR_RAST_OPERATION(_) \
_(AR3D_QR,RAST_OPERATION,SWATH_WIDTH) \
_(AR3D_QR,RAST_OPERATION,V_DIRECTION)
#define REG_AR3D_QR_RAST_OPERATION(_) _(AR3D_QR,RAST_OPERATION,0x406,0x6,1,1,0x7,0x0,NOARY,FLD)
// PIX_8: Rasterize in columns that are 8 pixels wide.
// PIX_16:Rasterize in columns that are 16 pixels wide.
#define REG_FLD_AR3D_QR_RAST_OPERATION_SWATH_WIDTH(_) _(AR3D_QR,RAST_OPERATION,SWATH_WIDTH,2,1,0,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_RAST_OPERATION_SWATH_WIDTH(_) \
_(AR3D_QR,RAST_OPERATION,SWATH_WIDTH,PIX_8,0) \
_(AR3D_QR,RAST_OPERATION,SWATH_WIDTH,PIX_16,1)
#define AR3D_QR_RAST_OPERATION_SWATH_WIDTH_PIX_8                        _MK_ENUM_CONST(0)
#define AR3D_QR_RAST_OPERATION_SWATH_WIDTH_PIX_16                       _MK_ENUM_CONST(1)

// DOWN: Always rasterize from top down for any triangle.
// ALTERNATE: When swathing, rasterize columns in alternating directions.
#define REG_FLD_AR3D_QR_RAST_OPERATION_V_DIRECTION(_) _(AR3D_QR,RAST_OPERATION,V_DIRECTION,1,2,2,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_RAST_OPERATION_V_DIRECTION(_) \
_(AR3D_QR,RAST_OPERATION,V_DIRECTION,DOWN,0) \
_(AR3D_QR,RAST_OPERATION,V_DIRECTION,ALTERNATE,1)
#define AR3D_QR_RAST_OPERATION_V_DIRECTION_DOWN                 _MK_ENUM_CONST(0)
#define AR3D_QR_RAST_OPERATION_V_DIRECTION_ALTERNATE                    _MK_ENUM_CONST(1)

// RAST_SCISSOR_SNAP controls the generation and usage of the
// internal qrast scissor rectangle (note that this is separate and
// distinct from the glScissor functionality).  

// Register AR3D_QR_RAST_SCISSOR_SNAP 
#define LIST_REG_FLD_AR3D_QR_RAST_SCISSOR_SNAP(_) \
_(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_SNAP) \
_(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_UPDATE) \
_(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_UPDATE_WRITE) \
_(AR3D_QR,RAST_SCISSOR_SNAP,BBOX_ACCUMULATE) \
_(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_ENABLE)
#define REG_AR3D_QR_RAST_SCISSOR_SNAP(_) _(AR3D_QR,RAST_SCISSOR_SNAP,0x407,0x7,1,1,0x3f,0x0,NOARY,FLD)
// NOP: Has no effect on the scissor values.
// Setting the RAST_SCISSOR_SNAP to SAMPLE causes the RAST_BBOX values
// to be immediately transfered to the RAST_SCISSOR values.  This
// has the side effect of setting the RAST_SCISSOR_UPDATE bit.
// Setting the SNAP value to STALL causes the pipe to stall until
// the RAST_SCISSOR_UPDATE bit has been set to '1' by a SAMPLE operation.
#define REG_FLD_AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_SNAP(_) _(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_SNAP,2,1,0,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_SNAP(_) \
_(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_SNAP,NOP,0) \
_(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_SNAP,SAMPLE,1) \
_(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_SNAP,STALL,2)
#define AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_SNAP_NOP                 _MK_ENUM_CONST(0)
#define AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_SNAP_SAMPLE                      _MK_ENUM_CONST(1)
#define AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_SNAP_STALL                       _MK_ENUM_CONST(2)

// See RAST_SCISSOR_SNAP.
#define REG_FLD_AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_UPDATE(_) _(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_UPDATE,1,2,2,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_UPDATE(_)

// Writing a '1' here causes the value written to the RAST_SCISSOR_UPDATE
// to be used by the HW.  This allows the driver to restore the state
// of that bit after a context switch.
#define REG_FLD_AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_UPDATE_WRITE(_) _(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_UPDATE_WRITE,1,3,3,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_UPDATE_WRITE(_)

// DISABLE: QRAST does not change the value of the RAST_BBOX registers.
// ENABLE:  QRAST updates the RAST_BBOX registers based on pixels which are visible.
#define REG_FLD_AR3D_QR_RAST_SCISSOR_SNAP_BBOX_ACCUMULATE(_) _(AR3D_QR,RAST_SCISSOR_SNAP,BBOX_ACCUMULATE,1,4,4,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_RAST_SCISSOR_SNAP_BBOX_ACCUMULATE(_) \
_(AR3D_QR,RAST_SCISSOR_SNAP,BBOX_ACCUMULATE,DISABLE,0) \
_(AR3D_QR,RAST_SCISSOR_SNAP,BBOX_ACCUMULATE,ENABLE,1)
#define AR3D_QR_RAST_SCISSOR_SNAP_BBOX_ACCUMULATE_DISABLE                       _MK_ENUM_CONST(0)
#define AR3D_QR_RAST_SCISSOR_SNAP_BBOX_ACCUMULATE_ENABLE                        _MK_ENUM_CONST(1)

// DISABLE: QRAST does no additional scissoring (see RAST_SCISSOR)
// ENABLE:  QRAST uses the RAST_SCISSOR values in determining visibility.
#define REG_FLD_AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_ENABLE(_) _(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_ENABLE,1,5,5,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_ENABLE(_) \
_(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_ENABLE,DISABLE,0) \
_(AR3D_QR,RAST_SCISSOR_SNAP,RAST_SCISSOR_ENABLE,ENABLE,1)
#define AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_QR_RAST_SCISSOR_SNAP_RAST_SCISSOR_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

// QRAST implements a separate SCISSOR function in addition to the
// usual OpenGL scissor implemented in SETUP.  The QRAST scissor is
// used to scissor the rendered region based on the result of an
// accumulated scissor window from the Depth/Stencil/Coverage test.
// See the RAST_SCISSOR_SNAP register for information on programming
// this value automatically.  RAST_SCISSOR_MIN and RAST_SCISSOR_MAX
// contain the current scissor rectangle used for the QRAST scissor.

// Register AR3D_QR_RAST_SCISSOR_MIN 
#define LIST_REG_FLD_AR3D_QR_RAST_SCISSOR_MIN(_) \
_(AR3D_QR,RAST_SCISSOR_MIN,X) \
_(AR3D_QR,RAST_SCISSOR_MIN,Y)
#define REG_AR3D_QR_RAST_SCISSOR_MIN(_) _(AR3D_QR,RAST_SCISSOR_MIN,0x408,0x8,1,1,0x1fff1fff,0x0,NOARY,FLD)
// Current QRAST SCISSOR X-MIN. 
#define REG_FLD_AR3D_QR_RAST_SCISSOR_MIN_X(_) _(AR3D_QR,RAST_SCISSOR_MIN,X,13,12,0,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_SCISSOR_MIN_X(_)

// Current QRAST SCISSOR Y-MIN. 
#define REG_FLD_AR3D_QR_RAST_SCISSOR_MIN_Y(_) _(AR3D_QR,RAST_SCISSOR_MIN,Y,13,28,16,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_SCISSOR_MIN_Y(_)


// Register AR3D_QR_RAST_SCISSOR_MAX 
#define LIST_REG_FLD_AR3D_QR_RAST_SCISSOR_MAX(_) \
_(AR3D_QR,RAST_SCISSOR_MAX,X) \
_(AR3D_QR,RAST_SCISSOR_MAX,Y)
#define REG_AR3D_QR_RAST_SCISSOR_MAX(_) _(AR3D_QR,RAST_SCISSOR_MAX,0x409,0x9,1,1,0x1fff1fff,0x0,NOARY,FLD)
// Current QRAST SCISSOR Y-MAX.
#define REG_FLD_AR3D_QR_RAST_SCISSOR_MAX_X(_) _(AR3D_QR,RAST_SCISSOR_MAX,X,13,12,0,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_SCISSOR_MAX_X(_)

// Current QRAST SCISSOR Y-MAX. 
#define REG_FLD_AR3D_QR_RAST_SCISSOR_MAX_Y(_) _(AR3D_QR,RAST_SCISSOR_MAX,Y,13,28,16,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_SCISSOR_MAX_Y(_)

// RAST_BBOX_MIN and RAST_BBOX_MAX contained the accumulated qrast
// geometry bounding box.  See QRAST_SCISSOR_UPDATE for information
// on transferring this value into the RAST_SCISSOR registers.

// Register AR3D_QR_RAST_BBOX_MIN 
#define LIST_REG_FLD_AR3D_QR_RAST_BBOX_MIN(_) \
_(AR3D_QR,RAST_BBOX_MIN,X) \
_(AR3D_QR,RAST_BBOX_MIN,Y)
#define REG_AR3D_QR_RAST_BBOX_MIN(_) _(AR3D_QR,RAST_BBOX_MIN,0x40a,0xa,1,1,0x1fff1fff,0x0,NOARY,FLD)
// Accumulated bounding box X-MIN. 
#define REG_FLD_AR3D_QR_RAST_BBOX_MIN_X(_) _(AR3D_QR,RAST_BBOX_MIN,X,13,12,0,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_BBOX_MIN_X(_)

// Accumulated bounding box Y-MIN.
#define REG_FLD_AR3D_QR_RAST_BBOX_MIN_Y(_) _(AR3D_QR,RAST_BBOX_MIN,Y,13,28,16,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_BBOX_MIN_Y(_)


// Register AR3D_QR_RAST_BBOX_MAX 
#define LIST_REG_FLD_AR3D_QR_RAST_BBOX_MAX(_) \
_(AR3D_QR,RAST_BBOX_MAX,X) \
_(AR3D_QR,RAST_BBOX_MAX,Y)
#define REG_AR3D_QR_RAST_BBOX_MAX(_) _(AR3D_QR,RAST_BBOX_MAX,0x40b,0xb,1,1,0x1fff1fff,0x0,NOARY,FLD)
// Accumulated bounding box X-MAX. 
#define REG_FLD_AR3D_QR_RAST_BBOX_MAX_X(_) _(AR3D_QR,RAST_BBOX_MAX,X,13,12,0,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_BBOX_MAX_X(_)

// Accumulated bounding box Y-MAX. 
#define REG_FLD_AR3D_QR_RAST_BBOX_MAX_Y(_) _(AR3D_QR,RAST_BBOX_MAX,Y,13,28,16,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_RAST_BBOX_MAX_Y(_)

// SB_OPERATION is the register which controls how the scoreboard in
// the QRAST unit behaves.  
//
// When the scoreboard is switched off, any pixels which are in the
// pipeline will continue to clear entries in the scoreboard -- no new
// entries will be made for new pixel data, and no new pixels will be
// stalled based on the state of scoreboard.

// Register AR3D_QR_SB_OPERATION 
#define LIST_REG_FLD_AR3D_QR_SB_OPERATION(_) \
_(AR3D_QR,SB_OPERATION,GRANULARITY) \
_(AR3D_QR,SB_OPERATION,INDEX_MODE) \
_(AR3D_QR,SB_OPERATION,BLOCKING_MODE) \
_(AR3D_QR,SB_OPERATION,STALL) \
_(AR3D_QR,SB_OPERATION,CLEAR) \
_(AR3D_QR,SB_OPERATION,CACHE) \
_(AR3D_QR,SB_OPERATION,RD_OPTZ_CYA)
#define REG_AR3D_QR_SB_OPERATION(_) _(AR3D_QR,SB_OPERATION,0x40c,0xc,1,1,0x3ff,0x0,NOARY,FLD)
// OFF: The scoreboard is disabled.
// PER_PIXEL: The scoreboard has 1 entry per pixel.  Only one
// occurance of each visible pixel is allowed in the pipe
// at any time.
// PER_SAMPLE: The scoreboard has 1 entry per pixel. The scoreboard 
// entry is marked if any real or virtual sample associated with 
// a pixel is covered.
// PSEUDO: This is primarily a test mode.  When used, the scoreboard
// memory is unused (off), but the scoreboard accounding packets continue
// to flow in the system.  This is useful because it enables BLOCKING_MODEs
// other than OFF to work.
#define REG_FLD_AR3D_QR_SB_OPERATION_GRANULARITY(_) _(AR3D_QR,SB_OPERATION,GRANULARITY,2,1,0,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_SB_OPERATION_GRANULARITY(_) \
_(AR3D_QR,SB_OPERATION,GRANULARITY,OFF,0) \
_(AR3D_QR,SB_OPERATION,GRANULARITY,PER_SAMPLE,1) \
_(AR3D_QR,SB_OPERATION,GRANULARITY,PER_PIXEL,2) \
_(AR3D_QR,SB_OPERATION,GRANULARITY,PSEUDO,3)
#define AR3D_QR_SB_OPERATION_GRANULARITY_OFF                    _MK_ENUM_CONST(0)
#define AR3D_QR_SB_OPERATION_GRANULARITY_PER_SAMPLE                     _MK_ENUM_CONST(1)
#define AR3D_QR_SB_OPERATION_GRANULARITY_PER_PIXEL                      _MK_ENUM_CONST(2)
#define AR3D_QR_SB_OPERATION_GRANULARITY_PSEUDO                 _MK_ENUM_CONST(3)

// TABLE: The scoreboard address is dereferenced through a table 
// to allow for maximum travel horizontally or vertically 
// before a collision occurs.
// FORMULA: The scoreboard address is computed from the (x,y) directly.
// This maximizes distance for rectangular regions at the cost of
// potential performance in slivery triangles. In tests before tapeout,
// this had better performance.
// RESERVED_1 and RESERVED_2 are present for future use.
#define REG_FLD_AR3D_QR_SB_OPERATION_INDEX_MODE(_) _(AR3D_QR,SB_OPERATION,INDEX_MODE,2,3,2,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_SB_OPERATION_INDEX_MODE(_) \
_(AR3D_QR,SB_OPERATION,INDEX_MODE,TABLE,0) \
_(AR3D_QR,SB_OPERATION,INDEX_MODE,FORMULA,1) \
_(AR3D_QR,SB_OPERATION,INDEX_MODE,RESERVED_1,2) \
_(AR3D_QR,SB_OPERATION,INDEX_MODE,RESERVED_2,3)
#define AR3D_QR_SB_OPERATION_INDEX_MODE_TABLE                   _MK_ENUM_CONST(0)
#define AR3D_QR_SB_OPERATION_INDEX_MODE_FORMULA                 _MK_ENUM_CONST(1)
#define AR3D_QR_SB_OPERATION_INDEX_MODE_RESERVED_1                      _MK_ENUM_CONST(2)
#define AR3D_QR_SB_OPERATION_INDEX_MODE_RESERVED_2                      _MK_ENUM_CONST(3)

// OFF: Triangles are allowed to flow based on the scoreboard state.
// PER_TRI_RAST: The scoreboard blocks at each triangle boundary
// until the triangle has been completely rasterized and early Z'd.
// This mode works in conjunction with a GRANULARITY other than OFF!
// PER_TRI_SHADER: The scoreboard blocks at each triangle boundary
// until the triangle has been completely rendered. This mode works 
// in conjunction with a GRANULARITY other than OFF!
#define REG_FLD_AR3D_QR_SB_OPERATION_BLOCKING_MODE(_) _(AR3D_QR,SB_OPERATION,BLOCKING_MODE,2,5,4,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_SB_OPERATION_BLOCKING_MODE(_) \
_(AR3D_QR,SB_OPERATION,BLOCKING_MODE,OFF,0) \
_(AR3D_QR,SB_OPERATION,BLOCKING_MODE,PER_TRI_RAST,1) \
_(AR3D_QR,SB_OPERATION,BLOCKING_MODE,PER_TRI_SHADER,2)
#define AR3D_QR_SB_OPERATION_BLOCKING_MODE_OFF                  _MK_ENUM_CONST(0)
#define AR3D_QR_SB_OPERATION_BLOCKING_MODE_PER_TRI_RAST                 _MK_ENUM_CONST(1)
#define AR3D_QR_SB_OPERATION_BLOCKING_MODE_PER_TRI_SHADER                       _MK_ENUM_CONST(2)

// A write of '1' to this bit will not be processed 
// until the scoreboard is empty.  This causes the
// pipe below the scoreboard to drain of all pixels if the scoreboard
// has a non-off GRANULARITY.
#define REG_FLD_AR3D_QR_SB_OPERATION_STALL(_) _(AR3D_QR,SB_OPERATION,STALL,1,6,6,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_SB_OPERATION_STALL(_)

// A write of '1' to this bit will immediately clear 
// all entries in the scoreboard.
#define REG_FLD_AR3D_QR_SB_OPERATION_CLEAR(_) _(AR3D_QR,SB_OPERATION,CLEAR,1,7,7,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_SB_OPERATION_CLEAR(_)

// ON: the depth, stencil, and vcaa caches are used to optimize FDC traffic.
// OFF: the depth, stencil, and vcaa caches always miss, increasing FDC traffic.
#define REG_FLD_AR3D_QR_SB_OPERATION_CACHE(_) _(AR3D_QR,SB_OPERATION,CACHE,1,8,8,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_SB_OPERATION_CACHE(_) \
_(AR3D_QR,SB_OPERATION,CACHE,ON,0) \
_(AR3D_QR,SB_OPERATION,CACHE,OFF,1)
#define AR3D_QR_SB_OPERATION_CACHE_ON                   _MK_ENUM_CONST(0)
#define AR3D_QR_SB_OPERATION_CACHE_OFF                  _MK_ENUM_CONST(1)

// A write of '1' to this bit will disable any read optimisation logic
// in scoreboard
#define REG_FLD_AR3D_QR_SB_OPERATION_RD_OPTZ_CYA(_) _(AR3D_QR,SB_OPERATION,RD_OPTZ_CYA,1,9,9,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_SB_OPERATION_RD_OPTZ_CYA(_)


// Register AR3D_QR_QRAST_CLKEN_OVERRIDE 
#define LIST_REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,PIXTEST_CLKEN_OVR) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,FDCIF_CLKEN_OVR) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,TOP_CLKEN_OVR) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,SCOREBOARD_CLKEN_OVR) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,LATENCYFIFO_CLKEN_OVR) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,ZSER_CLKEN_OVR) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,REG_CLKEN_OVR) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,SETUPIF_CLKEN_OVR) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,TIDZSER_CLKEN_OVR) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,PIPE_CLKEN_OVR)
#define REG_AR3D_QR_QRAST_CLKEN_OVERRIDE(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,0x40d,0xd,1,1,0x3ff,0x0,NOARY,FLD)
// CLK_GATED : Enable clock gating for gr3dqrastpixtestclk; 
// CLK_ALWAYS_ON : Disable clock gating for gr3dqrastpixtestclk
#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_PIXTEST_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,PIXTEST_CLKEN_OVR,1,0,0,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_PIXTEST_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,PIXTEST_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,PIXTEST_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_PIXTEST_CLKEN_OVR_CLK_GATED                        _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_PIXTEST_CLKEN_OVR_CLK_ALWAYS_ON                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_FDCIF_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,FDCIF_CLKEN_OVR,1,1,1,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_FDCIF_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,FDCIF_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,FDCIF_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_FDCIF_CLKEN_OVR_CLK_GATED                  _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_FDCIF_CLKEN_OVR_CLK_ALWAYS_ON                      _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_TOP_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,TOP_CLKEN_OVR,1,2,2,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_TOP_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,TOP_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,TOP_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_TOP_CLKEN_OVR_CLK_GATED                    _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_TOP_CLKEN_OVR_CLK_ALWAYS_ON                        _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_SCOREBOARD_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,SCOREBOARD_CLKEN_OVR,1,3,3,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_SCOREBOARD_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,SCOREBOARD_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,SCOREBOARD_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_SCOREBOARD_CLKEN_OVR_CLK_GATED                     _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_SCOREBOARD_CLKEN_OVR_CLK_ALWAYS_ON                 _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_LATENCYFIFO_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,LATENCYFIFO_CLKEN_OVR,1,4,4,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_LATENCYFIFO_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,LATENCYFIFO_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,LATENCYFIFO_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_LATENCYFIFO_CLKEN_OVR_CLK_GATED                    _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_LATENCYFIFO_CLKEN_OVR_CLK_ALWAYS_ON                        _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_ZSER_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,ZSER_CLKEN_OVR,1,5,5,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_ZSER_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,ZSER_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,ZSER_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_ZSER_CLKEN_OVR_CLK_GATED                   _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_ZSER_CLKEN_OVR_CLK_ALWAYS_ON                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_REG_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,REG_CLKEN_OVR,1,6,6,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_REG_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,REG_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,REG_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_REG_CLKEN_OVR_CLK_GATED                    _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_REG_CLKEN_OVR_CLK_ALWAYS_ON                        _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_SETUPIF_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,SETUPIF_CLKEN_OVR,1,7,7,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_SETUPIF_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,SETUPIF_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,SETUPIF_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_SETUPIF_CLKEN_OVR_CLK_GATED                        _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_SETUPIF_CLKEN_OVR_CLK_ALWAYS_ON                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_TIDZSER_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,TIDZSER_CLKEN_OVR,1,8,8,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_TIDZSER_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,TIDZSER_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,TIDZSER_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_TIDZSER_CLKEN_OVR_CLK_GATED                        _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_TIDZSER_CLKEN_OVR_CLK_ALWAYS_ON                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_QR_QRAST_CLKEN_OVERRIDE_PIPE_CLKEN_OVR(_) _(AR3D_QR,QRAST_CLKEN_OVERRIDE,PIPE_CLKEN_OVR,1,9,9,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_CLKEN_OVERRIDE_PIPE_CLKEN_OVR(_) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,PIPE_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,PIPE_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_PIPE_CLKEN_OVR_CLK_GATED                   _MK_ENUM_CONST(0)
#define AR3D_QR_QRAST_CLKEN_OVERRIDE_PIPE_CLKEN_OVR_CLK_ALWAYS_ON                       _MK_ENUM_CONST(1)

// The VCAA_OPERATION register controls the VCAA computation and
// output within QRAST.  The VCAA computation is disabled whenever
// VCAA_OUTPUT is DISABLED and QRAST_WRITE is disabled.  Turning on
// either or both VCAA_OUTPUT and VCAA_WRITE causes virtual sample
// coverage to be computed.
//
// QRAST_WRITE    controls what data is written by QRAST to the frame buffer.
// TRANSPARENCY  controls whether or not the transparency optimization is enabled.
// SILHOUETTE    controls whether or not the silhouette edge optimization is enabled.
// VCAA_SURF_PTR is the index of the VCAA surface in the global surface table.

// Register AR3D_QR_VCAA_OPERATION 
#define LIST_REG_FLD_AR3D_QR_VCAA_OPERATION(_) \
_(AR3D_QR,VCAA_OPERATION,QRAST_FB_WRITE) \
_(AR3D_QR,VCAA_OPERATION,TRANSPARENCY) \
_(AR3D_QR,VCAA_OPERATION,SILHOUETTE) \
_(AR3D_QR,VCAA_OPERATION,VCAA_SURF_PTR) \
_(AR3D_QR,VCAA_OPERATION,VCAA_ENABLE) \
_(AR3D_QR,VCAA_OPERATION,VIRTUAL_AS_REAL)
#define REG_AR3D_QR_VCAA_OPERATION(_) _(AR3D_QR,VCAA_OPERATION,0x40e,0xe,1,1,0x3ff,0x0,NOARY,FLD)
// DISABLE: VCAA data NOT sent to frame buffer by QRAST.
// UNMERGE: Output the fragment coverage data to the frame buffer.
// MERGE: Output MERGED fragment and frame buffer VCAA data to frame buffer.
// ONE: Output all 1's for the coverage data for any touched pixel.
#define REG_FLD_AR3D_QR_VCAA_OPERATION_QRAST_FB_WRITE(_) _(AR3D_QR,VCAA_OPERATION,QRAST_FB_WRITE,2,1,0,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_VCAA_OPERATION_QRAST_FB_WRITE(_) \
_(AR3D_QR,VCAA_OPERATION,QRAST_FB_WRITE,DISABLE,0) \
_(AR3D_QR,VCAA_OPERATION,QRAST_FB_WRITE,UNMERGE,1) \
_(AR3D_QR,VCAA_OPERATION,QRAST_FB_WRITE,MERGE,2) \
_(AR3D_QR,VCAA_OPERATION,QRAST_FB_WRITE,ONE,3)
#define AR3D_QR_VCAA_OPERATION_QRAST_FB_WRITE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_QR_VCAA_OPERATION_QRAST_FB_WRITE_UNMERGE                   _MK_ENUM_CONST(1)
#define AR3D_QR_VCAA_OPERATION_QRAST_FB_WRITE_MERGE                     _MK_ENUM_CONST(2)
#define AR3D_QR_VCAA_OPERATION_QRAST_FB_WRITE_ONE                       _MK_ENUM_CONST(3)

// DISABLE: Update VCAA for fully covered and partially covered pixels.
// ENABLE: Update VCAA data for partially covered pixels only.
#define REG_FLD_AR3D_QR_VCAA_OPERATION_TRANSPARENCY(_) _(AR3D_QR,VCAA_OPERATION,TRANSPARENCY,1,2,2,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_VCAA_OPERATION_TRANSPARENCY(_) \
_(AR3D_QR,VCAA_OPERATION,TRANSPARENCY,DISABLE,0) \
_(AR3D_QR,VCAA_OPERATION,TRANSPARENCY,ENABLE,1)
#define AR3D_QR_VCAA_OPERATION_TRANSPARENCY_DISABLE                     _MK_ENUM_CONST(0)
#define AR3D_QR_VCAA_OPERATION_TRANSPARENCY_ENABLE                      _MK_ENUM_CONST(1)

// Use the pixel Z value from the frame buffer for comparison.
// Use the adjacent or pixel Z value from the frame buffer for comparison.
#define REG_FLD_AR3D_QR_VCAA_OPERATION_SILHOUETTE(_) _(AR3D_QR,VCAA_OPERATION,SILHOUETTE,1,3,3,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_VCAA_OPERATION_SILHOUETTE(_) \
_(AR3D_QR,VCAA_OPERATION,SILHOUETTE,DISABLE,0) \
_(AR3D_QR,VCAA_OPERATION,SILHOUETTE,ENABLE,1)
#define AR3D_QR_VCAA_OPERATION_SILHOUETTE_DISABLE                       _MK_ENUM_CONST(0)
#define AR3D_QR_VCAA_OPERATION_SILHOUETTE_ENABLE                        _MK_ENUM_CONST(1)

// Pointer to the VCAA surface in the surface tables.  Note that the only
// allowed value for this field is currently NV_GR3D_V_SURF_PTR.
#define REG_FLD_AR3D_QR_VCAA_OPERATION_VCAA_SURF_PTR(_) _(AR3D_QR,VCAA_OPERATION,VCAA_SURF_PTR,3,6,4,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_VCAA_OPERATION_VCAA_SURF_PTR(_)

// DISABLE: Computed virtual samples are always zero.
// ENABLE: Virtual sample coverage computed from geometry, VCAA surface is read
// COMPUTE_ONLY: Virtual sample coverage computed from geometry, VCAA surface is NOT read.
#define REG_FLD_AR3D_QR_VCAA_OPERATION_VCAA_ENABLE(_) _(AR3D_QR,VCAA_OPERATION,VCAA_ENABLE,2,8,7,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_VCAA_OPERATION_VCAA_ENABLE(_) \
_(AR3D_QR,VCAA_OPERATION,VCAA_ENABLE,DISABLE,0) \
_(AR3D_QR,VCAA_OPERATION,VCAA_ENABLE,ENABLE,1) \
_(AR3D_QR,VCAA_OPERATION,VCAA_ENABLE,COMPUTE_ONLY,2)
#define AR3D_QR_VCAA_OPERATION_VCAA_ENABLE_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_QR_VCAA_OPERATION_VCAA_ENABLE_ENABLE                       _MK_ENUM_CONST(1)
#define AR3D_QR_VCAA_OPERATION_VCAA_ENABLE_COMPUTE_ONLY                 _MK_ENUM_CONST(2)

// DISABLE: Only real samples update depth and stencil buffers.
// ENABLE: Real or virtual coverage causes depth and stencil updates.
#define REG_FLD_AR3D_QR_VCAA_OPERATION_VIRTUAL_AS_REAL(_) _(AR3D_QR,VCAA_OPERATION,VIRTUAL_AS_REAL,1,9,9,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_VCAA_OPERATION_VIRTUAL_AS_REAL(_) \
_(AR3D_QR,VCAA_OPERATION,VIRTUAL_AS_REAL,DISABLE,0) \
_(AR3D_QR,VCAA_OPERATION,VIRTUAL_AS_REAL,ENABLE,1)
#define AR3D_QR_VCAA_OPERATION_VIRTUAL_AS_REAL_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_QR_VCAA_OPERATION_VIRTUAL_AS_REAL_ENABLE                   _MK_ENUM_CONST(1)

// The OUTPUT_TO_SHADER register controls what information is propogate from QRAST to PSEQ.
// This includes VCAA and SCOREBOARD data as well as whether or not any quad at all is sent!

// Register AR3D_QR_OUTPUT_TO_SHADER 
#define LIST_REG_FLD_AR3D_QR_OUTPUT_TO_SHADER(_) \
_(AR3D_QR,OUTPUT_TO_SHADER,VCAA_OUTPUT) \
_(AR3D_QR,OUTPUT_TO_SHADER,SWALLOW_QUADS) \
_(AR3D_QR,OUTPUT_TO_SHADER,PASS_ONLY) \
_(AR3D_QR,OUTPUT_TO_SHADER,SCOREBOARD_OUTPUT) \
_(AR3D_QR,OUTPUT_TO_SHADER,TIMEOUT) \
_(AR3D_QR,OUTPUT_TO_SHADER,PSEQ_FLUSH)
#define REG_AR3D_QR_OUTPUT_TO_SHADER(_) _(AR3D_QR,OUTPUT_TO_SHADER,0x40f,0xf,1,1,0x7ff,0x0,NOARY,FLD)
// VCAA data NOT sent to PSEQ.
// Output MERGE fragement and frame buffer VCAA data to PSEQ.
// Output UNMERGE fragment VCAA data to PSEQ.
// SMEAR the real sample value to the 4 virtual samples in output to PSEQ.
// For STENCIL_COVERAGE, output the Stencil AND Merged Coverage value (bitwise AND)
#define REG_FLD_AR3D_QR_OUTPUT_TO_SHADER_VCAA_OUTPUT(_) _(AR3D_QR,OUTPUT_TO_SHADER,VCAA_OUTPUT,3,2,0,3,0x7,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_OUTPUT_TO_SHADER_VCAA_OUTPUT(_) \
_(AR3D_QR,OUTPUT_TO_SHADER,VCAA_OUTPUT,DISABLE,0) \
_(AR3D_QR,OUTPUT_TO_SHADER,VCAA_OUTPUT,MERGE,1) \
_(AR3D_QR,OUTPUT_TO_SHADER,VCAA_OUTPUT,UNMERGE,2) \
_(AR3D_QR,OUTPUT_TO_SHADER,VCAA_OUTPUT,SMEAR,3) \
_(AR3D_QR,OUTPUT_TO_SHADER,VCAA_OUTPUT,STENCIL_COVERAGE,4)
#define AR3D_QR_OUTPUT_TO_SHADER_VCAA_OUTPUT_DISABLE                    _MK_ENUM_CONST(0)
#define AR3D_QR_OUTPUT_TO_SHADER_VCAA_OUTPUT_MERGE                      _MK_ENUM_CONST(1)
#define AR3D_QR_OUTPUT_TO_SHADER_VCAA_OUTPUT_UNMERGE                    _MK_ENUM_CONST(2)
#define AR3D_QR_OUTPUT_TO_SHADER_VCAA_OUTPUT_SMEAR                      _MK_ENUM_CONST(3)
#define AR3D_QR_OUTPUT_TO_SHADER_VCAA_OUTPUT_STENCIL_COVERAGE                   _MK_ENUM_CONST(4)

// This field controls how coverage data is used to determine which
// pixels are sent to PSEQ.  
// OFF: Qrast sends pixels with real and/or virtual coverage to pseq.  So
// this would be the setting for coverage-to-alpha where pixels with only
// virtual coverage should none-the-less be drawn.
// VIRTUAL: Qrast swallows pixels with only virtual coverage. (reals are send to pseq).
// So this would be a typical non-coverage-to-alpha setting where the shader
// only draws pixels that have real coverage.
// ALL: Qrast sends no pixels to pseq.  This is a depth-only rendering setting
// where the shader draws nothing.
#define REG_FLD_AR3D_QR_OUTPUT_TO_SHADER_SWALLOW_QUADS(_) _(AR3D_QR,OUTPUT_TO_SHADER,SWALLOW_QUADS,2,4,3,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_OUTPUT_TO_SHADER_SWALLOW_QUADS(_) \
_(AR3D_QR,OUTPUT_TO_SHADER,SWALLOW_QUADS,OFF,0) \
_(AR3D_QR,OUTPUT_TO_SHADER,SWALLOW_QUADS,VIRTUAL,1) \
_(AR3D_QR,OUTPUT_TO_SHADER,SWALLOW_QUADS,ALL,2)
#define AR3D_QR_OUTPUT_TO_SHADER_SWALLOW_QUADS_OFF                      _MK_ENUM_CONST(0)
#define AR3D_QR_OUTPUT_TO_SHADER_SWALLOW_QUADS_VIRTUAL                  _MK_ENUM_CONST(1)
#define AR3D_QR_OUTPUT_TO_SHADER_SWALLOW_QUADS_ALL                      _MK_ENUM_CONST(2)

// This field controls how the state of pixel tests modifies which pixels
// are sent to PSEQ.  In particular, this field exists to support late vs
// early pixel testing.  When early Z/Stencil/VCAA is used, PASS_ONLY should
// be ENABLE.  When late Stencil/VCAA is used, PASS_ONLY should be DISABLE.
//
// ENABLE:  Only pixels who's real sample PASS the stencil test and depth test are
// sent to PSEQ.  This setting is used in conjunction with early Z/S/VCAA surfaces.
// It prevents pixels which fail stencil, for example, from being passed to the shader.
//
// DISABLE: All covered pixels which are not swallowed are sent to PSEQ, 
// even if they fail the depth or stencil tests.  This is the setting for late stencil
// where the pixel shader must perform the stencil op for any pixel covered by a fragment
// even if it fails depth test or stencil test. This is also the setting for late vcaa where
// DWR could be updating the vcaa surface even when pixels fail depth test.
#define REG_FLD_AR3D_QR_OUTPUT_TO_SHADER_PASS_ONLY(_) _(AR3D_QR,OUTPUT_TO_SHADER,PASS_ONLY,1,5,5,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_OUTPUT_TO_SHADER_PASS_ONLY(_) \
_(AR3D_QR,OUTPUT_TO_SHADER,PASS_ONLY,ENABLE,0) \
_(AR3D_QR,OUTPUT_TO_SHADER,PASS_ONLY,DISABLE,1)
#define AR3D_QR_OUTPUT_TO_SHADER_PASS_ONLY_ENABLE                       _MK_ENUM_CONST(0)
#define AR3D_QR_OUTPUT_TO_SHADER_PASS_ONLY_DISABLE                      _MK_ENUM_CONST(1)

// DISABLE: QRAST clears the scoreboard bit as pixels complete Z/S/VCAA processing.
// This causes pixels that are only doing c-writes in shader to go faster.
// ENABLED: PSEQ clears the scoreboard bit when pixels are retired from the shader.
#define REG_FLD_AR3D_QR_OUTPUT_TO_SHADER_SCOREBOARD_OUTPUT(_) _(AR3D_QR,OUTPUT_TO_SHADER,SCOREBOARD_OUTPUT,1,6,6,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_OUTPUT_TO_SHADER_SCOREBOARD_OUTPUT(_) \
_(AR3D_QR,OUTPUT_TO_SHADER,SCOREBOARD_OUTPUT,DISABLE,0) \
_(AR3D_QR,OUTPUT_TO_SHADER,SCOREBOARD_OUTPUT,ENABLE,1)
#define AR3D_QR_OUTPUT_TO_SHADER_SCOREBOARD_OUTPUT_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_QR_OUTPUT_TO_SHADER_SCOREBOARD_OUTPUT_ENABLE                       _MK_ENUM_CONST(1)

// 0: disabled.  The delta checker never times out.
// 1..7: enabled.  The delta checker times out in N * 64 clocks of no new quads.
// This behavior is not modelled by the CSIM.
#define REG_FLD_AR3D_QR_OUTPUT_TO_SHADER_TIMEOUT(_) _(AR3D_QR,OUTPUT_TO_SHADER,TIMEOUT,3,9,7,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_OUTPUT_TO_SHADER_TIMEOUT(_)

// PSEQ waits until it has enough work to do before recirculating.  When
// this field is DETERMINISTIC, qrast sends out a PSEQ flush when it detects that
// it has no more work to send pseq, yet pseq is waiting for more work before recirculating.
// This can be inefficient, but it is deterministic.  PERFORMANCE is not
// deterministic, but is efficient.  It sends a flush whenever the serializer
// fifo goes empty, which depends on timing and hence is not deterministic.
#define REG_FLD_AR3D_QR_OUTPUT_TO_SHADER_PSEQ_FLUSH(_) _(AR3D_QR,OUTPUT_TO_SHADER,PSEQ_FLUSH,1,10,10,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_QR_OUTPUT_TO_SHADER_PSEQ_FLUSH(_) \
_(AR3D_QR,OUTPUT_TO_SHADER,PSEQ_FLUSH,PERFORMANCE,0) \
_(AR3D_QR,OUTPUT_TO_SHADER,PSEQ_FLUSH,DETERMINISTIC,1)
#define AR3D_QR_OUTPUT_TO_SHADER_PSEQ_FLUSH_PERFORMANCE                 _MK_ENUM_CONST(0)
#define AR3D_QR_OUTPUT_TO_SHADER_PSEQ_FLUSH_DETERMINISTIC                       _MK_ENUM_CONST(1)

// The QRAST_DEBUG is available for future use.

// Register AR3D_QR_QRAST_DEBUG 
#define LIST_REG_FLD_AR3D_QR_QRAST_DEBUG(_) \
_(AR3D_QR,QRAST_DEBUG,VALUE)
#define REG_AR3D_QR_QRAST_DEBUG(_) _(AR3D_QR,QRAST_DEBUG,0x410,0x10,1,1,0xffffffff,0x0,NOARY,FLD)
// To be defined.
#define REG_FLD_AR3D_QR_QRAST_DEBUG_VALUE(_) _(AR3D_QR,QRAST_DEBUG,VALUE,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_DEBUG_VALUE(_)


// Register AR3D_QR_QRAST_LIMITS 
#define LIST_REG_FLD_AR3D_QR_QRAST_LIMITS(_) \
_(AR3D_QR,QRAST_LIMITS,PIX_CNT_QRAST) \
_(AR3D_QR,QRAST_LIMITS,PIX_CNT_SHD)
#define REG_AR3D_QR_QRAST_LIMITS(_) _(AR3D_QR,QRAST_LIMITS,0x411,0x11,1,1,0x7fffff,0x0,NOARY,FLD)
// As a CYA, Qrast can limit the number of pixels in flight in qrast 
// by setting this value.  Default is disabled (0).
#define REG_FLD_AR3D_QR_QRAST_LIMITS_PIX_CNT_QRAST(_) _(AR3D_QR,QRAST_LIMITS,PIX_CNT_QRAST,12,11,0,3,0xfff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_LIMITS_PIX_CNT_QRAST(_)

// As a CYA, Qrast can limit the number of pixels in flight after scoreboard
// by setting this value.  Default is disabled (0).
#define REG_FLD_AR3D_QR_QRAST_LIMITS_PIX_CNT_SHD(_) _(AR3D_QR,QRAST_LIMITS,PIX_CNT_SHD,11,22,12,3,0x7ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_QR_QRAST_LIMITS_PIX_CNT_SHD(_)

/////////////////////////////////////////////////////////////////////////////////
// Snooped global registers:
//
// S_OPERATION[2]
// SURFDESC -- Contains the Z surface descriptor.
//             Contains the S surface descriptor
//             Contains the C surface descriptor.
// SURADDR -- Contains the surface address.
/////////////////////////////////////////////////////////////////////////////////
//These packets are RTL specific
//XXX: Could not find a define for number of samples
//XXX: If there is one, replace the 10 in the last column with that

// Packet ROW_RAM
#define LIST_PKT_FLD_ROW_RAM(_) \
_(ROW_RAM,SMP0_IN) \
_(ROW_RAM,SMP1_IN) \
_(ROW_RAM,SMP2_IN) \
_(ROW_RAM,SMP3_IN) \
_(ROW_RAM,SMP4_IN) \
_(ROW_RAM,SMP5_IN) \
_(ROW_RAM,SMP6_IN) \
_(ROW_RAM,SMP7_IN) \
_(ROW_RAM,SMP8_IN) \
_(ROW_RAM,SMP9_IN) \
_(ROW_RAM,SMP0_OUT) \
_(ROW_RAM,SMP1_OUT) \
_(ROW_RAM,SMP2_OUT) \
_(ROW_RAM,SMP3_OUT) \
_(ROW_RAM,SMP4_OUT) \
_(ROW_RAM,SMP5_OUT) \
_(ROW_RAM,SMP6_OUT) \
_(ROW_RAM,SMP7_OUT) \
_(ROW_RAM,SMP8_OUT) \
_(ROW_RAM,SMP9_OUT) \
_(ROW_RAM,SMP_COVERED)
#define PKT_ROW_RAM(_) _(ROW_RAM,251,FLD)
#define PKT_FLD_ROW_RAM_SMP0_IN(_) _(ROW_RAM,SMP0_IN,0,12,11,0,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP0_IN(_)
#define PKT_FLD_ROW_RAM_SMP1_IN(_) _(ROW_RAM,SMP1_IN,0,12,23,12,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP1_IN(_)
#define PKT_FLD_ROW_RAM_SMP2_IN(_) _(ROW_RAM,SMP2_IN,0,12,35,24,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP2_IN(_)
#define PKT_FLD_ROW_RAM_SMP3_IN(_) _(ROW_RAM,SMP3_IN,0,12,47,36,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP3_IN(_)
#define PKT_FLD_ROW_RAM_SMP4_IN(_) _(ROW_RAM,SMP4_IN,0,12,59,48,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP4_IN(_)
#define PKT_FLD_ROW_RAM_SMP5_IN(_) _(ROW_RAM,SMP5_IN,0,12,71,60,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP5_IN(_)
#define PKT_FLD_ROW_RAM_SMP6_IN(_) _(ROW_RAM,SMP6_IN,0,12,83,72,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP6_IN(_)
#define PKT_FLD_ROW_RAM_SMP7_IN(_) _(ROW_RAM,SMP7_IN,0,12,95,84,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP7_IN(_)
#define PKT_FLD_ROW_RAM_SMP8_IN(_) _(ROW_RAM,SMP8_IN,0,12,107,96,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP8_IN(_)
#define PKT_FLD_ROW_RAM_SMP9_IN(_) _(ROW_RAM,SMP9_IN,0,12,119,108,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP9_IN(_)
#define PKT_FLD_ROW_RAM_SMP0_OUT(_) _(ROW_RAM,SMP0_OUT,0,12,131,120,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP0_OUT(_)
#define PKT_FLD_ROW_RAM_SMP1_OUT(_) _(ROW_RAM,SMP1_OUT,0,12,143,132,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP1_OUT(_)
#define PKT_FLD_ROW_RAM_SMP2_OUT(_) _(ROW_RAM,SMP2_OUT,0,12,155,144,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP2_OUT(_)
#define PKT_FLD_ROW_RAM_SMP3_OUT(_) _(ROW_RAM,SMP3_OUT,0,12,167,156,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP3_OUT(_)
#define PKT_FLD_ROW_RAM_SMP4_OUT(_) _(ROW_RAM,SMP4_OUT,0,12,179,168,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP4_OUT(_)
#define PKT_FLD_ROW_RAM_SMP5_OUT(_) _(ROW_RAM,SMP5_OUT,0,12,191,180,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP5_OUT(_)
#define PKT_FLD_ROW_RAM_SMP6_OUT(_) _(ROW_RAM,SMP6_OUT,0,12,203,192,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP6_OUT(_)
#define PKT_FLD_ROW_RAM_SMP7_OUT(_) _(ROW_RAM,SMP7_OUT,0,12,215,204,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP7_OUT(_)
#define PKT_FLD_ROW_RAM_SMP8_OUT(_) _(ROW_RAM,SMP8_OUT,0,12,227,216,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP8_OUT(_)
#define PKT_FLD_ROW_RAM_SMP9_OUT(_) _(ROW_RAM,SMP9_OUT,0,12,239,228,0xfff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP9_OUT(_)
#define PKT_FLD_ROW_RAM_SMP_COVERED(_) _(ROW_RAM,SMP_COVERED,0,11,250,240,0x7ff,NOENM)
#define LIST_PKT_ENM_ROW_RAM_SMP_COVERED(_)
// --------------------------------------------------------------------------
// 
// Copyright (c) 2005, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// ar3d_pseq.spec
//
//
// OVERVIEW:
// -------------------------------------
// PSEQ (Program Sequencer) controls the recirculation of pixels
// through the pixel pipeline.  PSEQ also performs unfiltered data reads,
// to fetch framebuffer data, instruction data, or spilled pixel data.
// PSEQ notifies the gatekeeper in QRAST when quads are removed from the
// recirculation loop.
// 
// GLOBAL REGISTERS:
// -------------------------------------
// PSEQ keeps a copy of the following global registers (see
// ar3d.spec for a description of global registers):
// * PIX_ATTR - first_sequence, num_rows, max_qid
// * RAISE - raise signal to send back to host module
// * INSTRUMENT - performance monitoring (mainly for stat gathering)
// * SURFDESC - description of the different surfaces PSEQ can read.
// * SURFADDR - base adddress of the surfaces PSEQ can read.
// * SPILLSURFADDR - base address for the pixel spill surface
// * DITHER_TABLE - to undither framebuffer color loads
//
// NOTES AND RESTRICTIONS: (Please especially note numbers 4 and 5)
// ---------------------------------------------
// 1. PSEQ will not recirculate register accesses.  Only SPANSTART
//    packets and pixel data will be recirculated.
// 
// 2. PSEQ has two local register regions.  One at the top of the
//    recirculation loop, and another at the bottom of the
//    recirculation loop.  Registers local to PSEQ_UPPER are not sent
//    on to the rest of the pixel pipeline.  Registers local to
//    PSEQ_LOWER are sent to the rest of the pixel pipeline, and are
//    removed when they arrive from the DWR interface.  This feature is
//    useful for registers that need to be updated at the end of the
//    pixel pipeline.  Registers that update the top of the pixel
//    pipeline like the FLUSH register do not enter the pipeline, but
//    will be discarded after flushing the pipeline.
// 
// 3. PSEQ is the only module in the pipeline that will discard pixel
//    data.  All pixel data will eventually return to the PSEQ from
//    the DWR through a feedback interface.  PSEQ keeps track of how
//    many times the pixel data has gone through the pipeline and
//    whether or not it needs to be retired.
//
// 4. The global PIX_ATTR register must be programmed correctly
//    before any pixel is sent down the pipeline.  
//
// 5. PSEQ has a command table and program counter to control the flow
//    of program fetch and execution.  This functionality allows
//    shaders larger than the modules' instruction tables.  It also
//    allows multiple shaders to be linked together without knowing
//    about each other.  Further detail is in the COMMAND section
//
// 6. The unfiltered data reads are controlled using pseq's instruction
//    table.  Further detail is in the INST_DATA section
//
// LOCAL REGISTERS:
// --------------------------------------

// Register AR3D_PSEQ_FLUSH 
#define LIST_REG_FLD_AR3D_PSEQ_FLUSH(_) \
_(AR3D_PSEQ,FLUSH,FLUSH)
#define REG_AR3D_PSEQ_FLUSH(_) _(AR3D_PSEQ,FLUSH,0x500,0x0,1,1,0x1,0x0,NOARY,FLD)
// Trigger recirculation
// This does not flush any of the
// caches in TEX or DWR.  Also, because it's a local
// register write, PSEQ will discard it after
// flushing the pipeline, and it will not be seen
// by the lower modules (ATRAST, TEX, ALU, DWR).
// This register is safe to write to at any time.
// The value of the FLUSH field is irrelevant; it may
// be 0 or 1 and the FLUSH still occurs.
// Any register write will do the same, but this is
// a dummy pseq local register for the times we
// don't have another register we want to write.
// 
// FLUSH also has the side affect of restarting
// a stopped command unit.  This register
// should be in the gather dma stream after the
// last pseq register.  The sooner after the better.
// See GATHER.STOP for more detail
#define REG_FLD_AR3D_PSEQ_FLUSH_FLUSH(_) _(AR3D_PSEQ,FLUSH,FLUSH,1,0,0,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_FLUSH_FLUSH(_)

// CTL:  pseq control register
// Note: 
//   The largest legal value for CTL.MAX_OUT is 1006 (1023-17)
//   Normally a value this large would hang the fragment pipe.
//   There is an exception when all the executes in the
//   command table are single pass and have STOP, DONE, 
//   or SPILL destinations.
//   There is no benefit to setting a value this large except
//   for testing
//
//   This register doesn't get sunk in pseq until the bottom of the fragment
//   pipe so pseq.dwr_if can see it.

// Register AR3D_PSEQ_CTL 
#define LIST_REG_FLD_AR3D_PSEQ_CTL(_) \
_(AR3D_PSEQ,CTL,MERGE_SPAN_STARTS) \
_(AR3D_PSEQ,CTL,MERGE_REGISTERS) \
_(AR3D_PSEQ,CTL,REMOVE_KILLED_PIXELS) \
_(AR3D_PSEQ,CTL,ALLOW_QID_COLLISIONS) \
_(AR3D_PSEQ,CTL,MAX_OUT) \
_(AR3D_PSEQ,CTL,MIN_OUT)
#define REG_AR3D_PSEQ_CTL(_) _(AR3D_PSEQ,CTL,0x501,0x1,1,1,0xffffff,0x0,NOARY,FLD)
//cya bit, turns on redundant spanstart
// merging (P1 feature)
#define REG_FLD_AR3D_PSEQ_CTL_MERGE_SPAN_STARTS(_) _(AR3D_PSEQ,CTL,MERGE_SPAN_STARTS,1,0,0,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_CTL_MERGE_SPAN_STARTS(_)

//cya bit, turns on consecutive register
// merging (P1 feature)
#define REG_FLD_AR3D_PSEQ_CTL_MERGE_REGISTERS(_) _(AR3D_PSEQ,CTL,MERGE_REGISTERS,1,1,1,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_CTL_MERGE_REGISTERS(_)

// Remove killed pixel from loop
// and replace with a spanstart. 
#define REG_FLD_AR3D_PSEQ_CTL_REMOVE_KILLED_PIXELS(_) _(AR3D_PSEQ,CTL,REMOVE_KILLED_PIXELS,1,2,2,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_CTL_REMOVE_KILLED_PIXELS(_)

// Hint to allow more than one quad
// with the same QID into the pseq fragment loop.
// This can be turned on when there is no 
// ST/LD_R20 or ST/LD_R80 ops in the fragment program. 
#define REG_FLD_AR3D_PSEQ_CTL_ALLOW_QID_COLLISIONS(_) _(AR3D_PSEQ,CTL,ALLOW_QID_COLLISIONS,1,3,3,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_CTL_ALLOW_QID_COLLISIONS(_)

// This is a high watermark that PSEQ will fill the
// pipeline to before recirculating the pixels
//  
// - When this register is set to 0, pseq goes into
// passthrough mode.  Passthrough mode ignores the 
// command table.  Pixels are processed in a single
// pass where the AR3D_GLOBAL_PIX_ATTR register provides
// the sequence start value for those pixels
// - Otherwise, this register should be set to the
// maximum number of entries in the pipeline less 16
// (largest atomic packet) for optimum performance.
// Setting this register to a higher value will hang
// the pipeline if pixels are recirculating
// The optimum recirculation value for MG20 is TBD
// (although 320 (0x140) has been used by h/w a lot,
// and 300 (0x12c) should be considered "safe")
#define REG_FLD_AR3D_PSEQ_CTL_MAX_OUT(_) _(AR3D_PSEQ,CTL,MAX_OUT,10,13,4,3,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_CTL_MAX_OUT(_)

// This is a low watermark that PSEQ will allow
// the pipeline to drain to before switching back
// out of recirculation mode.
//  
// - When recirculating pixels, this register 
// should be set to a value between 0 and MAX_OUT
// Setting this register closer to 0 will allow
// the pipeline to get more empty before filling
// again.  Setting a value closer to MAX_OUT will
// cause the pipeline to get more fragmented,
// which may effect cache efficiency.  
//
// Also, this register must be set to 0 for the following
// cases:
// * Single pass shaders.  This is because min_out is
//   only relevant in multipass pixel execution
// * EXECUTE commands without STOP.  For example this command
//   program would need to set MIN_OUT to 0:
//     0 GATHER          0x0,    3
//     1 GATHER.P        0x1000, 500
//     2 GATHER          0x4,    3
//     3 GATHER.P        0x2000, 120
//     4 EXECUTE.RECIRC  0,      24 
//     5 EXECUTE.DONE    30,     4
//     6 BRANCH          ALWAYS, -2
//   while this command program could set MIN_OUT to some
//   value greater than 0:
//     0 GATHER.P        0x100,  500
//     1 EXECUTE.STOP    0,      24
//
// The optimum recirculation value for MG20 is TBD
#define REG_FLD_AR3D_PSEQ_CTL_MIN_OUT(_) _(AR3D_PSEQ,CTL,MIN_OUT,10,23,14,3,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_CTL_MIN_OUT(_)

// This register is in place, in case we want to do something if a
// shader runs for too long.  There are no current plans to do
// anything.  If we do anything it should be useful to software, and
// not to hard to implement.  Nothing proposed so far meets these goals.

// Register AR3D_PSEQ_TIMEOUT 
#define LIST_REG_FLD_AR3D_PSEQ_TIMEOUT(_) \
_(AR3D_PSEQ,TIMEOUT,COUNT)
#define REG_AR3D_PSEQ_TIMEOUT(_) _(AR3D_PSEQ,TIMEOUT,0x502,0x2,1,1,0xffffffff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_PSEQ_TIMEOUT_COUNT(_) _(AR3D_PSEQ,TIMEOUT,COUNT,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_TIMEOUT_COUNT(_)

// Indexes COMMAND. After each command executes the PC is incremented.
// PC will wrap at the end of the COMMAND table. For example a PC value
// of NV_GR3D_NUM_PSEQ_COMMANDS is the same as a PC value of 0.

// Register AR3D_PSEQ_PC 
#define LIST_REG_FLD_AR3D_PSEQ_PC(_) \
_(AR3D_PSEQ,PC,PC)
#define REG_AR3D_PSEQ_PC(_) _(AR3D_PSEQ,PC,0x503,0x3,1,1,0xf,0x0,NOARY,FLD)
#define REG_FLD_AR3D_PSEQ_PC_PC(_) _(AR3D_PSEQ,PC,PC,4,3,0,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_PC_PC(_)

// COMMAND contains 16 64 bit commands for pseq to execute.  PC
// indexes this table.  Longer command programs can be reload the
// table using GATHER.P
// 
// opcodes:
//
// GATHER   Gather data from memory and send down the fragment pipe as
//          register writes.  The register address can come from the data
//          read from memory, or can come from a field in this command.
//          The data read back is a dma stream defined by 
//          host1x.spec.  Supported DMA opcodes are INCR and NONINCR.
//
// EXECUTE  Execute a sequence of pixels.
//
// BRANCH   Update the PC to a new location.  
//          conditional branches are a P1 addition.
//          
//
// IMM      P1 feature to insert immediate register writes
//          (this feature has been partially tested by h/w, so s/w may be
//          interested in trying it out)
//
// ST       P1 feature to insert register reads for dw to store to memory
//
//
// Gather fields:
//      OPCODE:     set to GATHER
//      STOP:       Stop all pseq fragment processing while the
//                  gather is running.  A PC or FLUSH register
//                  write within the gather'ed stream will start
//                  pseq up again.
//
//                  This is used to synchronize the pseq with the
//                  registers returned from GATHER.
//
//                  If pseq does not see either of these register writes,
//                  it will wait until the last of the gather data returns
//                  from memory to start executing commands again.
//
//                  A dma stream that includes a PSEQ_COMMAND or PSEQ_PC
//                  register must always be gathered using the GATHER.STOP
//                  command.
//
//                  A dma stream that includes a register in the 3D global
//                  address space (like GLOBAL_INST_OFFSET) or a register
//                  in the PSEQ local address space (like PSEQ_INST_DATA)
//                  must use the STOP bit in the GATHER command that gathers
//                  the dma stream in question or in a following GATHER
//                  command but before an EXECUTE command.
//
//                  GATHER STOP Decision tree.
//                    if (dma stream has a PSEQ_COMMAND register or
//                        PSEQ_PC register or
//                        PSEQ_FLUSH register)
//                      GATHER STOP must be 1
//                    else if (dma stream has global or pseq local register)
//                      if (is last gather with global or pseq local registers before an execute command)
//                        GATHER STOP must be 1
//                      else
//                        GATHER STOP should be 0
//                    else
//                      GATHER STOP should be 0
//
//                  A GATHER.STOP can introduce memory latency based delays,
//                  so the chip can perform better when they are only used when
//                  required.
//
//                  legal, well performing examples  (the registers in the dma
//                  stream are listed after the GATHER)
//                    0 GATHER GLOBAL_INST_OFFSET
//                    1 GATHER.STOP PSEQ_INST_DATA + FLUSH
//                    2 EXECUTE
//
//                    0 GATHER GLOBAL_INST_OFFSET
//                    1 GATHER.STOP TEX_INST_DATA + FLUSH
//                    2 EXECUTE
//
//                    0 GATHER.STOP GLOBAL_INST_OFFSET + PSEQ_INST_DATA + FLUSH
//                    1 EXECUTE
//      OFFSET:     (P1 feature) Set to 0
//      INSERT:     (P1 feature) Set to DISABLE
//      TYPE:       (P1 feature) Set to NONINCR
//      COUNT:      Count of 32-bit words to be gathered from memory
//      ADDRESS     Base address of data to be gathered from memory
//                  must be 32-bit aligned
//
// Execute fields:
//      OPCODE:     set to EXECUTE
//      DEST:       destination for pixels at after all sequences
//                  complete.  Also indicates the source for the next
//                  EXECUTE opcode:
//                      RECIRC -- DWR
//                      SPILL  -- FDC
//                      DONE   -- QZ
//                      STOP   -- QZ  (also implies BRANCH 0)
//                  STOP dest will prevent the PC from incrementing.
//                  This can be used for single epoch shaders to
//                  prevent pseq from reloading redundant commands.
//                  STOP is preferred over DONE when a command program
//                  has only a single EXECUTE.  This is because
//                  EXECUTE.STOP is equivalent to an EXECUTE.DONE
//                  followed by a BRANCH ALWAYS -1, but it executes
//                  faster.
//      START:      start sequence number (which sequence number is
//                  the pixels initialized to for the first pass)
//                  this is the start value for row 0 pixel packets
//                  other rows will increment the seq value.
//      COUNT:      total number of sequence numbers executed.  This
//                  number has to be an exact multiple of the number of
//                  rows.  (numRows * numPasses)
// Branch fields:
//      OPCODE:     set to BRANCH
//      COND:       condition -- set to ALWAYS 
//                        (other conditions are P1)
//      DEST:       signed offset from current PC (PC will have the
//                  offset added to it's current value instead of +1)
//
// EXAMPLE COMMAND SEQUENCES
//
// Format
// <pc> <opcode> <args>
//
// EXECUTE.S == execute.spill
// EXECUTE.P == execute.stop
// EXECUTE.D == execute.done
// EXECUTE.R == execute.recirc
//
// GATHER.P == gather.stop
//
//
// simple passthrough (single pass) shader
// 0 EXECUTE.P  0,  4
//
// simple single epoch shader
// 0 EXECUTE.P  0,  24
//
// fetch the instructions and execute (single epoch)
// 0 GATHER.P   0x100,  500
// 1 EXECUTE.P  0,      24
//
// When using a single execute command program, execute.stop is preferred over 
// execute.done.  A execute.done program will use more power and will run slower
// than a execute.stop program. For this reason we are not providing a single 
// execute, execute.done example.
//
// fetch the instructions and execute shader and postscript
// 0 GATHER     0x0,    3   // gather main relocation info
// 1 GATHER.P   0x1000, 500 // gather main shader
// 2 GATHER     0x4,    3   // gather postscript relocation info
// 3 GATHER.P   0x2000, 120 // gather postscript
// 4 EXECUTE.R  0,      24  // execute main shader   
// 5 EXECUTE.D  30,     4   // execute postscript and finish   
// 6 BRANCH     ALWAYS, -2  // branch back to 4 (don't need to reload)
//
//
// fetch the instructions/uniforms, and execute shaders. (2 epochs)
// 0 GATHER     0x0,    3   // gather main relocation info
// 1 GATHER.P   0x1000, 500 // gather main shader
// 2 EXECUTE.S  0,      60  // execute main shader and spill   
// 3 GATHER.P   0x1000, 500 // gather main shader
// 4 GATHER     0x4,    3   // gather postscript relocation info
// 5 GATHER.P   0x2000, 120 // gather postscript
// 6 EXECUTE.D  0,      40  // execute main and postscript shaders
// 7 BRANCH     ALWAYS, -7  // branch back to 0
//
//
//
// fetch the instructions, and execute shaders. (2 epochs)
// 0 GATHER.P   0x1000, 500 // gather main shader
// 1 EXECUTE.S  0,      60  // execute main shader and spill   
// 2 GATHER     0x1000, 500 // gather main shader
// 3 GATHER     0x4,    3   // gather postscript relocation info
// 4 GATHER.P   0x2000, 120 // gather postscript
// 5 EXECUTE.D  0,      40  // execute main and postscript
//                          // shaders
// 6 BRANCH     ALWAYS, -6  // branch back to 0
//
//
// command program longer than the command table.  This example 
// includes command table gathers 
//   command_table_0
//     0  GATHER    0x100,  3   // prologue relocation info
//     1  GATHER.P  0x1000, 500 // gather prologue shader
//     2  GATHER    0x103,  3   // main relocation info
//     3  GATHER.P  0x2000, 500 // gather main shader (epoch 1)
//     4  EXECUTE.R 0,      8   // execute prologue
//     5  EXECUTE.S 8,      62  // execute main (epoch 1) 
//     6  GATHER    0x100,  3   // main relocation info
//     7  GATHER.P  0x3000, 500 // gather main shader (epoch 2)
//     8  EXECUTE.S 0,      64  // execute main (epoch 2) 
//     9  GATHER    0x100,  3   // main relocation info
//     10 GATHER.P  0x4000, 500 // gather main shader (epoch 3)
//     11 EXECUTE.S 0,      64  // execute main (epoch 3) 
//     12 GATHER    0x100,  3   // main relocation info
//     13 GATHER.P  0x5000, 500 // gather main shader (epoch 4)
//     14 EXECUTE.S 0,      64  // execute main (epoch 4) 
//     15 GATHER.P  0x34,   34  //gather command_table_1 + pc
//     
//   command_table_1
//     0  GATHER    0x100,  3   // main relocation info
//     1  GATHER.P  0x6000, 500 // gather main shader (epoch 5)
//     2  EXECUTE.S 0,      64  // execute main (epoch 5)
//     3  GATHER.P  0x7000, 500 // gather main shader (epoch 6)
//     4  EXECUTE.D 0,      24  // execute main (epoch 5)
//     5  GATHER.P  0x0,    34  // gather command_table_0 + pc
//
//
// multiple uniform updates and command table update 
//  this example uses p1 gather features (the INCR stuff)
//  also this example requires extra space in pipeline for
//  gathers without spills (so MAX_OUT will have to be reduced)
//
// 0  GATHER.P  0x1000, 500 // gather prologue shader
// 1  GATHER    0x100,  3   // main relocation info
// 2  GATHER.P  0x2000, 500 // gather main shader (epoch 1)
// 3  EXECUTE.R 0,      8   // execute prologue
//
// gather uniforms (register address insertion P1)
// 4  GATHER    0x10024,4,  AR3D_ALU_GLOBALS[12],   INCR 
// 5  GATHER    0x10012,4,  AR3D_ALU_GLOBALS[0],    INCR 
//
// 6  EXECUTE.S 8,      62  //execute main
// 7  GATHER    0x103,  3   //main relocation info
// 8  GATHER.P  0x3000, 500 //gather main shader (epoch 2)
//
// gather uniforms (register address insertion P1)
// 9  GATHER    0x10000,4,  AR3D_ALU_GLOBALS[0],    INCR 
// 10 GATHER    0x10048,4,  AR3D_ALU_GLOBALS[4],    INCR 
// 11 GATHER    0x10012,4,  AR3D_ALU_GLOBALS[8],    INCR 
// 12 GATHER    0x1008, 4,  AR3D_ALU_GLOBALS[12],   INCR 
// 13 GATHER    0x10020,4,  AR3D_ALU_GLOBALS[16],   INCR 
// 14 GATHER    0x10024,4,  AR3D_ALU_GLOBALS[20],   INCR 
//
// 15 GATHER.P  0x34,   34  //gather command table + pc
//
//
// second pass
// gather uniforms (register address insertion P1)
// 0  GATHER    0x10024,4,  AR3D_ALU_GLOBALS[20],INCR 
//
// 1  EXECUTE.S 8,      62  //execute main
// 2  GATHER.P  0x4000, 500 //gather main shader (epoch 3)
//
// gather uniforms (register address insertion P1)
// 3  GATHER    0x10020,4,  AR3D_ALU_GLOBALS[0],    INCR 
// 4  GATHER    0x10032,4,  AR3D_ALU_GLOBALS[4],    INCR   
// 5  GATHER    0x10120,4,  AR3D_ALU_GLOBALS[8],    INCR   
// 6  GATHER    0x10000,4,  AR3D_ALU_GLOBALS[12],   INCR   
// 7  GATHER    0x10024,4,  AR3D_ALU_GLOBALS[16],   INCR   
// 8  GATHER    0x10004,8,  AR3D_ALU_GLOBALS[20],   INCR   
//
// 9  GATHER.P  0x5000, 120 // gather postscript
// 10 EXECUTE.D 0,      40  // execute main and postscript
//                          // shaders (stitched together)
// 11 GATHER.P  0x0,    34  // gather command table + pc
//
//
//
// HANG EXAMPLES, DO NOT EMULATE
//
// too many inserted packets without spill (max_out has to 
// be programmed to allow register writes and pixels to 
// coexist.)
// 0 EXECUTE.R  0,      8
// 1 GATHER     0x1000, 900
// 2 BRANCH     ALWAYS, -2
//
//
// branch to self
// 0 EXECUTE.D  0,      8
// 1 BRANCH     ALWAYS, 0
//
//
// loop without finish
// 0 EXECUTE.R  0,      8
// 1 BRANCH     ALWAYS, -1
//
//
// update command program without GATHER.P
// 0 GATHER      0x2000, 500 // gather main shader (epoch 1)
// 1 EXECUTE.S   0,      8   // execute main shader
// 2 GATHER      0x34,   34  // gather command table + pc
// 3 BRANCH      ALWAYS, -3  // will start executing 0, 1 
//                           // before command table is 
//                           // updated undefined behavior 
//                           // -- potential hang
//
// END HANG EXAMPLES, DO NOT EMULATE
//
//
// Register/Packet Defs for COMMAND

// Register AR3D_PSEQ_COMMAND 
#define LIST_REG_FLD_AR3D_PSEQ_COMMAND(_) \
_(AR3D_PSEQ,COMMAND,DATA)
#define REG_AR3D_PSEQ_COMMAND(_) _(AR3D_PSEQ,COMMAND,0x520,0x20,32,1,0xffffffff,0x0,ARY,FLD)
#define REG_FLD_AR3D_PSEQ_COMMAND_DATA(_) _(AR3D_PSEQ,COMMAND,DATA,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_COMMAND_DATA(_)

//Generic packet type for COMMAND TABLE

// Packet AR3D_PSEQ_CMD
#define LIST_PKT_FLD_AR3D_PSEQ_CMD(_) \
_(AR3D_PSEQ_CMD,OPCODE) \
_(AR3D_PSEQ_CMD,ARGS0) \
_(AR3D_PSEQ_CMD,ARGS1)
#define PKT_AR3D_PSEQ_CMD(_) _(AR3D_PSEQ_CMD,32,FLD)
#define PKT_FLD_AR3D_PSEQ_CMD_OPCODE(_) _(AR3D_PSEQ_CMD,OPCODE,0,3,31,29,0x7,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_CMD_OPCODE(_) \
_(AR3D_PSEQ_CMD,OPCODE,GATHER,0) \
_(AR3D_PSEQ_CMD,OPCODE,EXECUTE,1) \
_(AR3D_PSEQ_CMD,OPCODE,BRANCH,2) \
_(AR3D_PSEQ_CMD,OPCODE,IMM,3) \
_(AR3D_PSEQ_CMD,OPCODE,ST,4)
#define PKT_FLD_AR3D_PSEQ_CMD_ARGS0(_) _(AR3D_PSEQ_CMD,ARGS0,0,29,28,0,0x1fffffff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_CMD_ARGS0(_)
#define PKT_FLD_AR3D_PSEQ_CMD_ARGS1(_) _(AR3D_PSEQ_CMD,ARGS1,1,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_CMD_ARGS1(_)

// Packet AR3D_PSEQ_GATHER
#define LIST_PKT_FLD_AR3D_PSEQ_GATHER(_) \
_(AR3D_PSEQ_GATHER,OPCODE) \
_(AR3D_PSEQ_GATHER,STOP) \
_(AR3D_PSEQ_GATHER,OFFSET) \
_(AR3D_PSEQ_GATHER,INSERT) \
_(AR3D_PSEQ_GATHER,TYPE) \
_(AR3D_PSEQ_GATHER,CACHE_PERSISTENT) \
_(AR3D_PSEQ_GATHER,COUNT) \
_(AR3D_PSEQ_GATHER,ADDRESS)
#define PKT_AR3D_PSEQ_GATHER(_) _(AR3D_PSEQ_GATHER,32,FLD)
// Register Gather
#define PKT_FLD_AR3D_PSEQ_GATHER_OPCODE(_) _(AR3D_PSEQ_GATHER,OPCODE,0,3,31,29,0x7,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_GATHER_OPCODE(_) \
_(AR3D_PSEQ_GATHER,OPCODE,GATHER,0)
// Stop all pseq fragment processing while the
// gather is running.  A PC or FLUSH register
// write within the gather'ed stream will start
// pseq up again.
//
// This is used to synchronize the pseq with the
// registers returned from GATHER.
//
// If pseq does not see either of these register writes,
// it will wait until the last of the gather data returns
// from memory to start executing commands again.
//
// A dma stream that includes a PSEQ_COMMAND or PSEQ_PC
// register must always be gathered using the GATHER.STOP
// command.
//
// A dma stream that includes a register in the 3D global
// address space (like GLOBAL_INST_OFFSET) or a register
// in the PSEQ local address space (like PSEQ_INST_DATA)
// must use the STOP bit in the GATHER command that gathers
// the dma stream in question or in a following GATHER
// command but before an EXECUTE command.
//
// GATHER STOP Decision tree.
//   if (dma stream has a PSEQ_COMMAND register or
//                        PSEQ_PC register or
//                        PSEQ_FLUSH register)
//     GATHER STOP must be 1
//   else if (dma stream has global or pseq local register)
//     if (is last gather with global or pseq local registers before an execute command)
//       GATHER STOP must be 1
//     else
//       GATHER STOP should be 0
//   else
//     GATHER STOP should be 0
//
// A GATHER.STOP can introduce memory latency based delays,
// so the chip can perform better when they are only used when
// required.
//
// legal, well performing examples  (the registers in the dma stream are listed after the GATHER)
// 0 GATHER GLOBAL_INST_OFFSET
// 1 GATHER.STOP PSEQ_INST_DATA + FLUSH
// 2 EXECUTE
//
// 0 GATHER GLOBAL_INST_OFFSET
// 1 GATHER.STOP TEX_INST_DATA + FLUSH
// 2 EXECUTE
//
// 0 GATHER.STOP GLOBAL_INST_OFFSET + PSEQ_INST_DATA + FLUSH
// 1 EXECUTE
#define PKT_FLD_AR3D_PSEQ_GATHER_STOP(_) _(AR3D_PSEQ_GATHER,STOP,0,1,28,28,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_GATHER_STOP(_)
// (P1 feature) Starting offset (if
// putting opcode into the stream)
#define PKT_FLD_AR3D_PSEQ_GATHER_OFFSET(_) _(AR3D_PSEQ_GATHER,OFFSET,0,12,27,16,0xfff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_GATHER_OFFSET(_)
// (P1 feature) Insert an opcode (type set
// by TYPE, initial offset set by OFFSET)
// immediately before the gathered data stream. 
#define PKT_FLD_AR3D_PSEQ_GATHER_INSERT(_) _(AR3D_PSEQ_GATHER,INSERT,0,1,15,15,0x1,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_GATHER_INSERT(_) \
_(AR3D_PSEQ_GATHER,INSERT,DISABLE,0) \
_(AR3D_PSEQ_GATHER,INSERT,ENABLE,1)
// (P1 feature) Type of opcode to be inserted (incrementing or 
// non-incrementing).  Only valid if INSERT is enabled.
#define PKT_FLD_AR3D_PSEQ_GATHER_TYPE(_) _(AR3D_PSEQ_GATHER,TYPE,0,1,14,14,0x1,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_GATHER_TYPE(_) \
_(AR3D_PSEQ_GATHER,TYPE,NONINCR,0) \
_(AR3D_PSEQ_GATHER,TYPE,INCR,1)
// Hint the cache to keep the gather 
// reads persistent
#define PKT_FLD_AR3D_PSEQ_GATHER_CACHE_PERSISTENT(_) _(AR3D_PSEQ_GATHER,CACHE_PERSISTENT,0,1,13,13,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_GATHER_CACHE_PERSISTENT(_)
// Count of 32-bit words to be gathered from memory
#define PKT_FLD_AR3D_PSEQ_GATHER_COUNT(_) _(AR3D_PSEQ_GATHER,COUNT,0,13,12,0,0x1fff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_GATHER_COUNT(_)
// Base address of chunk to be gathered from memory.  The address is given in words.
#define PKT_FLD_AR3D_PSEQ_GATHER_ADDRESS(_) _(AR3D_PSEQ_GATHER,ADDRESS,1,30,31,2,0x3fffffff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_GATHER_ADDRESS(_)

// Packet AR3D_PSEQ_EXECUTE
#define LIST_PKT_FLD_AR3D_PSEQ_EXECUTE(_) \
_(AR3D_PSEQ_EXECUTE,OPCODE) \
_(AR3D_PSEQ_EXECUTE,UNUSED0) \
_(AR3D_PSEQ_EXECUTE,NEXT_START) \
_(AR3D_PSEQ_EXECUTE,DEST) \
_(AR3D_PSEQ_EXECUTE,START) \
_(AR3D_PSEQ_EXECUTE,COUNT) \
_(AR3D_PSEQ_EXECUTE,UNUSED1)
#define PKT_AR3D_PSEQ_EXECUTE(_) _(AR3D_PSEQ_EXECUTE,32,FLD)
// Instruction execute
#define PKT_FLD_AR3D_PSEQ_EXECUTE_OPCODE(_) _(AR3D_PSEQ_EXECUTE,OPCODE,0,3,31,29,0x7,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_EXECUTE_OPCODE(_) \
_(AR3D_PSEQ_EXECUTE,OPCODE,EXECUTE,1)
#define PKT_FLD_AR3D_PSEQ_EXECUTE_UNUSED0(_) _(AR3D_PSEQ_EXECUTE,UNUSED0,0,8,28,21,0xff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_EXECUTE_UNUSED0(_)
// If this execute has a RECIRC dest this must
// be set to the next execute's start
#define PKT_FLD_AR3D_PSEQ_EXECUTE_NEXT_START(_) _(AR3D_PSEQ_EXECUTE,NEXT_START,0,6,20,15,0x3f,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_EXECUTE_NEXT_START(_)
// where do the pixels go when execute finishes
#define PKT_FLD_AR3D_PSEQ_EXECUTE_DEST(_) _(AR3D_PSEQ_EXECUTE,DEST,0,2,14,13,0x3,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_EXECUTE_DEST(_) \
_(AR3D_PSEQ_EXECUTE,DEST,RECIRC,0) \
_(AR3D_PSEQ_EXECUTE,DEST,SPILL,1) \
_(AR3D_PSEQ_EXECUTE,DEST,DONE,2) \
_(AR3D_PSEQ_EXECUTE,DEST,STOP,3)
// sequence start index
#define PKT_FLD_AR3D_PSEQ_EXECUTE_START(_) _(AR3D_PSEQ_EXECUTE,START,0,6,12,7,0x3f,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_EXECUTE_START(_)
// sequence count (numRows * numPasses)
#define PKT_FLD_AR3D_PSEQ_EXECUTE_COUNT(_) _(AR3D_PSEQ_EXECUTE,COUNT,0,7,6,0,0x7f,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_EXECUTE_COUNT(_)
#define PKT_FLD_AR3D_PSEQ_EXECUTE_UNUSED1(_) _(AR3D_PSEQ_EXECUTE,UNUSED1,1,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_EXECUTE_UNUSED1(_)

// Packet AR3D_PSEQ_BRANCH
#define LIST_PKT_FLD_AR3D_PSEQ_BRANCH(_) \
_(AR3D_PSEQ_BRANCH,OPCODE) \
_(AR3D_PSEQ_BRANCH,COND) \
_(AR3D_PSEQ_BRANCH,DEST) \
_(AR3D_PSEQ_BRANCH,UNUSED1)
#define PKT_AR3D_PSEQ_BRANCH(_) _(AR3D_PSEQ_BRANCH,32,FLD)
// Command Branch
#define PKT_FLD_AR3D_PSEQ_BRANCH_OPCODE(_) _(AR3D_PSEQ_BRANCH,OPCODE,0,3,31,29,0x7,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_BRANCH_OPCODE(_) \
_(AR3D_PSEQ_BRANCH,OPCODE,BRANCH,2)
// condition code 
// (ALWAYS is the only cond supported, others P1)
#define PKT_FLD_AR3D_PSEQ_BRANCH_COND(_) _(AR3D_PSEQ_BRANCH,COND,0,3,28,26,0x7,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_BRANCH_COND(_) \
_(AR3D_PSEQ_BRANCH,COND,ALWAYS,0) \
_(AR3D_PSEQ_BRANCH,COND,NEVER,1) \
_(AR3D_PSEQ_BRANCH,COND,AND,2) \
_(AR3D_PSEQ_BRANCH,COND,NAND,3) \
_(AR3D_PSEQ_BRANCH,COND,OR,4) \
_(AR3D_PSEQ_BRANCH,COND,NOR,5)
// signed offset from PC
// to branch to.
#define PKT_FLD_AR3D_PSEQ_BRANCH_DEST(_) _(AR3D_PSEQ_BRANCH,DEST,0,5,4,0,0x1f,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_BRANCH_DEST(_)
#define PKT_FLD_AR3D_PSEQ_BRANCH_UNUSED1(_) _(AR3D_PSEQ_BRANCH,UNUSED1,1,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_BRANCH_UNUSED1(_)
//not supported.  P1

// Packet AR3D_PSEQ_IMM
#define LIST_PKT_FLD_AR3D_PSEQ_IMM(_) \
_(AR3D_PSEQ_IMM,OPCODE) \
_(AR3D_PSEQ_IMM,OFFSET) \
_(AR3D_PSEQ_IMM,UNUSED) \
_(AR3D_PSEQ_IMM,IMMDATA)
#define PKT_AR3D_PSEQ_IMM(_) _(AR3D_PSEQ_IMM,32,FLD)
// Immediate register write
#define PKT_FLD_AR3D_PSEQ_IMM_OPCODE(_) _(AR3D_PSEQ_IMM,OPCODE,0,3,31,29,0x7,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_IMM_OPCODE(_) \
_(AR3D_PSEQ_IMM,OPCODE,IMM,3)
// register offset
#define PKT_FLD_AR3D_PSEQ_IMM_OFFSET(_) _(AR3D_PSEQ_IMM,OFFSET,0,12,27,16,0xfff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_IMM_OFFSET(_)
#define PKT_FLD_AR3D_PSEQ_IMM_UNUSED(_) _(AR3D_PSEQ_IMM,UNUSED,0,16,15,0,0xffff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_IMM_UNUSED(_)
// immediate data
#define PKT_FLD_AR3D_PSEQ_IMM_IMMDATA(_) _(AR3D_PSEQ_IMM,IMMDATA,1,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_IMM_IMMDATA(_)
//not supported. P1

// Packet AR3D_PSEQ_ST
#define LIST_PKT_FLD_AR3D_PSEQ_ST(_) \
_(AR3D_PSEQ_ST,OPCODE) \
_(AR3D_PSEQ_ST,OFFSET) \
_(AR3D_PSEQ_ST,SURF) \
_(AR3D_PSEQ_ST,TYPE) \
_(AR3D_PSEQ_ST,COUNT) \
_(AR3D_PSEQ_ST,UNUSED1)
#define PKT_AR3D_PSEQ_ST(_) _(AR3D_PSEQ_ST,32,FLD)
// Store register to memory
#define PKT_FLD_AR3D_PSEQ_ST_OPCODE(_) _(AR3D_PSEQ_ST,OPCODE,0,5,31,27,0x1f,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_ST_OPCODE(_) \
_(AR3D_PSEQ_ST,OPCODE,ST,4)
// register offset
#define PKT_FLD_AR3D_PSEQ_ST_OFFSET(_) _(AR3D_PSEQ_ST,OFFSET,0,12,27,16,0xfff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_ST_OFFSET(_)
// surface (indexes SURFDESC)
#define PKT_FLD_AR3D_PSEQ_ST_SURF(_) _(AR3D_PSEQ_ST,SURF,0,4,15,12,0xf,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_ST_SURF(_)
// How do we calculate the offset (incrementing 
// or non-incrementing). 
#define PKT_FLD_AR3D_PSEQ_ST_TYPE(_) _(AR3D_PSEQ_ST,TYPE,0,1,11,11,0x1,ENM)
#define LIST_PKT_ENM_AR3D_PSEQ_ST_TYPE(_) \
_(AR3D_PSEQ_ST,TYPE,NONINCR,0) \
_(AR3D_PSEQ_ST,TYPE,INCR,1)
#define PKT_FLD_AR3D_PSEQ_ST_COUNT(_) _(AR3D_PSEQ_ST,COUNT,0,11,10,0,0x7ff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_ST_COUNT(_)
#define PKT_FLD_AR3D_PSEQ_ST_UNUSED1(_) _(AR3D_PSEQ_ST,UNUSED1,1,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_AR3D_PSEQ_ST_UNUSED1(_)
//
// Instruction table offset: controls what indirect entry in the instruction table gets accessed.
// INDEX auto-increments with each access to INST_DATA.
//

// Register AR3D_PSEQ_INST_OFFSET 
#define LIST_REG_FLD_AR3D_PSEQ_INST_OFFSET(_) \
_(AR3D_PSEQ,INST_OFFSET,INDEX)
#define REG_AR3D_PSEQ_INST_OFFSET(_) _(AR3D_PSEQ,INST_OFFSET,0x540,0x40,1,1,0x3f,0x0,NOARY,FLD)
// current read or write target in INST_DATA
#define REG_FLD_AR3D_PSEQ_INST_OFFSET_INDEX(_) _(AR3D_PSEQ,INST_OFFSET,INDEX,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_INST_OFFSET_INDEX(_)

//
//  INST -- An array of pseq load instructions
//
// Pixels flow through the pipeline in "pixel packets".  A given pixel is
// expressed in one to four rows of pixel data, with each row containing four
// 20 bit fields.  These fields typically hold either a 20 bit floating point
// value or two 10 bit fixed point values.  One to four rows of data logically
// constitute a pixel packet.
//
// Pixel packets may recirculate through multiple fragment pipe units multiple
// times in order to carry out a complex shader.  In order to keep track of
// things, each row of a pixel packet is assigned a sequence number.  A sequence
// number is unique to a given row and pass of a pixel packet, and is controlled
// by the global register PIX_ATTR, or by pseq's execute command.
//
// Once pseq looks up the proper instruction it will perform the instruction
// indicated (either nop, or load)
// the 
//
// INST fields:
//  OP controls whether or not to preform a load, and what kind of
//      load to do
//
//      NOP --  No operation
//
//      LD  --  Load from memory.  Surfaces read from are described in
//              the SURFDESC section of ar3d.spec supported formats
//              are as follows:
//
//          Raw only:
//              C4X4,
//              Z16, 
//              Z16NL,
//          FX10 conversion:
//              A8, 
//              L8, 
//              S8,
//              L8A8,
//              B2G3R3,
//              B5G6R5, 
//              B5G5R5A1, 
//              B4G4R4A4,
//              A1B5G5R5, 
//              A4B4G4R4,
//              R8G8B8A8, 
//              B8G8R8A8,
//          FP20 conversion:
//              A16_float,
//              L16_float,
//              L16A16_float,
//              R16G16B16A16_float,
//              R11G11B10_float,
//
//      LD_R20 -- Load a register from memory.  
//          P32_float
//          P128
//
//      LD_R80 -- Load a register from memory.  
//          P128
//
// Not Supported: DXT1, DXT1C, DXT3, DXT5, ETC, ETC3, ETC5, LATC1, LATC2,
//                R10G10B10_float_A2, B8G8R8G8, G8B8G8R8
//
//
//  READ_KILLED controls whether to perform a load with killed pixels
//      All pixels with a load instruction will perform the load if
//      this bit is set
//      If this bit is disabled the following combinations of pixel
//      state and surface format will perform loads:
//
//      STENCIL will load on S_FAIL Z_FAIL Z_PASS 
//      All other formats will load on Z_PASS 
//
//  READ_NON_CENTER controls whether to perform a load with non_center pixels
//      In addition to the cases listed with the READ_KILLED description, pseq
//      will load in the following cases if READ_NON_CENTER is set
//
//      All formats will load when the pixel is in the NON_CENTER state 
//
//  SURF is an index into the SURFDESC and SURFADDR to describe the target of
//      the load
// 
//  ARGS Opcode specific arguments
// 
//    LD_ARGS -- The arguments for the INST_DATA::eOP_LD opcode
//
//      REG, MOD select a half register output location for the result
//        of the load.  Additional bits from the load will go into
//        adjacent registers (with wrap so that the destination register
//        after R3.H is R0.L)
//
//        10 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L
//        R0.H    -> R0.H
//        R1.L    -> R1.L
//        ...
//        R3.H    -> R3.H
//        
//        20 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L, R0.H
//        R0.H    -> R0.H, R1.L
//        R1.L    -> R1.L, R1.H
//        ...
//        R3.H    -> R3.H, R0.L
//        
//        30 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L, R0.H, R1.L
//        R0.H    -> R0.H, R1.L, R1.H
//        R1.L    -> R1.L, R1.H, R2.L
//        ...
//        R3.H    -> R3.H, R0.L, R0.H
//        
//        40 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L, R0.H, R1.L, R1.H
//        R0.H    -> R0.H, R1.L, R1.H, R2.L
//        R1.L    -> R1.L, R1.H, R2.L, R2.H
//        ...
//        R3.H    -> R3.H, R0.L, R0.H, R1.L
//        
//        ...
//        ... (skipping 50, 60, and 70 bit destination loads)
//        ...
//        
//        80 Bit Destination Load: (REG.MOD -> Registers used)
//        R0.L    -> R0.L, R0.H, R1.L, R1.H, R2.L, R2.H, R3.L, R3.H
//        R0.H    -> R0.H, R1.L, R1.H, R2.L, R2.H, R3.L, R3.H, R0.L
//        R1.L    -> R1.L, R1.H, R2.L, R2.H, R3.L, R3.H, R0.L, R0.H
//        ...
//        R3.H    -> R3.H, R0.L, R0.H, R1.L, R1.H, R2.L, R2.H, R3.L
//        
//        component ordering is always red,green,blue,alpha from lsb to msb
//        
//        Fixed point formats load into FX10 registers. For example:
//        
//        REG.MOD==R0.L:     red   -> R0, low
//                           green -> R0, high
//                           blue  -> R1, low
//                           alpha -> R1, high
//        
//        If the format in memory does not contain all the color components the
//        missing components get filled in like this:
//        A8           --   (0x00,0x00,0x00,A   ) 
//        L8           --   (L   ,L   ,L   ,0xFF)
//        L8A8         --   (L   ,L   ,L   ,A   )
//        B2G3R3       --   (R   ,G   ,B   ,0xFF)
//        B5G6R5       --   (R   ,G   ,B   ,0xFF)
//        
//        Floating point formats load into FP20 register. For example:
//        REG.MOD==R0.L:     red   -> R0
//                           green -> R1
//                           blue  -> R2
//                           alpha -> R3
//        
//        Like fixed point formats, if the format in memory does not contain all
//        the color components the missing components get filled in like this:
//        A16_float       --  (0.0 , A  )
//        L16_float       --  (L   , 1.0)
//        L16A16_float    --  (L   , A  )
//        R11G11B10_float --  (R   , G  , B  )
//
//      CNV  If set the load will put the result of a format conversion in
//        the registers indicated by REG and MOD.
//
//      RAW  If set the load will put the unconverted bits of the surface
//        load into the register pair adjacent to the register pair
//        indicated by REG, MOD.
//            REG.MOD     ->  RAW REG.MOD
//            R0.L        ->  R2.L
//            R0.H        ->  R2.H
//            R1.L        ->  R3.L
//            R1.H        ->  R3.H
//            R2.L        ->  R0.L
//            R2.H        ->  R0.H
//            R3.L        ->  R1.L
//            R3.H        ->  R1.H
//
//        The raw bits are packed unchanged into the lsb bits of the lowest
//        specified registers.  For example:
//          REG.MOD==R0.L:
//            8bit formats   ->  R0.L          < 7:0>
//            16bit formats  ->  R0            <16:0>
//            32bit formats  ->  R0,R1         <31:0>
//            64bit formats  ->  R0,R1,R2,R3.L <63:0>
//          
//      Because the fields would overlap, the following formats have undefined 
//      results if both RAW and CNV are enabled:
//      R11G11B10_float
//      R16G16B16A16_float
//
//      LD Args Format
//        Bit        Description
//        1:0        REG: Selects which FP20 register to load
//                                  0 = R0
//                                  1 = R1
//                                  2 = R2
//                                  3 = R3
//        2          MOD:  Selects which half word to load.
//                                  0 = L
//                                  1 = H
//        3          CNV: Load format converted bits into REG.MOD
//                                  0 = DISABLE
//                                  1 = ENABLE
//        4          RAW: Load raw  bits into REG+2.MOD
//                                  0 = DISABLE
//                                  1 = ENABLE
//
//
//    LD_R20_ARGS -- The arguments for the INST_DATA::eOP_LD_R20 opcode
//
//    REG  select a register output location for the result of the
//        load.  
//      READ_MASK each bit set in the mask will enable the result of the
//        read to be written to associated half register.  Bit 0 masks
//        the low half-register, and Bit 1 masks the high half-register.
//    
//      OFFSET_REG_EN If enabled the offset for the LD_R20 will come from
//        the half-register specified by OFFSET_REG and OFFSET_MOD.
//        Otherwise, the offset will come from the OFFSET_IMM field.
//        The OFFSET_IMM field overlaps the OFFSET_REG and OFFSET_MOD
//        fields, so they should not be used at the same time.
//    
//      OFFSET_IMM Index into the register array. Used if OFFSET_REG_EN is
//        DISABLED.
//    
//        If the surface is P128 the lower two bits are used to select
//        the 32 bit word from the 128 bit surface. The next 6 bits are
//        used to stride across the surface.
//    
//        If the surface is P32_float all 8 bits are used to stride
//        across the surface.
//    
//      OFFSET_REG, OFFSET_MOD Select the half-register the 8 bit offset
//        will come from.  Used if OFFSET_REG_EN is ENABLED.
//    
//        If the surface is P128 the lower two bits of the selected
//        half-register are used to select the 32 bit word from the 128
//        bit surface. The upper 6 bits are used to stride across the
//        surface.
//    
//        If the surface is P32_float the lower 8 bits of the selected
//        register are used to stride across the surface.
//    
//      OFFSET_TYPE Determines whether there is a unique memory address
//        for each pixel in the pipeline, or a shared memory address
//        for all pixels.  Please see GLOBAL_SURFDEST.ARRAY_STRIDE for
//        info about the different surface stride requirements between LOCAL
//        versus GLOBAL offset types
//        
//        LOCAL  -- unique memory location per pixel, used for temporary pixel data 
//                  storage
//        GLOBAL -- shared memory location for all pixels, can be used for constants
//                  and other global values.
//
//      LD_R20 Args Format
//        Bit        Description
//        1:0        REG: Select which FP20 register to load
//                                  0 = R0
//                                  1 = R1
//                                  2 = R2
//                                  3 = R3
//        3:2        READ_MASK: Select which L/H bits are read.
//        13:6       OFFSET_IMM: Used for array formats, 
//                                  index into the array if
//                                  OFFSET_REG_EN == DISABLE
//        9:8        OFFSET_REG: Specifies which register contains
//                                  the 8 bit offset
//                                  0 = R0
//                                  1 = R1
//                                  2 = R2
//                                  3 = R3
//        10         OFFSET_MOD: Specifies which half word contains 
//                                  the 8 bit offset
//                                  0 = L
//                                  1 = H
//        14         OFFSET_REG_EN: Enable offset reg
//                                  0 = DISABLE
//                                  1 = ENABLE
//        
//        15         OFFSET_TYPE: Is the offset a local offset or 
//                                  global offset.
//                                  A local offset uses QID, and offset to 
//                                  determine the memory address, while a global
//                                  offset just uses offset.
//                                  0 = LOCAL
//                                  1 = GLOBAL 
//
//    LD_R80_ARGS -- The arguments for the INST_DATA::eOP_LD_R80 opcode
//    
//      READ_MASK each bit set in the mask will enable the result of the
//        read to be written to associated half register.  
//        READ_MASK[0] masks R0.L
//        READ_MASK[1] masks R0.H
//        READ_MASK[2] masks R1.L
//        ...
//        READ_MASK[7] masks R3.H
//    
//      OFFSET_REG_EN If enabled the offset for the LD_R80 will come from
//        the half-register specified by OFFSET_REG and OFFSET_MOD.
//        Otherwise, the offset will come from the OFFSET_IMM field.
//        The OFFSET_IMM field overlaps the OFFSET_REG and OFFSET_MOD
//        fields, so they should not be used at the same time.
//    
//      OFFSET_IMM Index into the register array. Used if OFFSET_REG_EN is
//        DISABLED.
//    
//        All 6 bits are used to stride across the surface
//    
//      OFFSET_REG, OFFSET_MOD Select the half-register the 6 bit offset
//        will come from.  Used if OFFSET_REG_EN is ENABLED.
//    
//      OFFSET_TYPE  Is there a unique memory address for each pixel in the
//        pipeline, or do all pixels share the same memory address.
//    
//        LOCAL  -- unique address per pixel, used for register spill
//        GLOBAL -- shared address per pixel, can be used for constants
//                  and other global values.
//
//    LD_R80 Args Format
//      Bit        Description
//      7:0        READ_MASK:  Which FX10 registers to load
//      13:8       OFFSET_IMM: Used for array formats, 
//                                index into the array if
//                                OFFSET_REG_EN == DISABLE
//      9:8        OFFSET_REG:  Specifies which register contains
//                                the 6 bit offset
//                                0 = R0
//                                1 = R1
//                                2 = R2
//                                3 = R3
//      10         OFFSET_MOD: Specifies which half word contains 
//                                the 6 bit offset
//                                0 = L
//                                1 = H
//      14         OFFSET_REG_EN: Enable offset reg
//                                0 = DISABLE
//                                1 = ENABLE
//
//      15         OFFSET_TYPE: Is the offset a local offset or 
//                                global offset.
//                                A local offset uses QID, and offset to determine
//                                the memory address, while a global offset just
//                                uses offset.
//                                0 = LOCAL
//                                1 = GLOBAL 
//
//

// Register AR3D_PSEQ_INST_DATA 
#define LIST_REG_FLD_AR3D_PSEQ_INST_DATA(_) \
_(AR3D_PSEQ,INST_DATA,OP) \
_(AR3D_PSEQ,INST_DATA,CACHE_PERSISTENT) \
_(AR3D_PSEQ,INST_DATA,READ_KILLED) \
_(AR3D_PSEQ,INST_DATA,READ_NON_CENTER) \
_(AR3D_PSEQ,INST_DATA,SURF) \
_(AR3D_PSEQ,INST_DATA,ARGS)
#define REG_AR3D_PSEQ_INST_DATA(_) _(AR3D_PSEQ,INST_DATA,0x541,0x41,1,1,0x1ffffff,0x0,NOARY,FLD)
// opcode
#define REG_FLD_AR3D_PSEQ_INST_DATA_OP(_) _(AR3D_PSEQ,INST_DATA,OP,2,24,23,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_PSEQ_INST_DATA_OP(_) \
_(AR3D_PSEQ,INST_DATA,OP,NOP,0) \
_(AR3D_PSEQ,INST_DATA,OP,LD,1) \
_(AR3D_PSEQ,INST_DATA,OP,LD_R20,2) \
_(AR3D_PSEQ,INST_DATA,OP,LD_R80,3)
#define AR3D_PSEQ_INST_DATA_OP_NOP                      _MK_ENUM_CONST(0)
#define AR3D_PSEQ_INST_DATA_OP_LD                       _MK_ENUM_CONST(1)
#define AR3D_PSEQ_INST_DATA_OP_LD_R20                   _MK_ENUM_CONST(2)
#define AR3D_PSEQ_INST_DATA_OP_LD_R80                   _MK_ENUM_CONST(3)

// set if load should stay in the fdc cache
#define REG_FLD_AR3D_PSEQ_INST_DATA_CACHE_PERSISTENT(_) _(AR3D_PSEQ,INST_DATA,CACHE_PERSISTENT,1,22,22,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_INST_DATA_CACHE_PERSISTENT(_)

// If ENABLED read pixel even if not in Z_PASS state.
#define REG_FLD_AR3D_PSEQ_INST_DATA_READ_KILLED(_) _(AR3D_PSEQ,INST_DATA,READ_KILLED,1,21,21,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_PSEQ_INST_DATA_READ_KILLED(_) \
_(AR3D_PSEQ,INST_DATA,READ_KILLED,DISABLE,0) \
_(AR3D_PSEQ,INST_DATA,READ_KILLED,ENABLE,1)
#define AR3D_PSEQ_INST_DATA_READ_KILLED_DISABLE                 _MK_ENUM_CONST(0)
#define AR3D_PSEQ_INST_DATA_READ_KILLED_ENABLE                  _MK_ENUM_CONST(1)

// If ENABLED read pixel even if  in NON_CENTER state.
#define REG_FLD_AR3D_PSEQ_INST_DATA_READ_NON_CENTER(_) _(AR3D_PSEQ,INST_DATA,READ_NON_CENTER,1,20,20,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_PSEQ_INST_DATA_READ_NON_CENTER(_) \
_(AR3D_PSEQ,INST_DATA,READ_NON_CENTER,DISABLE,0) \
_(AR3D_PSEQ,INST_DATA,READ_NON_CENTER,ENABLE,1)
#define AR3D_PSEQ_INST_DATA_READ_NON_CENTER_DISABLE                     _MK_ENUM_CONST(0)
#define AR3D_PSEQ_INST_DATA_READ_NON_CENTER_ENABLE                      _MK_ENUM_CONST(1)

// surface descriptor index for read operations
#define REG_FLD_AR3D_PSEQ_INST_DATA_SURF(_) _(AR3D_PSEQ,INST_DATA,SURF,4,19,16,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_INST_DATA_SURF(_)

// see packets LD_*_ARGS below
#define REG_FLD_AR3D_PSEQ_INST_DATA_ARGS(_) _(AR3D_PSEQ,INST_DATA,ARGS,16,15,0,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_INST_DATA_ARGS(_)

//WARNING any changes to this packet needs to be
//  reflected in the comments above

// Packet LD_ARGS
#define LIST_PKT_FLD_LD_ARGS(_) \
_(LD_ARGS,REG) \
_(LD_ARGS,MOD) \
_(LD_ARGS,CNV) \
_(LD_ARGS,RAW) \
_(LD_ARGS,RESERVED)
#define PKT_LD_ARGS(_) _(LD_ARGS,16,FLD)
//Which register is the destination of the load
#define PKT_FLD_LD_ARGS_REG(_) _(LD_ARGS,REG,0,2,1,0,0x3,ENM)
#define LIST_PKT_ENM_LD_ARGS_REG(_) \
_(LD_ARGS,REG,R0,0) \
_(LD_ARGS,REG,R1,1) \
_(LD_ARGS,REG,R2,2) \
_(LD_ARGS,REG,R3,3)
//which half word is the destination of the load
#define PKT_FLD_LD_ARGS_MOD(_) _(LD_ARGS,MOD,0,1,2,2,0x1,ENM)
#define LIST_PKT_ENM_LD_ARGS_MOD(_) \
_(LD_ARGS,MOD,L,0) \
_(LD_ARGS,MOD,H,1)
//load format converted bits into REG
#define PKT_FLD_LD_ARGS_CNV(_) _(LD_ARGS,CNV,0,1,3,3,0x1,ENM)
#define LIST_PKT_ENM_LD_ARGS_CNV(_) \
_(LD_ARGS,CNV,DISABLE,0) \
_(LD_ARGS,CNV,ENABLE,1)
//if enabled load the raw bits into the adjacent
#define PKT_FLD_LD_ARGS_RAW(_) _(LD_ARGS,RAW,0,1,4,4,0x1,ENM)
#define LIST_PKT_ENM_LD_ARGS_RAW(_) \
_(LD_ARGS,RAW,DISABLE,0) \
_(LD_ARGS,RAW,ENABLE,1)
#define PKT_FLD_LD_ARGS_RESERVED(_) _(LD_ARGS,RESERVED,0,11,15,5,0x7ff,NOENM)
#define LIST_PKT_ENM_LD_ARGS_RESERVED(_)
//WARNING any changes to this packet needs to be
//  reflected in the comments above

// Packet LD_R20_ARGS
#define LIST_PKT_FLD_LD_R20_ARGS(_) \
_(LD_R20_ARGS,REG) \
_(LD_R20_ARGS,READ_MASK) \
_(LD_R20_ARGS,OFFSET_IMM) \
_(LD_R20_ARGS,OFFSET_REG) \
_(LD_R20_ARGS,OFFSET_MOD) \
_(LD_R20_ARGS,OFFSET_REG_EN) \
_(LD_R20_ARGS,OFFSET_TYPE)
#define PKT_LD_R20_ARGS(_) _(LD_R20_ARGS,16,FLD)
//Which FP20 register to load
#define PKT_FLD_LD_R20_ARGS_REG(_) _(LD_R20_ARGS,REG,0,2,1,0,0x3,ENM)
#define LIST_PKT_ENM_LD_R20_ARGS_REG(_) \
_(LD_R20_ARGS,REG,R0,0) \
_(LD_R20_ARGS,REG,R1,1) \
_(LD_R20_ARGS,REG,R2,2) \
_(LD_R20_ARGS,REG,R3,3)
//which L/H bits are read.
#define PKT_FLD_LD_R20_ARGS_READ_MASK(_) _(LD_R20_ARGS,READ_MASK,0,2,3,2,0x3,NOENM)
#define LIST_PKT_ENM_LD_R20_ARGS_READ_MASK(_)
//offset -- used for array formats, 
//          index into the array if
//          OFFSET_REG_EN == DISABLE
#define PKT_FLD_LD_R20_ARGS_OFFSET_IMM(_) _(LD_R20_ARGS,OFFSET_IMM,0,8,13,6,0xff,NOENM)
#define LIST_PKT_ENM_LD_R20_ARGS_OFFSET_IMM(_)
//which register contains the 8 bit offset
#define PKT_FLD_LD_R20_ARGS_OFFSET_REG(_) _(LD_R20_ARGS,OFFSET_REG,0,2,9,8,0x3,ENM)
#define LIST_PKT_ENM_LD_R20_ARGS_OFFSET_REG(_) \
_(LD_R20_ARGS,OFFSET_REG,R0,0) \
_(LD_R20_ARGS,OFFSET_REG,R1,1) \
_(LD_R20_ARGS,OFFSET_REG,R2,2) \
_(LD_R20_ARGS,OFFSET_REG,R3,3)
//which half word contains the 8 bit offset
#define PKT_FLD_LD_R20_ARGS_OFFSET_MOD(_) _(LD_R20_ARGS,OFFSET_MOD,0,1,10,10,0x1,ENM)
#define LIST_PKT_ENM_LD_R20_ARGS_OFFSET_MOD(_) \
_(LD_R20_ARGS,OFFSET_MOD,L,0) \
_(LD_R20_ARGS,OFFSET_MOD,H,1)
//enable offset reg
#define PKT_FLD_LD_R20_ARGS_OFFSET_REG_EN(_) _(LD_R20_ARGS,OFFSET_REG_EN,0,1,14,14,0x1,ENM)
#define LIST_PKT_ENM_LD_R20_ARGS_OFFSET_REG_EN(_) \
_(LD_R20_ARGS,OFFSET_REG_EN,DISABLE,0) \
_(LD_R20_ARGS,OFFSET_REG_EN,ENABLE,1)
//Is the offset a local offset or global offset
//a local offset uses x,y,offset to determine
//address, a global offset just uses offset.
#define PKT_FLD_LD_R20_ARGS_OFFSET_TYPE(_) _(LD_R20_ARGS,OFFSET_TYPE,0,1,15,15,0x1,ENM)
#define LIST_PKT_ENM_LD_R20_ARGS_OFFSET_TYPE(_) \
_(LD_R20_ARGS,OFFSET_TYPE,LOCAL,0) \
_(LD_R20_ARGS,OFFSET_TYPE,GLOBAL,1)
//WARNING any changes to this packet needs to be
//  reflected in the comments above

// Packet LD_R80_ARGS
#define LIST_PKT_FLD_LD_R80_ARGS(_) \
_(LD_R80_ARGS,READ_MASK) \
_(LD_R80_ARGS,OFFSET_IMM) \
_(LD_R80_ARGS,OFFSET_REG) \
_(LD_R80_ARGS,OFFSET_MOD) \
_(LD_R80_ARGS,OFFSET_REG_EN) \
_(LD_R80_ARGS,OFFSET_TYPE)
#define PKT_LD_R80_ARGS(_) _(LD_R80_ARGS,16,FLD)
//Which FX10 registers to load
#define PKT_FLD_LD_R80_ARGS_READ_MASK(_) _(LD_R80_ARGS,READ_MASK,0,8,7,0,0xff,NOENM)
#define LIST_PKT_ENM_LD_R80_ARGS_READ_MASK(_)
//offset -- used for array formats, 
//          index into the array if
//          OFFSET_REG_EN == DISABLE
#define PKT_FLD_LD_R80_ARGS_OFFSET_IMM(_) _(LD_R80_ARGS,OFFSET_IMM,0,6,13,8,0x3f,NOENM)
#define LIST_PKT_ENM_LD_R80_ARGS_OFFSET_IMM(_)
//which register contains the 8 bit offset
#define PKT_FLD_LD_R80_ARGS_OFFSET_REG(_) _(LD_R80_ARGS,OFFSET_REG,0,2,9,8,0x3,ENM)
#define LIST_PKT_ENM_LD_R80_ARGS_OFFSET_REG(_) \
_(LD_R80_ARGS,OFFSET_REG,R0,0) \
_(LD_R80_ARGS,OFFSET_REG,R1,1) \
_(LD_R80_ARGS,OFFSET_REG,R2,2) \
_(LD_R80_ARGS,OFFSET_REG,R3,3)
//which half word contains the 8 bit offset
#define PKT_FLD_LD_R80_ARGS_OFFSET_MOD(_) _(LD_R80_ARGS,OFFSET_MOD,0,1,10,10,0x1,ENM)
#define LIST_PKT_ENM_LD_R80_ARGS_OFFSET_MOD(_) \
_(LD_R80_ARGS,OFFSET_MOD,L,0) \
_(LD_R80_ARGS,OFFSET_MOD,H,1)
//enable offset reg
#define PKT_FLD_LD_R80_ARGS_OFFSET_REG_EN(_) _(LD_R80_ARGS,OFFSET_REG_EN,0,1,14,14,0x1,ENM)
#define LIST_PKT_ENM_LD_R80_ARGS_OFFSET_REG_EN(_) \
_(LD_R80_ARGS,OFFSET_REG_EN,DISABLE,0) \
_(LD_R80_ARGS,OFFSET_REG_EN,ENABLE,1)
//Is the offset a local offset or global offset
//a local offset uses x,y,offset to determine
//address, a global offset just uses offset.
#define PKT_FLD_LD_R80_ARGS_OFFSET_TYPE(_) _(LD_R80_ARGS,OFFSET_TYPE,0,1,15,15,0x1,ENM)
#define LIST_PKT_ENM_LD_R80_ARGS_OFFSET_TYPE(_) \
_(LD_R80_ARGS,OFFSET_TYPE,LOCAL,0) \
_(LD_R80_ARGS,OFFSET_TYPE,GLOBAL,1)
// DBG  -- Filter debug information
//
//   debug information (cmodel debug statements, instrumentation, etc)
//   will be controlled by the following DBG registers by this
//   formula:
//
//      
// DBG = (((DBG_X_EN == DISABLE)          | ((X >= DBX_X.START) && (X <= DBX_X.END)))
//        && ((DBG_Y_EN == DISABLE)       | ((Y >= DBX_Y.START) && (Y <= DBX_Y.END)))
//        && ((DBG_SEQ_EN == DISABLE)     | ((SEQ >= DBG_CTL.SEQ_START) && (SEQ <= DBG_CTL.SEQ_END)))
//        && ((DBG_COMMAND_EN == DISABLE) | (PC == DBG_CTL.COMMAND)))
// where DBG == 1 means debug is enabled and DBG == 0 means debug
// is disabled
// 
// In other words, debugging will be enabled unless an enabled test fails.
// Command allows us to get a range of sequence numbers by putting
// that range into a single EXECUTE command
// 
// The DBG bit in the pixel packet should be used by all fragment pipe
// modules to turn off instrumentation 
//    (if DBG==0 turn off instrumentation)  
// It should also be used by cmodel to turn off debug messages.  (if
// DBG==0 turn off debug msgs)
//
// Note:  One PSEQ stat PSEQ_RETWAIT.STEN cannot use dbg because it counting 
// how long it is waiting for the pixel packet to come from memory.  
// Since it doesn't know what the packet's dbg bit or x,y is set to, it doesn't 
// know to toggle the stat bit.  This stat will use SEQ and PC to filter, 
// but not X or Y.
// X range -- if DBG_X_EN is enabled then we disable debug for pixels
// outside the range [START,END]

// Register AR3D_PSEQ_DBG_X 
#define LIST_REG_FLD_AR3D_PSEQ_DBG_X(_) \
_(AR3D_PSEQ,DBG_X,START) \
_(AR3D_PSEQ,DBG_X,END)
#define REG_AR3D_PSEQ_DBG_X(_) _(AR3D_PSEQ,DBG_X,0x542,0x42,1,1,0x3fffff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_PSEQ_DBG_X_START(_) _(AR3D_PSEQ,DBG_X,START,11,21,11,3,0x7ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_X_START(_)

#define REG_FLD_AR3D_PSEQ_DBG_X_END(_) _(AR3D_PSEQ,DBG_X,END,11,10,0,3,0x7ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_X_END(_)

// Y range -- if DBG_X_EN is enabled then we disable debug for pixels
// outside the range [START,END]

// Register AR3D_PSEQ_DBG_Y 
#define LIST_REG_FLD_AR3D_PSEQ_DBG_Y(_) \
_(AR3D_PSEQ,DBG_Y,START) \
_(AR3D_PSEQ,DBG_Y,END)
#define REG_AR3D_PSEQ_DBG_Y(_) _(AR3D_PSEQ,DBG_Y,0x543,0x43,1,1,0x3fffff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_PSEQ_DBG_Y_START(_) _(AR3D_PSEQ,DBG_Y,START,11,21,11,3,0x7ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_Y_START(_)

#define REG_FLD_AR3D_PSEQ_DBG_Y_END(_) _(AR3D_PSEQ,DBG_Y,END,11,10,0,3,0x7ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_Y_END(_)

// SEQ and COMMAND compare values, and enables.

// Register AR3D_PSEQ_DBG_CTL 
#define LIST_REG_FLD_AR3D_PSEQ_DBG_CTL(_) \
_(AR3D_PSEQ,DBG_CTL,X_EN) \
_(AR3D_PSEQ,DBG_CTL,Y_EN) \
_(AR3D_PSEQ,DBG_CTL,SEQ_EN) \
_(AR3D_PSEQ,DBG_CTL,COMMAND_EN) \
_(AR3D_PSEQ,DBG_CTL,SEQ_START) \
_(AR3D_PSEQ,DBG_CTL,SEQ_END) \
_(AR3D_PSEQ,DBG_CTL,COMMAND_PC)
#define REG_AR3D_PSEQ_DBG_CTL(_) _(AR3D_PSEQ,DBG_CTL,0x544,0x44,1,1,0xf03f3ff,0x0,NOARY,FLD)
// enable filtering on pixel x
#define REG_FLD_AR3D_PSEQ_DBG_CTL_X_EN(_) _(AR3D_PSEQ,DBG_CTL,X_EN,1,0,0,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_CTL_X_EN(_) \
_(AR3D_PSEQ,DBG_CTL,X_EN,DISABLE,0) \
_(AR3D_PSEQ,DBG_CTL,X_EN,ENABLE,1)
#define AR3D_PSEQ_DBG_CTL_X_EN_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_PSEQ_DBG_CTL_X_EN_ENABLE                   _MK_ENUM_CONST(1)

// enable filtering on pixel y
#define REG_FLD_AR3D_PSEQ_DBG_CTL_Y_EN(_) _(AR3D_PSEQ,DBG_CTL,Y_EN,1,1,1,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_CTL_Y_EN(_) \
_(AR3D_PSEQ,DBG_CTL,Y_EN,DISABLE,0) \
_(AR3D_PSEQ,DBG_CTL,Y_EN,ENABLE,1)
#define AR3D_PSEQ_DBG_CTL_Y_EN_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_PSEQ_DBG_CTL_Y_EN_ENABLE                   _MK_ENUM_CONST(1)

// enable filtering on seq number
#define REG_FLD_AR3D_PSEQ_DBG_CTL_SEQ_EN(_) _(AR3D_PSEQ,DBG_CTL,SEQ_EN,1,2,2,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_CTL_SEQ_EN(_) \
_(AR3D_PSEQ,DBG_CTL,SEQ_EN,DISABLE,0) \
_(AR3D_PSEQ,DBG_CTL,SEQ_EN,ENABLE,1)
#define AR3D_PSEQ_DBG_CTL_SEQ_EN_DISABLE                        _MK_ENUM_CONST(0)
#define AR3D_PSEQ_DBG_CTL_SEQ_EN_ENABLE                 _MK_ENUM_CONST(1)

// enable filtering on command pc
#define REG_FLD_AR3D_PSEQ_DBG_CTL_COMMAND_EN(_) _(AR3D_PSEQ,DBG_CTL,COMMAND_EN,1,3,3,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_CTL_COMMAND_EN(_) \
_(AR3D_PSEQ,DBG_CTL,COMMAND_EN,DISABLE,0) \
_(AR3D_PSEQ,DBG_CTL,COMMAND_EN,ENABLE,1)
#define AR3D_PSEQ_DBG_CTL_COMMAND_EN_DISABLE                    _MK_ENUM_CONST(0)
#define AR3D_PSEQ_DBG_CTL_COMMAND_EN_ENABLE                     _MK_ENUM_CONST(1)

// if DBG_SEQ_EN is enabled then we
// disable debug for pixels that are less
// than this SEQ number 
#define REG_FLD_AR3D_PSEQ_DBG_CTL_SEQ_START(_) _(AR3D_PSEQ,DBG_CTL,SEQ_START,6,9,4,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_CTL_SEQ_START(_)

// if DBG_SEQ_EN is enabled then we
// disable debug for pixels that are greater
// than this SEQ number 
#define REG_FLD_AR3D_PSEQ_DBG_CTL_SEQ_END(_) _(AR3D_PSEQ,DBG_CTL,SEQ_END,6,17,12,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_CTL_SEQ_END(_)

// if DBG_COMMAND_EN is enabled then we disable
// debug for COMMANDS that don't equal this PC
#define REG_FLD_AR3D_PSEQ_DBG_CTL_COMMAND_PC(_) _(AR3D_PSEQ,DBG_CTL,COMMAND_PC,4,27,24,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DBG_CTL_COMMAND_PC(_)

// Initialize the qid that is inserted into spanstarts packets
// This must be set if lowering the MAX_QID field in the PIXATTR register
// 0 is a good value to set this to in that case.

// Register AR3D_PSEQ_QUAD_ID 
#define LIST_REG_FLD_AR3D_PSEQ_QUAD_ID(_) \
_(AR3D_PSEQ,QUAD_ID,INDEX)
#define REG_AR3D_PSEQ_QUAD_ID(_) _(AR3D_PSEQ,QUAD_ID,0x545,0x45,1,1,0xff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_PSEQ_QUAD_ID_INDEX(_) _(AR3D_PSEQ,QUAD_ID,INDEX,8,7,0,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_QUAD_ID_INDEX(_)

// INTERNAL register to keep the dwr_if control state in sync with the pixels
// that flow through the pipe

// Register AR3D_PSEQ_DWR_IF_STATE 
#define LIST_REG_FLD_AR3D_PSEQ_DWR_IF_STATE(_) \
_(AR3D_PSEQ,DWR_IF_STATE,START) \
_(AR3D_PSEQ,DWR_IF_STATE,COUNT) \
_(AR3D_PSEQ,DWR_IF_STATE,NEXT) \
_(AR3D_PSEQ,DWR_IF_STATE,NOT_LAST_EXE)
#define REG_AR3D_PSEQ_DWR_IF_STATE(_) _(AR3D_PSEQ,DWR_IF_STATE,0x546,0x46,1,1,0xfffff,0x0,NOARY,FLD)
//execute start
#define REG_FLD_AR3D_PSEQ_DWR_IF_STATE_START(_) _(AR3D_PSEQ,DWR_IF_STATE,START,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DWR_IF_STATE_START(_)

//execute count
#define REG_FLD_AR3D_PSEQ_DWR_IF_STATE_COUNT(_) _(AR3D_PSEQ,DWR_IF_STATE,COUNT,7,12,6,3,0x7f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DWR_IF_STATE_COUNT(_)

//execute next
#define REG_FLD_AR3D_PSEQ_DWR_IF_STATE_NEXT(_) _(AR3D_PSEQ,DWR_IF_STATE,NEXT,6,18,13,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DWR_IF_STATE_NEXT(_)

//pixels will not be retired at the end of this execute
#define REG_FLD_AR3D_PSEQ_DWR_IF_STATE_NOT_LAST_EXE(_) _(AR3D_PSEQ,DWR_IF_STATE,NOT_LAST_EXE,1,19,19,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_PSEQ_DWR_IF_STATE_NOT_LAST_EXE(_)

// --------------------------------------------------------------------------
// 
// Copyright (c) 2005, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// This spec file contains definitions relevant to the software view of the
// ATRAST processing stage.  Implementation details that are of no consequence
// to software can be found in ar3d_internal.spec.
//
// This file is included by ar3d.spec.
// 
// 
// ATRAST is loosely the attribute interpolator.  It logically fed from pixel
// data sent from QRAST that have lived past any early Z tests.  ATRAST is the
// stage where barycentric interpolants get massaged to yield perspective
// interpolation weights, where cubemapping setup is done, where higher order
// functions (like log, sin, sqrt) are performed, and ultimately where the
// vertex data is interpolated according to the barycentric weights to yield some
// intermediate value.  Because this unit is programmable there are a dizzying
// number of possible uses.  Typical use cases will be provided as a practical
// means of understanding total unit operation.
// 
// The ATRAST functional pipeline looks like this:
//     (0) Pixel packet of (R0,R1,R2,R3) arrives from PSEQ;
//         in parallel the pixel's 1/W value is computed.
//     (1) optional CUBEMAP permutation of R0..R2.
//     (2) optional MFU (Multi Function Unit) operation
//                      (recip, log, exp, sin, cos, sqrt, recipsqrt)
//     (3) optional two parallel multipliers with various sources/dests
//     (4) optional vertex attribute interpolation (IPA) stage
//     (5) pass (R0,R1,R2,R3) to TEX or recirculate to step 1 up to three times
// 
// The more detail explanation follows.
// 
// 
// ---- Instruction sequencing ----
// 
// Pixels flow through the pipeline in "pixel packets".  A given pixel is
// expressed in one to four rows of pixel data, with each row containing four
// 20 bit fields.  These fields hold either a 20 bit floating point value or two
// 10 bit fixed point values.  Other interpretations are used elsewhere in the
// pipeline, but ATRAST only deals with these two.  At any rate, the one to four
// rows of data logically constitute a pixel packet.
// 
// Like the other parts of the MG20 design, pixel packets may recirculate through
// multiple units multiple times in order to carry out a complex shader.  In
// order to keep track of things, each row of a pixel packet is assigned a
// sequence number.  A sequence number is unique to a given row and pass of a
// pixel packet, and is controlled by the global register PIX_ATTR.
// 
// ATRAST uses the sequence number to index the REMAP[] table.  The result of
// this indirection is an index into the ATRAST INST[] table along with a count
// of instructions, from zero to three.  When row has a zero instruction count
// it means that the row is unaffected by ATRAST; it still takes one clock to
// process such rows, and the advantage of having the zero encoding is that it
// doesn't take up any space in the INST[] instruction table.  When a row has
// an instruction count of one, it passes through ATRAST once and goes on to
// TEX.  If the count is more than one, the row is recirculated through the
// ATRAST unit before being sent off to TEX.  In effect it allows running macro
// sequences on a row without incurring the power expense of recirculating the
// pixel all the way through the back end of the 3D pipeline.
// 
// 
// ---- 1/W computation ----
// 
// QRAST feeds PSEQ, when then feeds ATRAST with pixel data, one row at a time.
// 
// Each pixel, no matter how many rows it may have, has an associated "1/w"
// value.  ATRAST computes this 1/w value for the pixel at hand with FP20
// precision, and this value is available for computations on any row of
// a pixel later in the ATRAST pipeline.  Logically it is a peer to the
// R0, R1, R2, R3 fields of the row.
// 
// If a row is recirculated through the ATRAST locally (because its sequence
// remapping table indicates the row has two or more instructions), this
// stage is NOT part of that recirculation. Specifically this means that
// barycentric coordinates A_PER and B_PER can only be computed in the first
// micropass.
// 
// ---- Cubemapping ----
// 
// This is the first step of the local recirculation loop.
// 
// If the CUBE field of INST[] is NOP, then this stage is skipped.
// If the CUBE field of INST[] is R0, then cubemapping is enabled.
// If either MUL multiplier references the I1 immediate, then the CUBE fie//
// Software reads and writes the REMAP[] table indirectly.
// REMAP_OFFSET supplies the table address and either REMAP_DATA or
// REMAP_DATA_4X access the table entry.
// INDEX auto-increments by one with each access to REMAP_DATA, and wraps
//       on overflow.
// INDEX auto-increments by four with each access to REMAP_DATA_4X, and wraps
//       on overflow.
// BASE is added to the REMAP_DATA and REMAP_DATA_4X OFFSET value(s) on writes.
// Reads to REMAP_DATA or REMAP_DATA_4X return result of addition at the time
//       of the last write to that INDEX.
//

// Register AR3D_AT_REMAP_OFFSET 
#define LIST_REG_FLD_AR3D_AT_REMAP_OFFSET(_) \
_(AR3D_AT,REMAP_OFFSET,INDEX) \
_(AR3D_AT,REMAP_OFFSET,BASE)
#define REG_AR3D_AT_REMAP_OFFSET(_) _(AR3D_AT,REMAP_OFFSET,0x600,0x0,1,1,0xfff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_AT_REMAP_OFFSET_INDEX(_) _(AR3D_AT,REMAP_OFFSET,INDEX,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_OFFSET_INDEX(_)

#define REG_FLD_AR3D_AT_REMAP_OFFSET_BASE(_) _(AR3D_AT,REMAP_OFFSET,BASE,6,11,6,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_OFFSET_BASE(_)

//
// Remap table - remaps packet sequence #'s to counts and offsets of real INST[]'s
//

// Register AR3D_AT_REMAP_DATA 
#define LIST_REG_FLD_AR3D_AT_REMAP_DATA(_) \
_(AR3D_AT,REMAP_DATA,COUNT) \
_(AR3D_AT,REMAP_DATA,OFFSET)
#define REG_AR3D_AT_REMAP_DATA(_) _(AR3D_AT,REMAP_DATA,0x601,0x1,1,1,0xff,0x0,NOARY,FLD)
// number of instructions on pixel rows with sequence
// number matching REMAP_OFFSET.INDEX, 0 to 3
#define REG_FLD_AR3D_AT_REMAP_DATA_COUNT(_) _(AR3D_AT,REMAP_DATA,COUNT,2,1,0,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_COUNT(_)

// INST[] index relative to pixel program;
// REMAP_OFFSET.BASE is added to this field on write,
// resulting in an absolute INST[] index.
#define REG_FLD_AR3D_AT_REMAP_DATA_OFFSET(_) _(AR3D_AT,REMAP_DATA,OFFSET,6,7,2,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_OFFSET(_)

//
// 4X Remap table - 4-at-a-time indirect port for remap tables (can be
// aligned at any REMAP_OFFSET INDEX value).  Like REMAP_DATA operation,
// writes into the OFFSET fields are automatically incremented by the
// current REMAP_OFFSET.BASE value.
//

// Register AR3D_AT_REMAP_DATA_4X 
#define LIST_REG_FLD_AR3D_AT_REMAP_DATA_4X(_) \
_(AR3D_AT,REMAP_DATA_4X,COUNT0) \
_(AR3D_AT,REMAP_DATA_4X,OFFSET0) \
_(AR3D_AT,REMAP_DATA_4X,COUNT1) \
_(AR3D_AT,REMAP_DATA_4X,OFFSET1) \
_(AR3D_AT,REMAP_DATA_4X,COUNT2) \
_(AR3D_AT,REMAP_DATA_4X,OFFSET2) \
_(AR3D_AT,REMAP_DATA_4X,COUNT3) \
_(AR3D_AT,REMAP_DATA_4X,OFFSET3)
#define REG_AR3D_AT_REMAP_DATA_4X(_) _(AR3D_AT,REMAP_DATA_4X,0x602,0x2,1,1,0xffffffff,0x0,NOARY,FLD)
// number of instructions on row REMAP_OFFSET.INDEX+0
#define REG_FLD_AR3D_AT_REMAP_DATA_4X_COUNT0(_) _(AR3D_AT,REMAP_DATA_4X,COUNT0,2,1,0,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_4X_COUNT0(_)

// INST[] index, relative to pixel program
#define REG_FLD_AR3D_AT_REMAP_DATA_4X_OFFSET0(_) _(AR3D_AT,REMAP_DATA_4X,OFFSET0,6,7,2,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_4X_OFFSET0(_)

// number of instructions on row REMAP_OFFSET.INDEX+1
#define REG_FLD_AR3D_AT_REMAP_DATA_4X_COUNT1(_) _(AR3D_AT,REMAP_DATA_4X,COUNT1,2,9,8,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_4X_COUNT1(_)

// INST[] index, relative to pixel program
#define REG_FLD_AR3D_AT_REMAP_DATA_4X_OFFSET1(_) _(AR3D_AT,REMAP_DATA_4X,OFFSET1,6,15,10,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_4X_OFFSET1(_)

// number of instructions on row REMAP_OFFSET.INDEX+2
#define REG_FLD_AR3D_AT_REMAP_DATA_4X_COUNT2(_) _(AR3D_AT,REMAP_DATA_4X,COUNT2,2,17,16,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_4X_COUNT2(_)

// INST[] index, relative to pixel program
#define REG_FLD_AR3D_AT_REMAP_DATA_4X_OFFSET2(_) _(AR3D_AT,REMAP_DATA_4X,OFFSET2,6,23,18,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_4X_OFFSET2(_)

// number of instructions on row REMAP_OFFSET.INDEX+3
#define REG_FLD_AR3D_AT_REMAP_DATA_4X_COUNT3(_) _(AR3D_AT,REMAP_DATA_4X,COUNT3,2,25,24,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_4X_COUNT3(_)

// INST[] index, relative to pixel program
#define REG_FLD_AR3D_AT_REMAP_DATA_4X_OFFSET3(_) _(AR3D_AT,REMAP_DATA_4X,OFFSET3,6,31,26,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_REMAP_DATA_4X_OFFSET3(_)

//
// Software reads and writes the INST[] table indirectly.
// INST_OFFSET.INDEX supplies the table address when INST_DATA is accessed
// for both reads and writes.
// INDEX auto-increments with each access to INST_DATA.
// This register will also update the BASE field of REMAP_OFFSET
//      this update will divide the INDEX from INST_OFFSET by the number of words
//      in an single logical alu instruction 
//      (NV_GR3D_ALU_INST_NUM_WORDS * NV_GR3D_NUM_ALUS) 
//

// Register AR3D_AT_INST_OFFSET 
#define LIST_REG_FLD_AR3D_AT_INST_OFFSET(_) \
_(AR3D_AT,INST_OFFSET,INDEX)
#define REG_AR3D_AT_INST_OFFSET(_) _(AR3D_AT,INST_OFFSET,0x603,0x3,1,1,0x7f,0x0,NOARY,FLD)
#define REG_FLD_AR3D_AT_INST_OFFSET_INDEX(_) _(AR3D_AT,INST_OFFSET,INDEX,7,6,0,3,0x7f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_OFFSET_INDEX(_)

// MFU operation can be bypassed by selecting FUNC==NOP, in which case the
// SRC_DST field is moot.
//
// When FUNC != NOP, SRC_DST selects both the input to the MFU as well as
// where the results are saved.
//
// The FUNC mnemonics are pretty terse, so here they are expanded:
//     NOP       no operation, suppressing MFU
//     RCP       reciprocal
//     RSQRT     reciprocal square root
//     LOG2      log base 2
//     EXP2      exponential (power of two)
//     SQRT      square root
//     SIN       sine
//     COS       cosine
//     FRC       fraction, (x-floor(x))
//     EXP2RRO   range reduction for companion EXP2
//     SINRRO    range reduction for companion SIN
//     COSRRO    range reduction for companion COS

// Packet AR3D_AT_FUNC
#define LIST_PKT_FLD_AR3D_AT_FUNC(_) \
_(AR3D_AT_FUNC,SRC_DST) \
_(AR3D_AT_FUNC,FUNC)
#define PKT_AR3D_AT_FUNC(_) _(AR3D_AT_FUNC,7,FLD)
// source and destination
#define PKT_FLD_AR3D_AT_FUNC_SRC_DST(_) _(AR3D_AT_FUNC,SRC_DST,0,3,6,4,0x7,ENM)
#define LIST_PKT_ENM_AR3D_AT_FUNC_SRC_DST(_) \
_(AR3D_AT_FUNC,SRC_DST,R0,0) \
_(AR3D_AT_FUNC,SRC_DST,R1,1) \
_(AR3D_AT_FUNC,SRC_DST,R2,2) \
_(AR3D_AT_FUNC,SRC_DST,R3,3) \
_(AR3D_AT_FUNC,SRC_DST,W,4)
// the function to compute
#define PKT_FLD_AR3D_AT_FUNC_FUNC(_) _(AR3D_AT_FUNC,FUNC,0,4,3,0,0xf,ENM)
#define LIST_PKT_ENM_AR3D_AT_FUNC_FUNC(_) \
_(AR3D_AT_FUNC,FUNC,NOP,0) \
_(AR3D_AT_FUNC,FUNC,RCP,1) \
_(AR3D_AT_FUNC,FUNC,RSQRT,2) \
_(AR3D_AT_FUNC,FUNC,LOG2,3) \
_(AR3D_AT_FUNC,FUNC,EXP2,4) \
_(AR3D_AT_FUNC,FUNC,SQRT,5) \
_(AR3D_AT_FUNC,FUNC,SIN,6) \
_(AR3D_AT_FUNC,FUNC,COS,7) \
_(AR3D_AT_FUNC,FUNC,FRC,8) \
_(AR3D_AT_FUNC,FUNC,EXP2RRO,9) \
_(AR3D_AT_FUNC,FUNC,SINRRO,10) \
_(AR3D_AT_FUNC,FUNC,COSRRO,11)
// For each multiplier, specify the two inputs come from and where the results
// are saved.
//
// DST:
//     NOP     specifying this disables the multiplier altogther and does
//             not change any state.  it also saves power.
//     PER     when the MUL.0 multiplier specifies this, its result is saved
//             in the ALPHA register; when MUL.1 specifies it its results are
//             saved in the BETA register.  These two values are used by the
//             IPA stage as interpolation weights when performing perspective
//             correct interpolation.
//     R0..R3  specifying one of these saves the result into one of the four
//             FP20 fields of the current pixel row.
//
// SRC0 and SRC1:
//     R0..R3  are the four FP20 fields of the current pixel row
//     C0..C3  are the four FP20 constant registers (CONSTANT0[])
//     I0..I1  are the two FP20 immediates.  If I0 is present, then the IPAs
//             are implicitly NOP'd.  If I1 is present, then the IPAs, the
//             CUBE function, and the MFU FUNC are all implicitly NOP'd,
//             as these fields hold the one or two FP20 immediates.
//     W       is the output of the MFU unit when it processes the 1/w value
//             from the barycentric steppers.  reading from this register is
//             invalid unless the MFU computed the result in the same logical
//             instruction.  Another way to state it is it is stateless; it
//             does not persist across instructions.
//     ALPHA   is the barycentric alpha weight (a(x,y)/w0) associated with
//             the current pixel.  Typcally this value is multiplied by W
//             and stored into the interpolation weight register.
//             It may be used only with SRC1.
//     BETA    is the barycentric beta weight (b(x,y)/w1) associated with
//             the current pixel.  Typcally this value is multiplied by W
//             and stored into the interpolation weight register.
//             It may be used only with SRC1.
//     ONE     is the FP20 constant 1.0, accurate to more than 1000 digits

// Packet AR3D_AT_MUL
#define LIST_PKT_FLD_AR3D_AT_MUL(_) \
_(AR3D_AT_MUL,DST) \
_(AR3D_AT_MUL,SRC1) \
_(AR3D_AT_MUL,SRC0)
#define PKT_AR3D_AT_MUL(_) _(AR3D_AT_MUL,11,FLD)
// destination of the mul
#define PKT_FLD_AR3D_AT_MUL_DST(_) _(AR3D_AT_MUL,DST,0,3,10,8,0x7,ENM)
#define LIST_PKT_ENM_AR3D_AT_MUL_DST(_) \
_(AR3D_AT_MUL,DST,NOP,0) \
_(AR3D_AT_MUL,DST,PER,1) \
_(AR3D_AT_MUL,DST,R0,4) \
_(AR3D_AT_MUL,DST,R1,5) \
_(AR3D_AT_MUL,DST,R2,6) \
_(AR3D_AT_MUL,DST,R3,7)
// one of the 2 sources of the mul
#define PKT_FLD_AR3D_AT_MUL_SRC1(_) _(AR3D_AT_MUL,SRC1,0,4,7,4,0xf,ENM)
#define LIST_PKT_ENM_AR3D_AT_MUL_SRC1(_) \
_(AR3D_AT_MUL,SRC1,R0,0) \
_(AR3D_AT_MUL,SRC1,R1,1) \
_(AR3D_AT_MUL,SRC1,R2,2) \
_(AR3D_AT_MUL,SRC1,R3,3) \
_(AR3D_AT_MUL,SRC1,C0,4) \
_(AR3D_AT_MUL,SRC1,C1,5) \
_(AR3D_AT_MUL,SRC1,C2,6) \
_(AR3D_AT_MUL,SRC1,C3,7) \
_(AR3D_AT_MUL,SRC1,I0,8) \
_(AR3D_AT_MUL,SRC1,I1,9) \
_(AR3D_AT_MUL,SRC1,W,10) \
_(AR3D_AT_MUL,SRC1,ALPHA,11) \
_(AR3D_AT_MUL,SRC1,BETA,12) \
_(AR3D_AT_MUL,SRC1,ONE,13)
// the other source
// ALPHA and BETA are going away here
#define PKT_FLD_AR3D_AT_MUL_SRC0(_) _(AR3D_AT_MUL,SRC0,0,4,3,0,0xf,ENM)
#define LIST_PKT_ENM_AR3D_AT_MUL_SRC0(_) \
_(AR3D_AT_MUL,SRC0,R0,0) \
_(AR3D_AT_MUL,SRC0,R1,1) \
_(AR3D_AT_MUL,SRC0,R2,2) \
_(AR3D_AT_MUL,SRC0,R3,3) \
_(AR3D_AT_MUL,SRC0,C0,4) \
_(AR3D_AT_MUL,SRC0,C1,5) \
_(AR3D_AT_MUL,SRC0,C2,6) \
_(AR3D_AT_MUL,SRC0,C3,7) \
_(AR3D_AT_MUL,SRC0,I0,8) \
_(AR3D_AT_MUL,SRC0,I1,9) \
_(AR3D_AT_MUL,SRC0,W,10) \
_(AR3D_AT_MUL,SRC0,ALPHA,11) \
_(AR3D_AT_MUL,SRC0,BETA,12) \
_(AR3D_AT_MUL,SRC0,ONE,13)
// For each interpolator, specify which set of interpolating weights to use,
// which parameter set to use from the TRAM, and what style of interpolation
// to perform for this bank.
//
// ENTRY:
//    This specifies which attribute to interpolate from the TRAM table.
//    The value is not an absolute TRAM[] index, but rather an offset from
//    the start of the data for that triangle.  The value must be less than
//    or equal to the value programmed into the global register TRI_ATTR,
//    field TRI_ROWS.
//
// PREC:
//    000 = NOP     = no computation/no result
//    001 = ZP      = evaluate fixed point (0.20) Z plane equation
//    010 = HPS     = one high precision interpolation with saturation
//    011 = HPC     = one high precision interpolation with clamping
//    100 = LPS_LPS = two low precision interpolations, with
//                    the high FX10 saturating and the low FX10 saturating
//    101 = LPS_LPC = two low precision interpolations, with
//                    the high FX10 saturating and the low FX10 clamping
//    110 = LPC_LPS = two low precision interpolations, with
//                    the high FX10 clamping and the low FX10 saturating
//    111 = LPC_LPS = two low precision interpolations, with
//                    the high FX10 clamping and the low FX10 clamping

// Packet AR3D_AT_IPA
#define LIST_PKT_FLD_AR3D_AT_IPA(_) \
_(AR3D_AT_IPA,ENTRY) \
_(AR3D_AT_IPA,PREC)
#define PKT_AR3D_AT_IPA(_) _(AR3D_AT_IPA,7,FLD)
// which of 16 TRAM[] entries to use
#define PKT_FLD_AR3D_AT_IPA_ENTRY(_) _(AR3D_AT_IPA,ENTRY,0,4,6,3,0xf,NOENM)
#define LIST_PKT_ENM_AR3D_AT_IPA_ENTRY(_)
// selecects precision and saturation modes
#define PKT_FLD_AR3D_AT_IPA_PREC(_) _(AR3D_AT_IPA,PREC,0,3,2,0,0x7,ENM)
#define LIST_PKT_ENM_AR3D_AT_IPA_PREC(_) \
_(AR3D_AT_IPA,PREC,NOP,0) \
_(AR3D_AT_IPA,PREC,ZP,1) \
_(AR3D_AT_IPA,PREC,HPS,2) \
_(AR3D_AT_IPA,PREC,HPC,3) \
_(AR3D_AT_IPA,PREC,LPS_LPS,4) \
_(AR3D_AT_IPA,PREC,LPS_LPC,5) \
_(AR3D_AT_IPA,PREC,LPC_LPS,6) \
_(AR3D_AT_IPA,PREC,LPC_LPC,7)
//
// Instruction indirect port.
// Instructions use variant encodings within one register spec to allow
// single instructions to be pairs of adjacent writes.
// The actual INST[] entry accessed is supplied by INST_OFFSET.INDEX,
// which is incremented after each access to INST_DATA.
//
// The fields below are a union of different uses.  The logical instruction
// is 64 bits wide.  The low (even) word controls the everything except for
// the IPA units; the high (odd) word controls the four IPA units.  However,
// some of these fields get overloaded with immediate data values for use
// by the MUL units, which is what the IMM0, IMM1L, IMM1H subfields are
// specifying.
//

// Register AR3D_AT_INST_DATA // EVEN INDEX values in INST_OFFSET
#define LIST_REG_FLD_AR3D_AT_INST_DATA(_) \
_(AR3D_AT,INST_DATA,DATA0) \
_(AR3D_AT,INST_DATA,IMM1H) \
_(AR3D_AT,INST_DATA,CUBE) \
_(AR3D_AT,INST_DATA,FUNC) \
_(AR3D_AT,INST_DATA,MUL1) \
_(AR3D_AT,INST_DATA,MUL0) \
_(AR3D_AT,INST_DATA,DATA1) \
_(AR3D_AT,INST_DATA,IMM1L) \
_(AR3D_AT,INST_DATA,IMM0) \
_(AR3D_AT,INST_DATA,IPA3) \
_(AR3D_AT,INST_DATA,IPA2) \
_(AR3D_AT,INST_DATA,IPA1) \
_(AR3D_AT,INST_DATA,IPA0)
#define REG_AR3D_AT_INST_DATA(_) _(AR3D_AT,INST_DATA,0x604,0x4,1,1,0xffffffff,0x0,NOARY,FLD)
// Data field for Even Instructions 
#define REG_FLD_AR3D_AT_INST_DATA_DATA0(_) _(AR3D_AT,INST_DATA,DATA0,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_DATA0(_)

// high half of MUL I1 FP20 immediate
#define REG_FLD_AR3D_AT_INST_DATA_IMM1H(_) _(AR3D_AT,INST_DATA,IMM1H,10,31,22,3,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_IMM1H(_)

// Cubemap enable (R0 means enabled)
#define REG_FLD_AR3D_AT_INST_DATA_CUBE(_) _(AR3D_AT,INST_DATA,CUBE,1,29,29,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_CUBE(_) \
_(AR3D_AT,INST_DATA,CUBE,NOP,0) \
_(AR3D_AT,INST_DATA,CUBE,R0,1)
#define AR3D_AT_INST_DATA_CUBE_NOP                      _MK_ENUM_CONST(0)
#define AR3D_AT_INST_DATA_CUBE_R0                       _MK_ENUM_CONST(1)

// transcendental function (AR3D_AT_FUNC)
#define REG_FLD_AR3D_AT_INST_DATA_FUNC(_) _(AR3D_AT,INST_DATA,FUNC,7,28,22,3,0x7f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_FUNC(_)

// multiply (AR3D_AT_MUL)
#define REG_FLD_AR3D_AT_INST_DATA_MUL1(_) _(AR3D_AT,INST_DATA,MUL1,11,21,11,3,0x7ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_MUL1(_)

// multiply (AR3D_AT_MUL)
// ODD INDEX values in INST_OFFSET
#define REG_FLD_AR3D_AT_INST_DATA_MUL0(_) _(AR3D_AT,INST_DATA,MUL0,11,10,0,3,0x7ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_MUL0(_)

// Data field for Odd Instructions
#define REG_FLD_AR3D_AT_INST_DATA_DATA1(_) _(AR3D_AT,INST_DATA,DATA1,30,29,0,3,0x3fffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_DATA1(_)

// low half of MUL I1 FP20 immediate
#define REG_FLD_AR3D_AT_INST_DATA_IMM1L(_) _(AR3D_AT,INST_DATA,IMM1L,10,29,20,3,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_IMM1L(_)

// MUL I0 FP20 immediate
#define REG_FLD_AR3D_AT_INST_DATA_IMM0(_) _(AR3D_AT,INST_DATA,IMM0,20,19,0,3,0xfffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_IMM0(_)

// attribute interpolation controls (AR3D_AT_IPA)
#define REG_FLD_AR3D_AT_INST_DATA_IPA3(_) _(AR3D_AT,INST_DATA,IPA3,7,27,21,3,0x7f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_IPA3(_)

// attribute interpolation controls (AR3D_AT_IPA)
#define REG_FLD_AR3D_AT_INST_DATA_IPA2(_) _(AR3D_AT,INST_DATA,IPA2,7,20,14,3,0x7f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_IPA2(_)

// attribute interpolation controls (AR3D_AT_IPA)
#define REG_FLD_AR3D_AT_INST_DATA_IPA1(_) _(AR3D_AT,INST_DATA,IPA1,7,13,7,3,0x7f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_IPA1(_)

// attribute interpolation controls (AR3D_AT_IPA)
#define REG_FLD_AR3D_AT_INST_DATA_IPA0(_) _(AR3D_AT,INST_DATA,IPA0,7,6,0,3,0x7f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_INST_DATA_IPA0(_)

// number of CONST registers available to the multiplier stage in ATRAST
// The constant registers are available for feeding to the MUL inputs.
// Sometimes they are referred to in shorthand as C0 .. Cn.
// Each holds a single FP20 value.

// Register AR3D_AT_CONSTANT0 
#define LIST_REG_FLD_AR3D_AT_CONSTANT0(_) \
_(AR3D_AT,CONSTANT0,VAL)
#define REG_AR3D_AT_CONSTANT0(_) _(AR3D_AT,CONSTANT0,0x608,0x8,4,1,0xfffff,0x0,ARY,FLD)
// RAST_R format, same as pixel packet registers
#define REG_FLD_AR3D_AT_CONSTANT0_VAL(_) _(AR3D_AT,CONSTANT0,VAL,20,19,0,3,0xfffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_CONSTANT0_VAL(_)

// HACK HACK HACK replaced this with project.spec values
//
// The TRAM (Triangle RAM) file is accessed indirectly by software.
// TRAM_OFFSET.INDEX supplies the TRAM[] index whenever TRAM_DATA is accessed
// by software, after which it auto increments by one.
//

// Register AR3D_AT_TRAM_OFFSET 
#define LIST_REG_FLD_AR3D_AT_TRAM_OFFSET(_) \
_(AR3D_AT,TRAM_OFFSET,INDEX)
#define REG_AR3D_AT_TRAM_OFFSET(_) _(AR3D_AT,TRAM_OFFSET,0x60c,0xc,1,1,0x1ff,0x0,NOARY,FLD)
// current read or write target in TRAM[]
#define REG_FLD_AR3D_AT_TRAM_OFFSET_INDEX(_) _(AR3D_AT,TRAM_OFFSET,INDEX,9,8,0,3,0x1ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_TRAM_OFFSET_INDEX(_)

//
// TRAM_DATA is the register to for accessing the TRAM[] array, after which
// the TRAM_OFFSET.INDEX field increments by one.
// The format of TRAM_DATA is opaque to software, but is defined by TRAM_BF_ZP,
// TRAM_BF_HP, TRAM_BF_LP if you must know.
// 

// Register AR3D_AT_TRAM_DATA 
#define LIST_REG_FLD_AR3D_AT_TRAM_DATA(_) \
_(AR3D_AT,TRAM_DATA,VAL)
#define REG_AR3D_AT_TRAM_DATA(_) _(AR3D_AT,TRAM_DATA,0x60d,0xd,1,1,0xffffffff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_AT_TRAM_DATA_VAL(_) _(AR3D_AT,TRAM_DATA,VAL,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_AT_TRAM_DATA_VAL(_)

// Second-level clock enable override register
//
// This can override the 2nd level clock enables in case of malfunction.
// Only exposed to software when needed.
//

// Register AR3D_AT_CLKEN_OVERRIDE 
#define LIST_REG_FLD_AR3D_AT_CLKEN_OVERRIDE(_) \
_(AR3D_AT,CLKEN_OVERRIDE,CORE_CLKEN_OVR) \
_(AR3D_AT,CLKEN_OVERRIDE,SLOPES_CLKEN_OVR) \
_(AR3D_AT,CLKEN_OVERRIDE,TRAM_CLKEN_OVR) \
_(AR3D_AT,CLKEN_OVERRIDE,BARY_CLKEN_OVR) \
_(AR3D_AT,CLKEN_OVERRIDE,ONEOVERW_CLKEN_OVR) \
_(AR3D_AT,CLKEN_OVERRIDE,MFU_CLKEN_OVR) \
_(AR3D_AT,CLKEN_OVERRIDE,MULABS_CLKEN_OVR) \
_(AR3D_AT,CLKEN_OVERRIDE,IPAS_CLKEN_OVR)
#define REG_AR3D_AT_CLKEN_OVERRIDE(_) _(AR3D_AT,CLKEN_OVERRIDE,0x60e,0xe,1,1,0xff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_AT_CLKEN_OVERRIDE_CORE_CLKEN_OVR(_) _(AR3D_AT,CLKEN_OVERRIDE,CORE_CLKEN_OVR,1,0,0,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_AT_CLKEN_OVERRIDE_CORE_CLKEN_OVR(_) \
_(AR3D_AT,CLKEN_OVERRIDE,CORE_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_AT,CLKEN_OVERRIDE,CORE_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_AT_CLKEN_OVERRIDE_CORE_CLKEN_OVR_CLK_GATED                 _MK_ENUM_CONST(0)
#define AR3D_AT_CLKEN_OVERRIDE_CORE_CLKEN_OVR_CLK_ALWAYS_ON                     _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_AT_CLKEN_OVERRIDE_SLOPES_CLKEN_OVR(_) _(AR3D_AT,CLKEN_OVERRIDE,SLOPES_CLKEN_OVR,1,1,1,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_AT_CLKEN_OVERRIDE_SLOPES_CLKEN_OVR(_) \
_(AR3D_AT,CLKEN_OVERRIDE,SLOPES_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_AT,CLKEN_OVERRIDE,SLOPES_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_AT_CLKEN_OVERRIDE_SLOPES_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_AT_CLKEN_OVERRIDE_SLOPES_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_AT_CLKEN_OVERRIDE_TRAM_CLKEN_OVR(_) _(AR3D_AT,CLKEN_OVERRIDE,TRAM_CLKEN_OVR,1,2,2,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_AT_CLKEN_OVERRIDE_TRAM_CLKEN_OVR(_) \
_(AR3D_AT,CLKEN_OVERRIDE,TRAM_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_AT,CLKEN_OVERRIDE,TRAM_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_AT_CLKEN_OVERRIDE_TRAM_CLKEN_OVR_CLK_GATED                 _MK_ENUM_CONST(0)
#define AR3D_AT_CLKEN_OVERRIDE_TRAM_CLKEN_OVR_CLK_ALWAYS_ON                     _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_AT_CLKEN_OVERRIDE_BARY_CLKEN_OVR(_) _(AR3D_AT,CLKEN_OVERRIDE,BARY_CLKEN_OVR,1,3,3,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_AT_CLKEN_OVERRIDE_BARY_CLKEN_OVR(_) \
_(AR3D_AT,CLKEN_OVERRIDE,BARY_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_AT,CLKEN_OVERRIDE,BARY_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_AT_CLKEN_OVERRIDE_BARY_CLKEN_OVR_CLK_GATED                 _MK_ENUM_CONST(0)
#define AR3D_AT_CLKEN_OVERRIDE_BARY_CLKEN_OVR_CLK_ALWAYS_ON                     _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_AT_CLKEN_OVERRIDE_ONEOVERW_CLKEN_OVR(_) _(AR3D_AT,CLKEN_OVERRIDE,ONEOVERW_CLKEN_OVR,1,4,4,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_AT_CLKEN_OVERRIDE_ONEOVERW_CLKEN_OVR(_) \
_(AR3D_AT,CLKEN_OVERRIDE,ONEOVERW_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_AT,CLKEN_OVERRIDE,ONEOVERW_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_AT_CLKEN_OVERRIDE_ONEOVERW_CLKEN_OVR_CLK_GATED                     _MK_ENUM_CONST(0)
#define AR3D_AT_CLKEN_OVERRIDE_ONEOVERW_CLKEN_OVR_CLK_ALWAYS_ON                 _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_AT_CLKEN_OVERRIDE_MFU_CLKEN_OVR(_) _(AR3D_AT,CLKEN_OVERRIDE,MFU_CLKEN_OVR,1,5,5,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_AT_CLKEN_OVERRIDE_MFU_CLKEN_OVR(_) \
_(AR3D_AT,CLKEN_OVERRIDE,MFU_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_AT,CLKEN_OVERRIDE,MFU_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_AT_CLKEN_OVERRIDE_MFU_CLKEN_OVR_CLK_GATED                  _MK_ENUM_CONST(0)
#define AR3D_AT_CLKEN_OVERRIDE_MFU_CLKEN_OVR_CLK_ALWAYS_ON                      _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_AT_CLKEN_OVERRIDE_MULABS_CLKEN_OVR(_) _(AR3D_AT,CLKEN_OVERRIDE,MULABS_CLKEN_OVR,1,6,6,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_AT_CLKEN_OVERRIDE_MULABS_CLKEN_OVR(_) \
_(AR3D_AT,CLKEN_OVERRIDE,MULABS_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_AT,CLKEN_OVERRIDE,MULABS_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_AT_CLKEN_OVERRIDE_MULABS_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_AT_CLKEN_OVERRIDE_MULABS_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_AT_CLKEN_OVERRIDE_IPAS_CLKEN_OVR(_) _(AR3D_AT,CLKEN_OVERRIDE,IPAS_CLKEN_OVR,1,7,7,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_AT_CLKEN_OVERRIDE_IPAS_CLKEN_OVR(_) \
_(AR3D_AT,CLKEN_OVERRIDE,IPAS_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_AT,CLKEN_OVERRIDE,IPAS_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_AT_CLKEN_OVERRIDE_IPAS_CLKEN_OVR_CLK_GATED                 _MK_ENUM_CONST(0)
#define AR3D_AT_CLKEN_OVERRIDE_IPAS_CLKEN_OVR_CLK_ALWAYS_ON                     _MK_ENUM_CONST(1)

// --------------------------------------------------------------------------
//
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// =========================================================================
// TEX instruction registers
// =========================================================================
//
// Instruction table offset: controls what indirect entry in the instruction table gets accessed.
// INDEX auto-increments with each access to INST_DATA.
//

// Register AR3D_TEX_INST_OFFSET 
#define LIST_REG_FLD_AR3D_TEX_INST_OFFSET(_) \
_(AR3D_TEX,INST_OFFSET,INDEX)
#define REG_AR3D_TEX_INST_OFFSET(_) _(AR3D_TEX,INST_OFFSET,0x700,0x0,1,1,0x3f,0x0,NOARY,FLD)
// current read or write target in INST_DATA
#define REG_FLD_AR3D_TEX_INST_OFFSET_INDEX(_) _(AR3D_TEX,INST_OFFSET,INDEX,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_INST_OFFSET_INDEX(_)

// The TEX instruction defines a texture fetch. The instruction also
// gives control over some of the details of these operations.
//
// The instructions performed, and the order they are performed, is determined
// by the global register PIX_ATTR.
//
//    * The texel addressed by the (s,t) or (s,t,r/face) tuple present in the
//      field indexed by REG_SRC on the surface indexed by SURF_PTR will be
//      fetched and passed to the ALUs in the field indexed by REG_DST.
//
//      What distinguishes a TEX fetch from a COLOR fetch in DF are the
//      following differences:
//          + mipmapped texture surfaces must be a power of two in size;
//            unmipmapped or color surfaces can have an arbitrary size (other
//            than alignment restrictions.)
//          + texture fetches allow a number of filtering options;
//            color fetches are always point sampled.
//          + texture fetches are derived from the calculated (s,t) coords;
//            color fetches are addressed by the (x,y) coords of the pixel
//          + texture fetches are cached and there is no memory coherence
//            with other writes occuring in the system, so writes to texture
//            surfaces must be very controlled;
//
//    * The resulting (A)RGB value is
//      expanded to a {4 x s1.8} format and is stored into the registers
//      selected by REG_DST.  Note that the component values are mapped such
//      that a pixel value of 0x00 is mapped to 0.00 and 0xFF is mapped to
//      +1.00.  The values in between are only guaranteed to be monotonically
//      increasing.
//
//      The table below indicates which color channels go to which register
//      fields in the RAST_R packet:
//
//          REG_DST==R0R1: red   -> R0, low
//                         green -> R0, high
//                         blue  -> R1, low
//                         alpha -> R1, high
//
//          REG_DST==R2R3: red   -> R2, low
//                         green -> R2, high
//                         blue  -> R3, low
//                         alpha -> R3, high
// Restrictions:
//    * The mapping of the 8b color component value to s1.8 format is done
//      by incrementing any values >= 0x80 by 1 (equivalent to *256/255)
//      Thus, 0x80 will never be produced by the process.
//
//    * If trilinear filtering is enabled (LERP_MIP) for an instruction,
//      the instruction takes two cycles instead of one.  If the pipeline
//      determines that bilinear filtering will be equivalent to trilinear
//      filtering, bilinear filtering will be done instead, taking a single
//      cycle (this happens when the LOD fraction is close to zero).
//
//    * If a surface surface is of type DXT1/3/5, the COLOR_KEY field should
//      be set to DISABLE as this operations makes no sense.

// Register AR3D_TEX_INST_DATA 
#define LIST_REG_FLD_AR3D_TEX_INST_DATA(_) \
_(AR3D_TEX,INST_DATA,USER_LOD) \
_(AR3D_TEX,INST_DATA,USER_LOD_BIAS) \
_(AR3D_TEX,INST_DATA,FETCH_KILLED) \
_(AR3D_TEX,INST_DATA,FETCH) \
_(AR3D_TEX,INST_DATA,COMP_SEL) \
_(AR3D_TEX,INST_DATA,COLOR_KEY) \
_(AR3D_TEX,INST_DATA,REG_DST) \
_(AR3D_TEX,INST_DATA,REG_SRC) \
_(AR3D_TEX,INST_DATA,SURF_PTR)
#define REG_AR3D_TEX_INST_DATA(_) _(AR3D_TEX,INST_DATA,0x701,0x1,1,1,0x3cff,0x0,NOARY,FLD)
// whether user specified lod is provided in a register
#define REG_FLD_AR3D_TEX_INST_DATA_USER_LOD(_) _(AR3D_TEX,INST_DATA,USER_LOD,1,13,13,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_INST_DATA_USER_LOD(_) \
_(AR3D_TEX,INST_DATA,USER_LOD,DISABLE,0) \
_(AR3D_TEX,INST_DATA,USER_LOD,ENABLE,1)
#define AR3D_TEX_INST_DATA_USER_LOD_DISABLE                     _MK_ENUM_CONST(0)
#define AR3D_TEX_INST_DATA_USER_LOD_ENABLE                      _MK_ENUM_CONST(1)

// whether lod bias is provided in a register
#define REG_FLD_AR3D_TEX_INST_DATA_USER_LOD_BIAS(_) _(AR3D_TEX,INST_DATA,USER_LOD_BIAS,1,12,12,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_INST_DATA_USER_LOD_BIAS(_) \
_(AR3D_TEX,INST_DATA,USER_LOD_BIAS,DISABLE,0) \
_(AR3D_TEX,INST_DATA,USER_LOD_BIAS,ENABLE,1)
#define AR3D_TEX_INST_DATA_USER_LOD_BIAS_DISABLE                        _MK_ENUM_CONST(0)
#define AR3D_TEX_INST_DATA_USER_LOD_BIAS_ENABLE                 _MK_ENUM_CONST(1)

// whether to fetch killed pixels.  Must be enabled when
// dependent texturing is on and LOD is required, and
// when derivative calculations are made
#define REG_FLD_AR3D_TEX_INST_DATA_FETCH_KILLED(_) _(AR3D_TEX,INST_DATA,FETCH_KILLED,1,11,11,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_INST_DATA_FETCH_KILLED(_) \
_(AR3D_TEX,INST_DATA,FETCH_KILLED,DISABLE,0) \
_(AR3D_TEX,INST_DATA,FETCH_KILLED,ENABLE,1)
#define AR3D_TEX_INST_DATA_FETCH_KILLED_DISABLE                 _MK_ENUM_CONST(0)
#define AR3D_TEX_INST_DATA_FETCH_KILLED_ENABLE                  _MK_ENUM_CONST(1)

// whether to fetch at all
#define REG_FLD_AR3D_TEX_INST_DATA_FETCH(_) _(AR3D_TEX,INST_DATA,FETCH,1,10,10,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_INST_DATA_FETCH(_) \
_(AR3D_TEX,INST_DATA,FETCH,DISABLE,0) \
_(AR3D_TEX,INST_DATA,FETCH,ENABLE,1)
#define AR3D_TEX_INST_DATA_FETCH_DISABLE                        _MK_ENUM_CONST(0)
#define AR3D_TEX_INST_DATA_FETCH_ENABLE                 _MK_ENUM_CONST(1)

// which 2 components of R16G16B16A16_float to read, if applicable
#define REG_FLD_AR3D_TEX_INST_DATA_COMP_SEL(_) _(AR3D_TEX,INST_DATA,COMP_SEL,1,7,7,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_INST_DATA_COMP_SEL(_) \
_(AR3D_TEX,INST_DATA,COMP_SEL,RG,0) \
_(AR3D_TEX,INST_DATA,COMP_SEL,BA,1)
#define AR3D_TEX_INST_DATA_COMP_SEL_RG                  _MK_ENUM_CONST(0)
#define AR3D_TEX_INST_DATA_COMP_SEL_BA                  _MK_ENUM_CONST(1)

// Enable ColorKey.  Must disable for DXT1/3/5 formats.
#define REG_FLD_AR3D_TEX_INST_DATA_COLOR_KEY(_) _(AR3D_TEX,INST_DATA,COLOR_KEY,1,6,6,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_INST_DATA_COLOR_KEY(_) \
_(AR3D_TEX,INST_DATA,COLOR_KEY,DISABLE,0) \
_(AR3D_TEX,INST_DATA,COLOR_KEY,ENABLE,1)
#define AR3D_TEX_INST_DATA_COLOR_KEY_DISABLE                    _MK_ENUM_CONST(0)
#define AR3D_TEX_INST_DATA_COLOR_KEY_ENABLE                     _MK_ENUM_CONST(1)

// reg receiving result of texture fetch
#define REG_FLD_AR3D_TEX_INST_DATA_REG_DST(_) _(AR3D_TEX,INST_DATA,REG_DST,1,5,5,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_INST_DATA_REG_DST(_) \
_(AR3D_TEX,INST_DATA,REG_DST,R0R1,0) \
_(AR3D_TEX,INST_DATA,REG_DST,R2R3,1)
#define AR3D_TEX_INST_DATA_REG_DST_R0R1                 _MK_ENUM_CONST(0)
#define AR3D_TEX_INST_DATA_REG_DST_R2R3                 _MK_ENUM_CONST(1)

// reg containing S, T (and R/face, if applicable) coordinates
#define REG_FLD_AR3D_TEX_INST_DATA_REG_SRC(_) _(AR3D_TEX,INST_DATA,REG_SRC,1,4,4,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_INST_DATA_REG_SRC(_) \
_(AR3D_TEX,INST_DATA,REG_SRC,R0R1R2,0) \
_(AR3D_TEX,INST_DATA,REG_SRC,R2R3R0,1)
#define AR3D_TEX_INST_DATA_REG_SRC_R0R1R2                       _MK_ENUM_CONST(0)
#define AR3D_TEX_INST_DATA_REG_SRC_R2R3R0                       _MK_ENUM_CONST(1)

// surface pointer to fetch through
#define REG_FLD_AR3D_TEX_INST_DATA_SURF_PTR(_) _(AR3D_TEX,INST_DATA,SURF_PTR,4,3,0,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_INST_DATA_SURF_PTR(_)

// =========================================================================
// Colorkey register
// =========================================================================
// The COLORKEY register is compared against each texel value.  If the raw
// texel value matches the appropriate number of LS bits of Colorkey, then
// the pixel is flagged as killed.  For example, 4b indexed texels compare
// their index to bits [3:0] of COLORKEY; 8b indexed texels are compared
// to bits [7:0]; R5G6R6 texels are compared to bits [15:0]; etc.
//
// In the case of bilinear pixels, if *any* of the four pre-filtered texels
// match the COLORKEY value, the pixel is killed.  In the case of trilinear
// texture filtering, the pixel is killed if *any* of the eight pre-filtered
// texels fetched matches the COLORKEY.
//
// This register is enabled by field COLOR_KEY in the instruction (INST[]);
// it must be disabled for the DXT1/3/5 formats.

// Register AR3D_TEX_COLORKEY 
#define LIST_REG_FLD_AR3D_TEX_COLORKEY(_) \
_(AR3D_TEX,COLORKEY,VALUE)
#define REG_AR3D_TEX_COLORKEY(_) _(AR3D_TEX,COLORKEY,0x702,0x2,1,1,0xffffffff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_TEX_COLORKEY_VALUE(_) _(AR3D_TEX,COLORKEY,VALUE,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_COLORKEY_VALUE(_)

// TEXADDR contains the base address for the texture surfaces.  The SURF_PTR field from INST
// will index into this table.
// Any write to TEXADDR, TEXDESC, or FLUSH will cause a texture cache flush.

// Register AR3D_TEX_TEXADDR 
#define LIST_REG_FLD_AR3D_TEX_TEXADDR(_) \
_(AR3D_TEX,TEXADDR,BASE_ADDRESS)
#define REG_AR3D_TEX_TEXADDR(_) _(AR3D_TEX,TEXADDR,0x710,0x10,16,1,0xffffffff,0x0,ARY,FLD)
// This surface base address should be 16-byte aligned
#define REG_FLD_AR3D_TEX_TEXADDR_BASE_ADDRESS(_) _(AR3D_TEX,TEXADDR,BASE_ADDRESS,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXADDR_BASE_ADDRESS(_)

// --------------------------------------------------------------------------
// Notes on TEXDESC (a packed array of 64bit surface formats).
//
// TRILINEAR_OPT, LERP_MAG/MIN/MIP, LOD_BIAS, MAX_ANISO,
// SURF_FORMAT, LAYOUT, MIRROR_S/T and CLAMP_S/T bits are in
// the even addresses
//
// WIDTH, HEIGHT, LOG2_WIDTH, LOG2_HEIGHT, LOD_MIN/MAX,
// BASE_LEVEL_ONLY, NORMALIZE, NON_POWER_OF_TWO and ARRAY_MAX
// are in the odd addresses
//
// Non power of two textures use WIDTH, HEIGHT and NORMALIZE
// and don't use LOG2_WIDTH, LOG2_HEIGHT, LOD_MIN/MAX, LERP_MIP
//
// Power of two textures use the opposite set of fields
//
// SURF_PTR field of INST is used to index into this table 2*SURF_PTR+0 for even fields and
// 2*SURF_PTR+1 for odd fields
//
// WIDTH, HEIGHT, LOG2_WIDTH, LOG2_HEIGHT
// Units are texels
// The use of the WIDTH and HEIGHT fields are mutually exclusive with the
// use of the LOG2_WIDTH and LOG2_HEIGHT fields. Use WIDTH for non-power-of-two
// surfaces, and use LOG2_WIDTH and LOG2_HEIGHT for power-of-two textures.
//
// LOG2_WIDTH, LOG2_HEIGHT
// For texture surfaces using mipmaps these need to be set to the log2 of
// the width and height (in texels) of level 0.
//
// NORMALIZE (sc25 only).
// When enabled, s/t are assumed to be in the range [0..1].  When disabled,
// s/t are assumed to be in the rance [0..WIDTH], [0..HEIGHT].
// Note that mg20 does not support unnormalized s/t.
//
// TRILINEAR_OPT
// makes the lod "stick around" at integer values SLOPE_2 means a computed
// value of e.g. 1.0..1.25 will be mapped to 1.0, and a value of 1.75..2.0
// will be mapped to 2.0. Values in between (1.25..1.75) will be mapped to
// 1.0..2.0 (i.e. a slope of 2)
//
// SURF_FORMAT
// Describes the format the data is stored in memory
// (S=stencil, C=coverage/predicate, I=intensity, L=luminance, A=alpha, B=blue,
//  G=green, R=red, Z=depth, P=pixel_packet)
// For floating point textures, tex writes to destination registers as follow:
//  L16_float, A16_float, and L16A16_float write to [even, odd] with (L,A)
//  R11G11B10_float writes to [even, odd, nextEven] with (R,G,B)
//  R16G16B16A16_float writes to [even, odd] with the selected pair of components
//
// Supported formats: (S=stencil, C=coverage/predicate,
//                     L=luminance, A=alpha, B=blue, G=green, R=red, 
//                     Z=depth, P=pixel_packet)
//  4 bpp:  DXT1, DXT1C, ETC, LATC1
//  8 bpp:  L8, A8, B2G3R3, DXT3, DXT5, ETC3, ETC5, LATC2
// 16 bpp:  L8A8, B5G6R5, A1B5G5R5, B5G5R5A1, A4B4G4R4, B4G4R4A4
//          A16_float, L16_float
// 32 bpp: R8G8B8A8, B8G8R8A8, L16A16_float, R11G11B10_float
// 64 bpp: R16G16B16A16_float, 
//
// Not Supported: S8, C4X4, Z16, Z16NL, R10G10B10_float_A2
//
// LAYOUT
// Please refer to ar3d.spec for description of swizzling and tiling.
//
// CLAMP_S CLAMP_T
// WRAP -- ignore the integer part of the texture coords so that the texture will
//         repeat.
// CLAMP -- clamp the texture coords to the range (0,1) such that it stays within
//         the texture proper
//
// MIRROR_S MIRROR_T
// If mirror is followed by wrap, this effectively defines a texture map twice as
// large as the original texture in which the additional half, for each mirrored
// texture coordinate, is a mirror image of the original texture.
//
//  S/U  -3  -2  -1   0   1   2   3
//  2^N-1 +       +       +       +
//         \     / \     / \     / 
//          \   /   \   /   \   /
//           \ /     \ /     \ /
//  0         +       +       +
//
// And if mirror is followed by clamp, the absolute value of the texture
// coordinates are computed prior to clamping.
//
//  S/U  -3  -2  -1   0   1   2   3
//  2^N-1 --------+       +--------
//                 \     /
//                  \   / 
//                   \ /
//   0                +
//
// Please note that any write to TEXADDR, TEXDESC, or FLUSH will cause a texture
// cache flush.
//
// Programming guideline:
// 1. One should set LOD_MAX to min(TEXTURE_MAX_LOD, maximum available lod).
// 2. One should set BASE_LEVEL_ONLY to (maximum available lod == 0).
//
// The order of evaluation of texture parameters are as follow (variables in caps
// are from the register fields):
//     log2ratio = log2major - log2minor
//     log2ratio = min(log2ratio, log2major)
//     log2ratio -= ANISO_BIAS
//     log2ratio = clamp(log2ratio, 0, log2(MAX_ANISO))
//     lod = log2major - log2ratio
//     lod += LOD_BIAS + USER_LOD_BIAS
//     if (TRILINEAR_OPT)
//         lod = tri_opt(lod)
//     lod = clamp(lod, LOD_MIN, LOD_MAX)
//     magnify = lod <= 0
//     if (!LERP_MIP)
//         lod = round(lod)
//     lod = clamp(lod, 0, max_available_lod)
//
// Restrictions:
// 1. Textures can be no larger than 2k x 2k texels.
// 2. Any single texture can be no larger than 64MB.
// 3. Non-power-of-two textures/cubemaps/arrays do not support mipmapping or anisotropic filtering.
// 4. Non-power-of-two textures/cubemaps/arrays do not support wrap, just clamp to edge.
// 5. Cubemaps do not support anisotropic filtering.
// 6. Cubemaps do not support texture wrap modes other than clamp to edge.
// 7. For power-of-two textures/faces/slices, a mipmap stack should be 32B 
//    aligned, individual levels within the stack should be 16B aligned.
// 8. All non-power-of-two textures/faces/slices are aligned to 1024B.
// 9. non-power-of-two textures widths (post-swizzled) are padded 
//    to 64B multiples.  This means that SWIZZLED layout surfaces have different
//    multiples based on the number of bits per pixel.
//       SWIZZLED layout pre-swizzle width alignment:
//       4bpp - 8bpp -- aligned to 16B multiples
//       16bpp - 64bpp -- aligned to 32B multiples
// 10.non-power-of-two texture faces/slices heights are padded to multiples
//    of 16
// 11.In XY_TILED_SWIZZLED LAYOUT, mipmap levels that have widths < 64B or 
//    heights < 16 are switched to SWIZZLED LAYOUT, the other mipmap levels
//    stay XY_TILED_SWIZZLED
// 12.All power-of-two face/slice sizes are padded to multiples of 1024B
// --------------------------------------------------------------------------

// Register AR3D_TEX_TEXDESC 
#define LIST_REG_FLD_AR3D_TEX_TEXDESC(_) \
_(AR3D_TEX,TEXDESC,WIDTH) \
_(AR3D_TEX,TEXDESC,HEIGHT) \
_(AR3D_TEX,TEXDESC,NORMALIZE) \
_(AR3D_TEX,TEXDESC,LOG2_WIDTH) \
_(AR3D_TEX,TEXDESC,LOG2_HEIGHT) \
_(AR3D_TEX,TEXDESC,LOD_MIN) \
_(AR3D_TEX,TEXDESC,LOD_MAX) \
_(AR3D_TEX,TEXDESC,BASE_LEVEL_ONLY) \
_(AR3D_TEX,TEXDESC,NON_POWER_OF_TWO) \
_(AR3D_TEX,TEXDESC,ARRAY_MAX) \
_(AR3D_TEX,TEXDESC,TRILINEAR_OPT) \
_(AR3D_TEX,TEXDESC,LERP_MAG) \
_(AR3D_TEX,TEXDESC,LERP_MIN) \
_(AR3D_TEX,TEXDESC,LERP_MIP) \
_(AR3D_TEX,TEXDESC,LOD_BIAS) \
_(AR3D_TEX,TEXDESC,MAX_ANISO) \
_(AR3D_TEX,TEXDESC,SURF_FORMAT) \
_(AR3D_TEX,TEXDESC,CUBEMAP) \
_(AR3D_TEX,TEXDESC,LAYOUT) \
_(AR3D_TEX,TEXDESC,MIRROR_S) \
_(AR3D_TEX,TEXDESC,MIRROR_T) \
_(AR3D_TEX,TEXDESC,CLAMP_S) \
_(AR3D_TEX,TEXDESC,CLAMP_T)
#define REG_AR3D_TEX_TEXDESC(_) _(AR3D_TEX,TEXDESC,0x720,0x20,32,1,0xffffffff,0x0,ARY,FLD)
// Width of surface. used by npot textures
#define REG_FLD_AR3D_TEX_TEXDESC_WIDTH(_) _(AR3D_TEX,TEXDESC,WIDTH,12,31,20,3,0xfff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_WIDTH(_)

// Height of surface. used by npot textures
#define REG_FLD_AR3D_TEX_TEXDESC_HEIGHT(_) _(AR3D_TEX,TEXDESC,HEIGHT,12,19,8,3,0xfff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_HEIGHT(_)

// If disabled, s/t map [0..WIDTH], [0..HEIGHT].
// else if enabled, s/t map [0..1], [0..1]. POWER-OF-TWO FIELDS
#define REG_FLD_AR3D_TEX_TEXDESC_NORMALIZE(_) _(AR3D_TEX,TEXDESC,NORMALIZE,1,7,7,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_NORMALIZE(_) \
_(AR3D_TEX,TEXDESC,NORMALIZE,DISABLE,0) \
_(AR3D_TEX,TEXDESC,NORMALIZE,ENABLE,1)
#define AR3D_TEX_TEXDESC_NORMALIZE_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXDESC_NORMALIZE_ENABLE                       _MK_ENUM_CONST(1)

// Log2 (width of surface) Union
#define REG_FLD_AR3D_TEX_TEXDESC_LOG2_WIDTH(_) _(AR3D_TEX,TEXDESC,LOG2_WIDTH,4,31,28,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_LOG2_WIDTH(_)

// Log2 (height of surface) Union
#define REG_FLD_AR3D_TEX_TEXDESC_LOG2_HEIGHT(_) _(AR3D_TEX,TEXDESC,LOG2_HEIGHT,4,27,24,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_LOG2_HEIGHT(_)

// finest LOD to sample from .NV_GR3D_LOD_BIAS_FRAC_BITS format
#define REG_FLD_AR3D_TEX_TEXDESC_LOD_MIN(_) _(AR3D_TEX,TEXDESC,LOD_MIN,8,23,16,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_LOD_MIN(_)

// coarsest LOD to sample from .NV_GR3D_LOD_BIAS_FRAC_BITS format
#define REG_FLD_AR3D_TEX_TEXDESC_LOD_MAX(_) _(AR3D_TEX,TEXDESC,LOD_MAX,8,15,8,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_LOD_MAX(_)

// if set, only base level is allocated, full stack otherwise POWER-OF-TWO/NON-POWER-OF-TWO COMMON FIELDS
#define REG_FLD_AR3D_TEX_TEXDESC_BASE_LEVEL_ONLY(_) _(AR3D_TEX,TEXDESC,BASE_LEVEL_ONLY,1,7,7,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_BASE_LEVEL_ONLY(_) \
_(AR3D_TEX,TEXDESC,BASE_LEVEL_ONLY,DISABLE,0) \
_(AR3D_TEX,TEXDESC,BASE_LEVEL_ONLY,ENABLE,1)
#define AR3D_TEX_TEXDESC_BASE_LEVEL_ONLY_DISABLE                        _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXDESC_BASE_LEVEL_ONLY_ENABLE                 _MK_ENUM_CONST(1)

// Texture dimensions are not power-of-two
#define REG_FLD_AR3D_TEX_TEXDESC_NON_POWER_OF_TWO(_) _(AR3D_TEX,TEXDESC,NON_POWER_OF_TWO,1,6,6,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_NON_POWER_OF_TWO(_) \
_(AR3D_TEX,TEXDESC,NON_POWER_OF_TWO,DISABLE,0) \
_(AR3D_TEX,TEXDESC,NON_POWER_OF_TWO,ENABLE,1)
#define AR3D_TEX_TEXDESC_NON_POWER_OF_TWO_DISABLE                       _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXDESC_NON_POWER_OF_TWO_ENABLE                        _MK_ENUM_CONST(1)

// Array has slices 0..ARRAY_MAX
#define REG_FLD_AR3D_TEX_TEXDESC_ARRAY_MAX(_) _(AR3D_TEX,TEXDESC,ARRAY_MAX,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_ARRAY_MAX(_)

// Enable trilinear optimization
#define REG_FLD_AR3D_TEX_TEXDESC_TRILINEAR_OPT(_) _(AR3D_TEX,TEXDESC,TRILINEAR_OPT,1,30,30,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_TRILINEAR_OPT(_) \
_(AR3D_TEX,TEXDESC,TRILINEAR_OPT,DISABLE,0) \
_(AR3D_TEX,TEXDESC,TRILINEAR_OPT,ENABLE,1)
#define AR3D_TEX_TEXDESC_TRILINEAR_OPT_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXDESC_TRILINEAR_OPT_ENABLE                   _MK_ENUM_CONST(1)

// bilerp fine level
#define REG_FLD_AR3D_TEX_TEXDESC_LERP_MAG(_) _(AR3D_TEX,TEXDESC,LERP_MAG,1,29,29,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_LERP_MAG(_)

// bilerp coarse level
#define REG_FLD_AR3D_TEX_TEXDESC_LERP_MIN(_) _(AR3D_TEX,TEXDESC,LERP_MIN,1,28,28,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_LERP_MIN(_)

// lerp between levels
#define REG_FLD_AR3D_TEX_TEXDESC_LERP_MIP(_) _(AR3D_TEX,TEXDESC,LERP_MIP,1,27,27,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_LERP_MIP(_)

// lod bias, signed with .NV_GR3D_LOD_BIAS_FRAC_BITS fractional bits
#define REG_FLD_AR3D_TEX_TEXDESC_LOD_BIAS(_) _(AR3D_TEX,TEXDESC,LOD_BIAS,9,26,18,3,0x1ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_LOD_BIAS(_)

// maximum aniso ratio minus one
#define REG_FLD_AR3D_TEX_TEXDESC_MAX_ANISO(_) _(AR3D_TEX,TEXDESC,MAX_ANISO,4,17,14,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_MAX_ANISO(_)

// surface format, see GLOBAL.SURFDESC_SC25.SURF_FORMAT
#define REG_FLD_AR3D_TEX_TEXDESC_SURF_FORMAT(_) _(AR3D_TEX,TEXDESC,SURF_FORMAT,6,13,8,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_SURF_FORMAT(_)

// suface is a cubemap (array max should be 5)
#define REG_FLD_AR3D_TEX_TEXDESC_CUBEMAP(_) _(AR3D_TEX,TEXDESC,CUBEMAP,1,7,7,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_CUBEMAP(_)

// When this signal is SWIZZLED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
// XY_TILED_LINEAR is not supported in ap15 (bugid: 310582)
#define REG_FLD_AR3D_TEX_TEXDESC_LAYOUT(_) _(AR3D_TEX,TEXDESC,LAYOUT,3,6,4,3,0x7,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_LAYOUT(_) \
_(AR3D_TEX,TEXDESC,LAYOUT,LINEAR,0) \
_(AR3D_TEX,TEXDESC,LAYOUT,SWIZZLED,1) \
_(AR3D_TEX,TEXDESC,LAYOUT,TILED_LINEAR,2) \
_(AR3D_TEX,TEXDESC,LAYOUT,TILED_SWIZZLED,3) \
_(AR3D_TEX,TEXDESC,LAYOUT,XY_TILED_LINEAR,4) \
_(AR3D_TEX,TEXDESC,LAYOUT,XY_TILED_SWIZZLED,5)
#define AR3D_TEX_TEXDESC_LAYOUT_LINEAR                  _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXDESC_LAYOUT_SWIZZLED                        _MK_ENUM_CONST(1)
#define AR3D_TEX_TEXDESC_LAYOUT_TILED_LINEAR                    _MK_ENUM_CONST(2)
#define AR3D_TEX_TEXDESC_LAYOUT_TILED_SWIZZLED                  _MK_ENUM_CONST(3)
#define AR3D_TEX_TEXDESC_LAYOUT_XY_TILED_LINEAR                 _MK_ENUM_CONST(4)
#define AR3D_TEX_TEXDESC_LAYOUT_XY_TILED_SWIZZLED                       _MK_ENUM_CONST(5)

// mirror the s coordinate
#define REG_FLD_AR3D_TEX_TEXDESC_MIRROR_S(_) _(AR3D_TEX,TEXDESC,MIRROR_S,1,3,3,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_MIRROR_S(_) \
_(AR3D_TEX,TEXDESC,MIRROR_S,DISABLE,0) \
_(AR3D_TEX,TEXDESC,MIRROR_S,ENABLE,1)
#define AR3D_TEX_TEXDESC_MIRROR_S_DISABLE                       _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXDESC_MIRROR_S_ENABLE                        _MK_ENUM_CONST(1)

// mirror the t coordiante
#define REG_FLD_AR3D_TEX_TEXDESC_MIRROR_T(_) _(AR3D_TEX,TEXDESC,MIRROR_T,1,2,2,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_MIRROR_T(_) \
_(AR3D_TEX,TEXDESC,MIRROR_T,DISABLE,0) \
_(AR3D_TEX,TEXDESC,MIRROR_T,ENABLE,1)
#define AR3D_TEX_TEXDESC_MIRROR_T_DISABLE                       _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXDESC_MIRROR_T_ENABLE                        _MK_ENUM_CONST(1)

// type of clamp for s coordinate
#define REG_FLD_AR3D_TEX_TEXDESC_CLAMP_S(_) _(AR3D_TEX,TEXDESC,CLAMP_S,1,1,1,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_CLAMP_S(_) \
_(AR3D_TEX,TEXDESC,CLAMP_S,WRAP,0) \
_(AR3D_TEX,TEXDESC,CLAMP_S,CLAMP,1)
#define AR3D_TEX_TEXDESC_CLAMP_S_WRAP                   _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXDESC_CLAMP_S_CLAMP                  _MK_ENUM_CONST(1)

// type of clamp for t coordinate
#define REG_FLD_AR3D_TEX_TEXDESC_CLAMP_T(_) _(AR3D_TEX,TEXDESC,CLAMP_T,1,0,0,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXDESC_CLAMP_T(_) \
_(AR3D_TEX,TEXDESC,CLAMP_T,WRAP,0) \
_(AR3D_TEX,TEXDESC,CLAMP_T,CLAMP,1)
#define AR3D_TEX_TEXDESC_CLAMP_T_WRAP                   _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXDESC_CLAMP_T_CLAMP                  _MK_ENUM_CONST(1)

// Texture control register containing miscellaneous enable and control bits.
// ANISO_BIAS scales the number of aniso bilerps down
// It should normally be non-zero, since zero means that even the slightest
// anisotropy will cause at least 2 aniso bilerps
// ANISO_OPT makes the aniso ratio "stick around" at integer values
// SLOPE_2 means a computed value of e.g. 1.0..1.5 will be mapped to 1.0, and
// a value of 1.5..2.0 will be mapped to 1.0..2.0 (i.e. a slope of 2)
// FLOOR makes the aniso ratio stick to the closest lower integer
// FLOOR_EVEN makes the aniso ratio stick to the closest lower even number
// Field TEXTURE_CACHE_EN enables/disables the texture cache for debug.
// It should normally be programmed to ENABLE and left alone.

// Register AR3D_TEX_TEXCTL 
#define LIST_REG_FLD_AR3D_TEX_TEXCTL(_) \
_(AR3D_TEX,TEXCTL,ANISO_BIAS) \
_(AR3D_TEX,TEXCTL,ANISO_OPT) \
_(AR3D_TEX,TEXCTL,TEXTURE_CACHE_EN)
#define REG_AR3D_TEX_TEXCTL(_) _(AR3D_TEX,TEXCTL,0x740,0x40,1,1,0x7d,0x0,NOARY,FLD)
// Aniso bias decreases lg2(ratio) by 0..7/8
#define REG_FLD_AR3D_TEX_TEXCTL_ANISO_BIAS(_) _(AR3D_TEX,TEXCTL,ANISO_BIAS,3,6,4,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_TEX_TEXCTL_ANISO_BIAS(_)

// Enable aniso optimization
#define REG_FLD_AR3D_TEX_TEXCTL_ANISO_OPT(_) _(AR3D_TEX,TEXCTL,ANISO_OPT,2,3,2,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXCTL_ANISO_OPT(_) \
_(AR3D_TEX,TEXCTL,ANISO_OPT,DISABLE,0) \
_(AR3D_TEX,TEXCTL,ANISO_OPT,SLOPE_2,1) \
_(AR3D_TEX,TEXCTL,ANISO_OPT,FLOOR,2) \
_(AR3D_TEX,TEXCTL,ANISO_OPT,FLOOR_EVEN,3)
#define AR3D_TEX_TEXCTL_ANISO_OPT_DISABLE                       _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXCTL_ANISO_OPT_SLOPE_2                       _MK_ENUM_CONST(1)
#define AR3D_TEX_TEXCTL_ANISO_OPT_FLOOR                 _MK_ENUM_CONST(2)
#define AR3D_TEX_TEXCTL_ANISO_OPT_FLOOR_EVEN                    _MK_ENUM_CONST(3)

// Enable texture cache
#define REG_FLD_AR3D_TEX_TEXCTL_TEXTURE_CACHE_EN(_) _(AR3D_TEX,TEXCTL,TEXTURE_CACHE_EN,1,0,0,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_TEX_TEXCTL_TEXTURE_CACHE_EN(_) \
_(AR3D_TEX,TEXCTL,TEXTURE_CACHE_EN,DISABLE,0) \
_(AR3D_TEX,TEXCTL,TEXTURE_CACHE_EN,ENABLE,1)
#define AR3D_TEX_TEXCTL_TEXTURE_CACHE_EN_DISABLE                        _MK_ENUM_CONST(0)
#define AR3D_TEX_TEXCTL_TEXTURE_CACHE_EN_ENABLE                 _MK_ENUM_CONST(1)


// Register AR3D_TEX_CLKEN_OVERRIDE 
#define LIST_REG_FLD_AR3D_TEX_CLKEN_OVERRIDE(_) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXPBCLK_CLKEN_OVR) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXPPBCLK_CLKEN_OVR) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXLODCLK_CLKEN_OVR) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXFORMATCLK_CLKEN_OVR) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXLODLOWERDPCLK_CLKEN_OVR) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXNONBYPCLK_CLKEN_OVR) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXCACHECLK_CLKEN_OVR)
#define REG_AR3D_TEX_CLKEN_OVERRIDE(_) _(AR3D_TEX,CLKEN_OVERRIDE,0x741,0x41,1,1,0x7f,0x0,NOARY,FLD)
// Fine Grain override for the gr3dclipcgclk
#define REG_FLD_AR3D_TEX_CLKEN_OVERRIDE_TEXPBCLK_CLKEN_OVR(_) _(AR3D_TEX,CLKEN_OVERRIDE,TEXPBCLK_CLKEN_OVR,1,0,0,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_TEX_CLKEN_OVERRIDE_TEXPBCLK_CLKEN_OVR(_) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXPBCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXPBCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXPBCLK_CLKEN_OVR_CLK_GATED                    _MK_ENUM_CONST(0)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXPBCLK_CLKEN_OVR_CLK_ALWAYS_ON                        _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipccclk
#define REG_FLD_AR3D_TEX_CLKEN_OVERRIDE_TEXPPBCLK_CLKEN_OVR(_) _(AR3D_TEX,CLKEN_OVERRIDE,TEXPPBCLK_CLKEN_OVR,1,1,1,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_TEX_CLKEN_OVERRIDE_TEXPPBCLK_CLKEN_OVR(_) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXPPBCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXPPBCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXPPBCLK_CLKEN_OVR_CLK_GATED                   _MK_ENUM_CONST(0)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXPPBCLK_CLKEN_OVR_CLK_ALWAYS_ON                       _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipcpclk
#define REG_FLD_AR3D_TEX_CLKEN_OVERRIDE_TEXLODCLK_CLKEN_OVR(_) _(AR3D_TEX,CLKEN_OVERRIDE,TEXLODCLK_CLKEN_OVR,1,2,2,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_TEX_CLKEN_OVERRIDE_TEXLODCLK_CLKEN_OVR(_) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXLODCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXLODCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXLODCLK_CLKEN_OVR_CLK_GATED                   _MK_ENUM_CONST(0)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXLODCLK_CLKEN_OVR_CLK_ALWAYS_ON                       _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipvpclk
#define REG_FLD_AR3D_TEX_CLKEN_OVERRIDE_TEXFORMATCLK_CLKEN_OVR(_) _(AR3D_TEX,CLKEN_OVERRIDE,TEXFORMATCLK_CLKEN_OVR,1,3,3,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_TEX_CLKEN_OVERRIDE_TEXFORMATCLK_CLKEN_OVR(_) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXFORMATCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXFORMATCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXFORMATCLK_CLKEN_OVR_CLK_GATED                        _MK_ENUM_CONST(0)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXFORMATCLK_CLKEN_OVR_CLK_ALWAYS_ON                    _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dcliparclk
#define REG_FLD_AR3D_TEX_CLKEN_OVERRIDE_TEXLODLOWERDPCLK_CLKEN_OVR(_) _(AR3D_TEX,CLKEN_OVERRIDE,TEXLODLOWERDPCLK_CLKEN_OVR,1,4,4,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_TEX_CLKEN_OVERRIDE_TEXLODLOWERDPCLK_CLKEN_OVR(_) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXLODLOWERDPCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXLODLOWERDPCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXLODLOWERDPCLK_CLKEN_OVR_CLK_GATED                    _MK_ENUM_CONST(0)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXLODLOWERDPCLK_CLKEN_OVR_CLK_ALWAYS_ON                        _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclippaclk
#define REG_FLD_AR3D_TEX_CLKEN_OVERRIDE_TEXNONBYPCLK_CLKEN_OVR(_) _(AR3D_TEX,CLKEN_OVERRIDE,TEXNONBYPCLK_CLKEN_OVR,1,5,5,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_TEX_CLKEN_OVERRIDE_TEXNONBYPCLK_CLKEN_OVR(_) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXNONBYPCLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXNONBYPCLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXNONBYPCLK_CLKEN_OVR_CLK_GATED                        _MK_ENUM_CONST(0)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXNONBYPCLK_CLKEN_OVR_CLK_ALWAYS_ON                    _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dclipdzclk
#define REG_FLD_AR3D_TEX_CLKEN_OVERRIDE_TEXCACHECLK_CLKEN_OVR(_) _(AR3D_TEX,CLKEN_OVERRIDE,TEXCACHECLK_CLKEN_OVR,1,6,6,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_TEX_CLKEN_OVERRIDE_TEXCACHECLK_CLKEN_OVR(_) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXCACHECLK_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_TEX,CLKEN_OVERRIDE,TEXCACHECLK_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXCACHECLK_CLKEN_OVR_CLK_GATED                 _MK_ENUM_CONST(0)
#define AR3D_TEX_CLKEN_OVERRIDE_TEXCACHECLK_CLKEN_OVR_CLK_ALWAYS_ON                     _MK_ENUM_CONST(1)

//tex has aniso or not in project spec file now
//define TEX_ANISO_PRESENT 1;
//
// Memory Client Interface Async Fifo Optimization Register
// This can only be changed while the pipeline is completely idle.
// Read-Only Instance
// Memory Client Interface Fifo Control Register.
// The registers below allow to optimize the synchronization timing in
// the memory client asynchronous fifos. When they can be used depend on
// the client and memory controller clock ratio.
// Additionally, the RDMC_RDFAST/RDCL_RDFAST fields can increase power
// consumption if the asynchronous fifo is implemented as a real ram.
// There is no power impact on latch-based fifos. Flipflop-based fifos
// do not use these fields.
// See recommended settings below.
//
// !! IMPORTANT !!
// The register fields can only be changed when the memory client async
// fifos are empty.
//
// The register field ending with WRCL_MCLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one client clock cycle if
// the memory controller clock frequency is less or equal to twice the client
// clock frequency:
//
//      mcclk_freq <= 2 * clientclk_freq
//
// The register field ending with WRMC_CLLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one memory controller clock
// cycle if the client clock frequency is less or equal to twice the memory
// controller clock frequency:
//
//      clientclk_freq <= 2 * mcclk_freq
//
// The register field ending with RDMC_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one memory controller clock cycle.
//
// !! WARNING !!
// RDMC_RDFAST can be used along with WRCL_MCLE2X only when:
//
//       mcclk_freq <= clientclk_freq
//
// The register field ending with RDCL_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one client clock cycle.
//
// !! WARNING !!
// RDCL_RDFAST can be used along with WRMC_CLLE2X only when:
//
//       clientclk_freq <= mcclk_freq
//
// RECOMMENDED SETTINGS
// # Client writing to fifo, memory controller reading from fifo
// - mcclk_freq <= clientclk_freq
//     You can enable both RDMC_RDFAST and WRCL_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.
// - clientclk_freq < mcclk_freq <= 2 * clientclk_freq
//     You can enable RDMC_RDFAST or WRCL_MCLE2X, but because the client clock
//     is slower, you should enable only WRCL_MCLE2X.
// - 2 * clientclk_freq < mcclk_freq
//     You can only enable RDMC_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDMC_RDFAST.
//
// # Memory controller writing to fifo, client reading from fifo
// - clientclk_freq <= mcclk_freq
//     You can enable both RDCL_RDFAST and WRMC_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.
// - mcclk_freq < clientclk_freq <= 2 * mcclk_freq
//     You can enable RDCL_RDFAST or WRMC_CLLE2X, but because the memory controller
//     clock is slower, you should enable only WRMC_CLLE2X.
// - 2 * mcclk_freq < clientclk_freq
//     You can only enable RDCL_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDCL_RDFAST.
//

// Register AR3D_TEX_NV_MCCIF_FIFOCTRL_RO 
#define LIST_REG_FLD_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO(_) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST)
#define REG_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO(_) _(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,0x742,0x42,1,1,0xf,0x0,NOARY,FLD)
#define REG_FLD_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X(_) _(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X,1,0,0,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X(_) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X,DISABLE,0) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X,ENABLE,1)
#define AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST(_) _(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST,1,1,1,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST(_) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST,DISABLE,0) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST,ENABLE,1)
#define AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X(_) _(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X,1,2,2,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X(_) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X,DISABLE,0) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X,ENABLE,1)
#define AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST(_) _(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST,1,3,3,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST(_) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST,DISABLE,0) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST,ENABLE,1)
#define AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_TEX_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST_ENABLE                       _MK_ENUM_CONST(1)

// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
//
//
// --------------------------------------------------------------------------
// ALU Instruction Registers
// --------------------------------------------------------------------------
//
// Overview:
// The ALU is the heart of the pixel shader hardware. It consists of 4 parallel units each
// of which computes a floating-point MAD DEST = (A*B+C). An optional second 
// multiplier can be turned on to compute a DP2 instead (A*B + C*D) where C and D can be either FX10 or FP20.
// Each unit has 4 inputs represented as A, B, C, and D.  D can be fixed or floating-point, but
// is restricted to B or C's selection.
//
//
// Remap table offset: controls what indirect entry in the remap table gets accessed.
// INDEX auto-increments with each access to REMAP_DATA (by 4 for accesses to REMAP_DATA_4X)
// BASE is added to the REMAP_DATA and REMAP_DATA_4X OFFSET value(s) on writes.
// Reads to REMAP_DATA or REMAP_DATA_4X return result of addition at the time of the last write to that INDEX.
// Writes to AR3D_GLOBAL_INST_OFFSET will update the index field of this register
// Writes to AR3D_ALU_INST_OFFSET will update the BASE field.
//      this update will divide the INDEX from INST_OFFSET by the number of words
//      in an single logical alu instruction 
//      (NV_GR3D_ALU_INST_NUM_WORDS * NV_GR3D_NUM_ALUS) 

// Register AR3D_ALU_REMAP_OFFSET 
#define LIST_REG_FLD_AR3D_ALU_REMAP_OFFSET(_) \
_(AR3D_ALU,REMAP_OFFSET,INDEX) \
_(AR3D_ALU,REMAP_OFFSET,BASE)
#define REG_AR3D_ALU_REMAP_OFFSET(_) _(AR3D_ALU,REMAP_OFFSET,0x800,0x0,1,1,0xfff,0x0,NOARY,FLD)
// current read or write target in REMAP_DATA
#define REG_FLD_AR3D_ALU_REMAP_OFFSET_INDEX(_) _(AR3D_ALU,REMAP_OFFSET,INDEX,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_OFFSET_INDEX(_)

// value to add to OFFSET on write
#define REG_FLD_AR3D_ALU_REMAP_OFFSET_BASE(_) _(AR3D_ALU,REMAP_OFFSET,BASE,6,11,6,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_OFFSET_BASE(_)

//
// Remap table - remaps packet sequence #'s to counts and offsets of real INST[]'s
//

// Register AR3D_ALU_REMAP_DATA 
#define LIST_REG_FLD_AR3D_ALU_REMAP_DATA(_) \
_(AR3D_ALU,REMAP_DATA,COUNT) \
_(AR3D_ALU,REMAP_DATA,OFFSET)
#define REG_AR3D_ALU_REMAP_DATA(_) _(AR3D_ALU,REMAP_DATA,0x801,0x1,1,1,0xff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_ALU_REMAP_DATA_COUNT(_) _(AR3D_ALU,REMAP_DATA,COUNT,2,1,0,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_COUNT(_)

#define REG_FLD_AR3D_ALU_REMAP_DATA_OFFSET(_) _(AR3D_ALU,REMAP_DATA,OFFSET,6,7,2,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_OFFSET(_)

//
// 4X Remap table - 4-at-a-time indirect port for remap tables (can be aligned at any REMAP_OFFSET INDEX value)
//

// Register AR3D_ALU_REMAP_DATA_4X 
#define LIST_REG_FLD_AR3D_ALU_REMAP_DATA_4X(_) \
_(AR3D_ALU,REMAP_DATA_4X,COUNT0) \
_(AR3D_ALU,REMAP_DATA_4X,OFFSET0) \
_(AR3D_ALU,REMAP_DATA_4X,COUNT1) \
_(AR3D_ALU,REMAP_DATA_4X,OFFSET1) \
_(AR3D_ALU,REMAP_DATA_4X,COUNT2) \
_(AR3D_ALU,REMAP_DATA_4X,OFFSET2) \
_(AR3D_ALU,REMAP_DATA_4X,COUNT3) \
_(AR3D_ALU,REMAP_DATA_4X,OFFSET3)
#define REG_AR3D_ALU_REMAP_DATA_4X(_) _(AR3D_ALU,REMAP_DATA_4X,0x802,0x2,1,1,0xffffffff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_ALU_REMAP_DATA_4X_COUNT0(_) _(AR3D_ALU,REMAP_DATA_4X,COUNT0,2,1,0,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_4X_COUNT0(_)

#define REG_FLD_AR3D_ALU_REMAP_DATA_4X_OFFSET0(_) _(AR3D_ALU,REMAP_DATA_4X,OFFSET0,6,7,2,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_4X_OFFSET0(_)

#define REG_FLD_AR3D_ALU_REMAP_DATA_4X_COUNT1(_) _(AR3D_ALU,REMAP_DATA_4X,COUNT1,2,9,8,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_4X_COUNT1(_)

#define REG_FLD_AR3D_ALU_REMAP_DATA_4X_OFFSET1(_) _(AR3D_ALU,REMAP_DATA_4X,OFFSET1,6,15,10,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_4X_OFFSET1(_)

#define REG_FLD_AR3D_ALU_REMAP_DATA_4X_COUNT2(_) _(AR3D_ALU,REMAP_DATA_4X,COUNT2,2,17,16,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_4X_COUNT2(_)

#define REG_FLD_AR3D_ALU_REMAP_DATA_4X_OFFSET2(_) _(AR3D_ALU,REMAP_DATA_4X,OFFSET2,6,23,18,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_4X_OFFSET2(_)

#define REG_FLD_AR3D_ALU_REMAP_DATA_4X_COUNT3(_) _(AR3D_ALU,REMAP_DATA_4X,COUNT3,2,25,24,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_4X_COUNT3(_)

#define REG_FLD_AR3D_ALU_REMAP_DATA_4X_OFFSET3(_) _(AR3D_ALU,REMAP_DATA_4X,OFFSET3,6,31,26,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_REMAP_DATA_4X_OFFSET3(_)

//
// Instruction table offset: controls what indirect entry in the instruction table gets accessed.
// INDEX auto-increments with each access to INST_DATA.
// This register will also update the BASE field of REMAP_OFFSET
//      this update will divide the INDEX from INST_OFFSET by the number of words
//      in an single logical atrast instruction 
//      (NV_GR3D_AT_INST_NUM_WORDS) 

// Register AR3D_ALU_INST_OFFSET 
#define LIST_REG_FLD_AR3D_ALU_INST_OFFSET(_) \
_(AR3D_ALU,INST_OFFSET,INDEX)
#define REG_AR3D_ALU_INST_OFFSET(_) _(AR3D_ALU,INST_OFFSET,0x803,0x3,1,1,0x1ff,0x0,NOARY,FLD)
// current read or write target in INST_DATA
#define REG_FLD_AR3D_ALU_INST_OFFSET_INDEX(_) _(AR3D_ALU,INST_OFFSET,INDEX,9,8,0,3,0x1ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_INST_OFFSET_INDEX(_)

//
// Instruction table. 
// this array of instruction registers uses variant encodings within one
// register spec to allow single instructions to be pairs of adjacent writes
// The table below is 4* deeper to account for the 4 ALUs.
// The layout is
//    INST[0] = ALU0 instruction 0 even [OP DEST A]
//    INST[1] = ALU0 instruction 0 odd  [B C D]
//    INST[2] = ALU1 instruction 0 even [OP DEST A]
//       ...
//    INST[8] = ALU0 instruction 1 even [OP DEST A]
//       ...
//

// Register AR3D_ALU_INST_DATA 
#define LIST_REG_FLD_AR3D_ALU_INST_DATA(_) \
_(AR3D_ALU,INST_DATA,OP) \
_(AR3D_ALU,INST_DATA,DEST) \
_(AR3D_ALU,INST_DATA,A) \
_(AR3D_ALU,INST_DATA,B) \
_(AR3D_ALU,INST_DATA,C) \
_(AR3D_ALU,INST_DATA,D)
#define REG_AR3D_ALU_INST_DATA(_) _(AR3D_ALU,INST_DATA,0x804,0x4,1,1,0xffffffff,0x0,NOARY,FLD)
//   Operation (AR3D_ALU_OP)
#define REG_FLD_AR3D_ALU_INST_DATA_OP(_) _(AR3D_ALU,INST_DATA,OP,5,31,27,3,0x1f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_INST_DATA_OP(_)

//   Destination control (AR3D_ALU_RESSEL)
#define REG_FLD_AR3D_ALU_INST_DATA_DEST(_) _(AR3D_ALU,INST_DATA,DEST,14,26,13,3,0x3fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_INST_DATA_DEST(_)

//   A input control (AR3D_ALU_ARGSEL_ABC)
#define REG_FLD_AR3D_ALU_INST_DATA_A(_) _(AR3D_ALU,INST_DATA,A,13,12,0,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_INST_DATA_A(_)

//   B input control (AR3D_ALU_ARGSEL_ABC)
#define REG_FLD_AR3D_ALU_INST_DATA_B(_) _(AR3D_ALU,INST_DATA,B,13,31,19,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_INST_DATA_B(_)

//   C input control (AR3D_ALU_ARGSEL_ABC)
#define REG_FLD_AR3D_ALU_INST_DATA_C(_) _(AR3D_ALU,INST_DATA,C,13,18,6,3,0x1fff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_INST_DATA_C(_)

//   D input control (AR3D_ALU_ARGSEL_D)
#define REG_FLD_AR3D_ALU_INST_DATA_D(_) _(AR3D_ALU,INST_DATA,D,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_INST_DATA_D(_)

//
// Descriptions of Instruction fields:
//
// --------------------------------------------------------------
// Argument Selector for A,B,C inputs (AR3D_ALU_ARGSEL_ABC)
// --------------------------------------------------------------
// 
// AR3D_ALU_ARGSEL_ABC
//     12:6  RSEL       register select index
//     5:5   MOD        select LOW or HIGH 10b (s1.8).  use with fixed-point precision.
//     4:4   SUB_1      input modifier:  subtract 1, only applicable to FX10 inputs (.HI or .LO)
//     3:3   PREC       choose either fixed-point input or floating-point input
//     2:2   ABS        input modifier:  absolute value
//     1:1   NEG        input modifier:  negate
//     0:0   X2         input modifier:  multiply by 2
//
// A,B and C can be any of
//  o up to 16 row registers (4 per row)
//  o 8 scratch registers (plus any of the unused rows)
//  o 32 globals
//  o 3 immediate values.
//  o constant 0.0 or 1.0
//  o x,y values in packed format (2 registers)
//  o kill code
//  o up to 16 predicate bits (4 per row)
//
// There are 4 input modifiers that can be applied to the A, B, and C inputs: subtract one, scale by 2, absolute, and negate.
//
// Register select (12:6) mapping:
//       000xxxx  Row register R0-R15.  Can be used as FP20 or dual FX10 pairs.
//       0010xxx  Scratch registers S0-S7.  Can be used as FP20 or dual FX10 pairs.
//       00110xx  ALU results RES0-RES3.  Can be used as FP20 or dual FX10 pairs.  
//                Note, the RES bus will normally be read the same way the intended destination would be read
//                (Fp20 for the Fp20 representation, or .HI or .LO for the FX10 representations), except for one case:  
//                when writing a predicate with the FP20 modifier, the RES bus will have the FP20 representation of the 
//                predicate value (0.0 or 1.0) rather than the FX10 representation. 
//       00111xx  Immediates IMM0-IMM2.  Can be used as FP20 or dual FX10 pairs.  Read-only.  Consumes
//                ALU3's instruction, which becomes a NOP.
//       0011111  Constant 0.0 and 1.0 as a FX10 pair.  .lo is 0.0, .hi is 1.0.  Read-only.
//       01xxxxx  Globals, G0-G31.  Can be used as FP20 or dual FX10 pairs.  G8-G31 are read-only.
//       100000x  X,Y registers. 11-bit values, which can be directly interepreted as an FP20 values.  Read-only.
//       1000010  PCOV.  Pixel coverage -- count of 4 vcaa bits plus the center coverage.  Read-only.
//                Value stored as FX10 in .LO.
//       1001xxx  Predicate registers as FX10 pairs.  P0.lo is predicate 0, P0.hi is predicate 1, etc.  Reads
//                as 0.0 or 1.0, can write as 0.0 or not 0.0, which maps to 1. Note than when
//                late VCAA is enabled, the VCAA bits are mapped to P0 and P1.
//       1010000  FF.  Front-face -- indicates that polygon is front-faced.  Stored from spanstart.  Read-only.  
//                Value stored as FX10 in .LO.
//       1010001  Kill code as FX10 value.  Only .lo is valid.  Reading returns 1.0 if pixel killed (or otherwise
//                not rendered) and 0.0 if pixel is live.  Writing any non-zero value will kill pixel, writing 0.0 will leave
//                current kill code state alone. 
//       others   Other values are undefined and should not be used.
//
//       Note: The value written to a destination by the immediately preceding instruction is only accessible using the RES input.
//             
//                Write to G[n] (where n is in the range 0-7) is mapped to G[8*interleave + n] (where interleave is defined
//                as the pixel number in the current quad).  Example below.
//             Writes to G0-G7 are mapped to G0-G7, G8-G15, G16-G23, or G24-G31 based on the pixel's interleave in the quad.  This allows
//             inter-pixel communication.  For example:
//                 G0 = R0;  // pixel 0's R0 is written to G0
//                           // pixel 1's R0 is written to G8
//                           // pixel 2's R0 is written to G16
//                           // pixel 3's R0 is written to G24
//                 R0 = G0;  // each pixel's R0 gets G0 (which is pixel 0's R0); there is no aliasing on reads

// Packet AR3D_ALU_ARGSEL_ABC
#define LIST_PKT_FLD_AR3D_ALU_ARGSEL_ABC(_) \
_(AR3D_ALU_ARGSEL_ABC,RSEL) \
_(AR3D_ALU_ARGSEL_ABC,MOD) \
_(AR3D_ALU_ARGSEL_ABC,SUB_1) \
_(AR3D_ALU_ARGSEL_ABC,PREC) \
_(AR3D_ALU_ARGSEL_ABC,ABS) \
_(AR3D_ALU_ARGSEL_ABC,NEG) \
_(AR3D_ALU_ARGSEL_ABC,X2)
#define PKT_AR3D_ALU_ARGSEL_ABC(_) _(AR3D_ALU_ARGSEL_ABC,13,FLD)
// register select index
#define PKT_FLD_AR3D_ALU_ARGSEL_ABC_RSEL(_) _(AR3D_ALU_ARGSEL_ABC,RSEL,0,7,12,6,0x7f,ENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_ABC_RSEL(_) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R0,0) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R1,1) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R2,2) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R3,3) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R4,4) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R5,5) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R6,6) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R7,7) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R8,8) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R9,9) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R10,10) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R11,11) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R12,12) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R13,13) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R14,14) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,R15,15) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,S0,16) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,S1,17) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,S2,18) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,S3,19) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,S4,20) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,S5,21) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,S6,22) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,S7,23) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,RES0,24) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,RES1,25) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,RES2,26) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,RES3,27) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,IMM0,28) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,IMM1,29) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,IMM2,30) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,C01,31) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G0,32) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G1,33) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G2,34) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G3,35) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G4,36) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G5,37) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G6,38) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G7,39) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G8,40) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G9,41) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G10,42) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G11,43) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G12,44) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G13,45) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G14,46) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G15,47) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G16,48) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G17,49) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G18,50) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G19,51) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G20,52) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G21,53) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G22,54) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G23,55) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G24,56) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G25,57) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G26,58) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G27,59) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G28,60) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G29,61) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G30,62) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,G31,63) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,P0,64) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,P1,65) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,P2,66) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,P3,67) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,P4,68) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,P5,69) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,P6,70) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,P7,71) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,X,72) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,Y,73) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,PCOV,74) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,FF,75) \
_(AR3D_ALU_ARGSEL_ABC,RSEL,KC,76)
// select LOW or HIGH 10b (s1.8).  use with fixed-point precision.
#define PKT_FLD_AR3D_ALU_ARGSEL_ABC_MOD(_) _(AR3D_ALU_ARGSEL_ABC,MOD,0,1,5,5,0x1,ENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_ABC_MOD(_) \
_(AR3D_ALU_ARGSEL_ABC,MOD,L,0) \
_(AR3D_ALU_ARGSEL_ABC,MOD,H,1)
// input modifier:  subtract 1, only applicable to FX10 inputs (.LO or .HI)
#define PKT_FLD_AR3D_ALU_ARGSEL_ABC_SUB_1(_) _(AR3D_ALU_ARGSEL_ABC,SUB_1,0,1,4,4,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_ABC_SUB_1(_)
// choose either fixed-point input or floating-point input
#define PKT_FLD_AR3D_ALU_ARGSEL_ABC_PREC(_) _(AR3D_ALU_ARGSEL_ABC,PREC,0,1,3,3,0x1,ENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_ABC_PREC(_) \
_(AR3D_ALU_ARGSEL_ABC,PREC,FP,0) \
_(AR3D_ALU_ARGSEL_ABC,PREC,FX,1)
// input modifier:  absolute value
#define PKT_FLD_AR3D_ALU_ARGSEL_ABC_ABS(_) _(AR3D_ALU_ARGSEL_ABC,ABS,0,1,2,2,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_ABC_ABS(_)
// input modifier:  negate
#define PKT_FLD_AR3D_ALU_ARGSEL_ABC_NEG(_) _(AR3D_ALU_ARGSEL_ABC,NEG,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_ABC_NEG(_)
// input modifier:  multiply by 2
#define PKT_FLD_AR3D_ALU_ARGSEL_ABC_X2(_) _(AR3D_ALU_ARGSEL_ABC,X2,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_ABC_X2(_)
// --------------------------------------------------------------
// Argument selector for D input (AR3D_ALU_ARGSEL_D)
// --------------------------------------------------------------
// D can only be B or C.  MOD can be set such that the D input 
// selects an the HI or LO half of B or C.  PREC determines whether to 
// use the FX10 half chosen by MOD or the full FP20.
//
//  AR3D_ALU_ARGSEL_D
//     5:5   RSEL     register select index - One of B or C
//     4:4   MOD      select LOW or HIGH 10b (s1.8)
//     3:3   SUB_1    input modifier:  subtract one, only applicable to FX10 inputs (.LO or .HI)
//     2:2   FUNC     Select A*B+C or A*B+C*D -- the latter effectively enables the D input
//     1:1   ABS      input modifier:  absolute
//     0:0   PREC     choose fixed-point or floating-point input
// The D input has only one input modifier, subtract one.
//

// Packet AR3D_ALU_ARGSEL_D
#define LIST_PKT_FLD_AR3D_ALU_ARGSEL_D(_) \
_(AR3D_ALU_ARGSEL_D,RSEL) \
_(AR3D_ALU_ARGSEL_D,MOD) \
_(AR3D_ALU_ARGSEL_D,SUB_1) \
_(AR3D_ALU_ARGSEL_D,FUNC) \
_(AR3D_ALU_ARGSEL_D,ABS) \
_(AR3D_ALU_ARGSEL_D,PREC)
#define PKT_AR3D_ALU_ARGSEL_D(_) _(AR3D_ALU_ARGSEL_D,6,FLD)
// register select index - One of B or C
#define PKT_FLD_AR3D_ALU_ARGSEL_D_RSEL(_) _(AR3D_ALU_ARGSEL_D,RSEL,0,1,5,5,0x1,ENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_D_RSEL(_) \
_(AR3D_ALU_ARGSEL_D,RSEL,B,0) \
_(AR3D_ALU_ARGSEL_D,RSEL,C,1)
// select LOW or HIGH 10b (s1.8)
#define PKT_FLD_AR3D_ALU_ARGSEL_D_MOD(_) _(AR3D_ALU_ARGSEL_D,MOD,0,1,4,4,0x1,ENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_D_MOD(_) \
_(AR3D_ALU_ARGSEL_D,MOD,L,0) \
_(AR3D_ALU_ARGSEL_D,MOD,H,1)
// input modifier:  subtract one, only applicable to FX10 inputs (.LO or .HI)
#define PKT_FLD_AR3D_ALU_ARGSEL_D_SUB_1(_) _(AR3D_ALU_ARGSEL_D,SUB_1,0,1,3,3,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_D_SUB_1(_)
// Select A*B+C or A*B+C*D -- the latter effectively enables the D input
#define PKT_FLD_AR3D_ALU_ARGSEL_D_FUNC(_) _(AR3D_ALU_ARGSEL_D,FUNC,0,1,2,2,0x1,ENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_D_FUNC(_) \
_(AR3D_ALU_ARGSEL_D,FUNC,MAD,0) \
_(AR3D_ALU_ARGSEL_D,FUNC,DP2,1)
// input modifier:  absolute
#define PKT_FLD_AR3D_ALU_ARGSEL_D_ABS(_) _(AR3D_ALU_ARGSEL_D,ABS,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_D_ABS(_)
// choose either fixed-point input or floating-point input
#define PKT_FLD_AR3D_ALU_ARGSEL_D_PREC(_) _(AR3D_ALU_ARGSEL_D,PREC,0,1,0,0,0x1,ENM)
#define LIST_PKT_ENM_AR3D_ALU_ARGSEL_D_PREC(_) \
_(AR3D_ALU_ARGSEL_D,PREC,FP,0) \
_(AR3D_ALU_ARGSEL_D,PREC,FX,1)
// --------------------------------------------------------------
// X and Y coordinates (ALU_AR3D_XY)
// --------------------------------------------------------------
// A coordinate is read as an FP20, where the actual coordinate is stored in the bottom 12 bits.  
// The FP20 exponent is loaded with 2^13 so that X,Y value can be interereted directly by subtracting 8192.
#define ALU_XY_EXP      44

// Packet AR3D_ALU_COORD
#define LIST_PKT_FLD_AR3D_ALU_COORD(_) \
_(AR3D_ALU_COORD,EXP) \
_(AR3D_ALU_COORD,COORD) \
_(AR3D_ALU_COORD,FP20)
#define PKT_AR3D_ALU_COORD(_) _(AR3D_ALU_COORD,20,FLD)
// static exponent field, set to ALU_XY_EXP (2^13)
#define PKT_FLD_AR3D_ALU_COORD_EXP(_) _(AR3D_ALU_COORD,EXP,0,7,19,13,0x7f,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_COORD_EXP(_)
// where the actual coordinate is stored
#define PKT_FLD_AR3D_ALU_COORD_COORD(_) _(AR3D_ALU_COORD,COORD,0,12,11,0,0xfff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_COORD_COORD(_)
// stored as FP20
#define PKT_FLD_AR3D_ALU_COORD_FP20(_) _(AR3D_ALU_COORD,FP20,0,20,19,0,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_COORD_FP20(_)
// --------------------------------------------------------------
// ALU Operations (AR3D_ALU_OP)
// --------------------------------------------------------------
// AR3D_ALU_OP
//     4:3  OP         opcode
//                     0=MAD
//                     1=MIN
//                     2=MAX
//                     3=CMP
//     2    SEND     send mult result to ALU N, see mapping above
//     1    RECV     use the mult result of the next ALU rather than C input
//     0    MMUL     turn on the second destination
//
// The ALU can compute one of the following per clock. The {*D} indicates
// an optional multiply
//
// o MAD = DEST = A*B +C{*D}
// o MIN = MIN (A*B, C*{D})
// o MAX = MAX (A*B, C{*D})
// o CMP = (A < 0 && A != -0) ? B: C{*D}
//
// Note that to use CMP on a predicate, you probably need an input modifer like NEG or SUB1.
// Also note that the CMP instruction matches the CMP instruction from ARB_fragment_program.
// The CMP instruction is different from that of DX9 and DX10 (which are also different from each other).
// Another note, C*{D} will be replaced by the previous ALU's multiply result if the RECV mux is turned on.
//
// The ALUs multipliers can be linked together to compute more complex functions like
// DP2A, DP3, DP4 etc.  The details are as follows:
//
// Each ALU functions like so fx2fp -> fpMULT -> fpADD -> fp2fx.  However, ALU0 has an ADD4 rather than an ADD2,
// and ALU2 has an ADD3.  These larger fpADDs can accept the outputs of the other ALU's multipliers for more 
// complex functions.  
//
// Each ALU has a RECV mux that chooses between the previous ALU's mult result or its own C input.  
// The RECV mux's result is used for all operators: MAD, MAX, MIN, and CMP.
// Each ALU besides ALU 0 has a SEND mux, which either 'sends' the result of the ALU's mult or 0: 
//   ALU 0, no SEND mux
//   ALU 1, SEND mux connects to ALU 0
//   ALU 2, SEND mux connects to ALU 0
//   ALU 3, SEND mux connects to ALU 2
//
// In table form, the interaction of the ALUs is shown below:
//   -Read horizontally as ALU N has an S or R output to ALU 0-3, where R stands for unconditional send
//   (countered by a conditional receive on the input side) and S stands for conditional send.
//   -Read vertically, ALU N has an S or R input from ALU 0-3.
//           0    1    2    3
//   ALU 0   -    R    -    - 
//       1   S    -    R    -
//       2   S    -    -    R
//       3   R    -    S    -
//
// SEND/RECV mux programming guide (- indicates don't enable either mux):
//   Function         ALU0      ALU1      ALU2      ALU3
//   4x MAD           -         -         -         -
//   2x DP2A          -         SEND      -         SEND
//   2x DP2           RECV      -         RECV      SEND
//   1x DP3A + 1xMAD  -         SEND      SEND      - 
//   1x DP3  + 1xMAD  RECV      SEND      -         - 
//   1x DP2a + 2xMAD  -         SEND      -         -
//   1x DP4           RECV      SEND      SEND      -   
//
//
// Finally, there is a dual-FP multiply mode that is enabled with the MMUL bit.  When enabled, instead
// of computing A*B+C{*D}, the quantities A*B and C{*D} are computed seperately and packed into a pair
// of FX10's.  The A*B quantity is written to the register half specified by the DEST field and the
// C{*D} parameter is written into the other half.  Any output mods are applied to both.

// Packet AR3D_ALU_OP
#define LIST_PKT_FLD_AR3D_ALU_OP(_) \
_(AR3D_ALU_OP,OP) \
_(AR3D_ALU_OP,SEND) \
_(AR3D_ALU_OP,RECV) \
_(AR3D_ALU_OP,MMUL)
#define PKT_AR3D_ALU_OP(_) _(AR3D_ALU_OP,5,FLD)
// opcode
#define PKT_FLD_AR3D_ALU_OP_OP(_) _(AR3D_ALU_OP,OP,0,2,4,3,0x3,ENM)
#define LIST_PKT_ENM_AR3D_ALU_OP_OP(_) \
_(AR3D_ALU_OP,OP,MAD,0) \
_(AR3D_ALU_OP,OP,MIN,1) \
_(AR3D_ALU_OP,OP,MAX,2) \
_(AR3D_ALU_OP,OP,CMP,3)
// send mult result to ALU N, see mapping above
#define PKT_FLD_AR3D_ALU_OP_SEND(_) _(AR3D_ALU_OP,SEND,0,1,2,2,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_OP_SEND(_)
// use the mult result of the next ALU rather than C input
#define PKT_FLD_AR3D_ALU_OP_RECV(_) _(AR3D_ALU_OP,RECV,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_OP_RECV(_)
// turn on the second destination
#define PKT_FLD_AR3D_ALU_OP_MMUL(_) _(AR3D_ALU_OP,MMUL,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_OP_MMUL(_)
// --------------------------------------------------------------
// Destination Selector (AR3D_ALU_RESSEL)
// --------------------------------------------------------------
// Select destination and any output modifiers.  The destinations are the same list as the inputs, but note
// that that some of destinations are read-only, which is listed above.  The destination can be written as fixed-point
// or floating-point.
//
// Output modifiers:  scale by 0.5, 1, 2, 4; clamp between 0.0 and 1.0; compare result to 0 and set destination to 0.0/1.0
// Note, output modifiers are performed in the precision of the destination; this is most relevant to the CCs.
// Register example:
//     destination R0.LO, CC will be performed in FX10 precision
//     destination R0, CC will be performed in FP20 precision
// Predicate example:
//     destination P0.LO, CC will be performed in FX10 precision
//     destination P0, CC will be performed in FP20 precision (and written to P0.HI)
//     destination P0.FPLO, CC will be performed in FP20 precision (and written to P0.LO)
//
// AR3D_ALU_RESSEL
//     13:12  SCALE     output modifier:  output scale, *1, *2, *4 or /2
//                      0=X1
//                      1=X2
//                      2=X4
//                      3=DIV2
//     11:11  CLAMP     output modifier:  clamp to [0.0..1.0]
//     10:9   CC        output modifier:  output compare.  Set to 0.0/1.0 if result == 0.0 / >= 0.0 / > 0.0
//                                        if destination is a predicate, set 0.0/1.0 if result != 0
//                      0=NONE
//                      1=EQ
//                      2=GT
//                      3=GEQ
//     8:2    RSEL      destination register select index.  Follows same mapping as ARGSEL_ABC
//     1:0    DSTSEL    Destination select.  Only use FP20_L if sending an FP20 output to a register that shares 2 values (predicates).  
//                      FP20 should be used in all other cases.  When not writing a predicate, FP20_L will be considered a NOP and
//                      nothing will be written.  Note, the RES bus will have the FP20 representation of the predicate value (0.0 or 1.0)
//                      if the predicate is written with the FP20 or FP20_L modifier.
//                      0=FP20_L
//                      1=FX10_L
//                      2=FX10_H
//                      3=FP20
//

// Packet AR3D_ALU_RESSEL
#define LIST_PKT_FLD_AR3D_ALU_RESSEL(_) \
_(AR3D_ALU_RESSEL,SCALE) \
_(AR3D_ALU_RESSEL,CLAMP) \
_(AR3D_ALU_RESSEL,CC) \
_(AR3D_ALU_RESSEL,RSEL) \
_(AR3D_ALU_RESSEL,DSTSEL)
#define PKT_AR3D_ALU_RESSEL(_) _(AR3D_ALU_RESSEL,14,FLD)
// output modifier:  output scale, *1, *2, *4 or /2
#define PKT_FLD_AR3D_ALU_RESSEL_SCALE(_) _(AR3D_ALU_RESSEL,SCALE,0,2,13,12,0x3,ENM)
#define LIST_PKT_ENM_AR3D_ALU_RESSEL_SCALE(_) \
_(AR3D_ALU_RESSEL,SCALE,X1,0) \
_(AR3D_ALU_RESSEL,SCALE,X2,1) \
_(AR3D_ALU_RESSEL,SCALE,X4,2) \
_(AR3D_ALU_RESSEL,SCALE,DIV2,3)
// output modifier:  clamp to [0.0..1.0]
#define PKT_FLD_AR3D_ALU_RESSEL_CLAMP(_) _(AR3D_ALU_RESSEL,CLAMP,0,1,11,11,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_RESSEL_CLAMP(_)
// output modifier:  output compare.  Set to 0.0/1.0 if result == 0.0 / >= 0.0 / > 0.0
//                   if destination is a predicate, set 0.0/1.0 if result != 0
//                   Note, output modifiers are performed in the precision of the destination
#define PKT_FLD_AR3D_ALU_RESSEL_CC(_) _(AR3D_ALU_RESSEL,CC,0,2,10,9,0x3,ENM)
#define LIST_PKT_ENM_AR3D_ALU_RESSEL_CC(_) \
_(AR3D_ALU_RESSEL,CC,NONE,0) \
_(AR3D_ALU_RESSEL,CC,SEQ,1) \
_(AR3D_ALU_RESSEL,CC,SGT,2) \
_(AR3D_ALU_RESSEL,CC,SGE,3)
// destination register select index.
#define PKT_FLD_AR3D_ALU_RESSEL_RSEL(_) _(AR3D_ALU_RESSEL,RSEL,0,7,8,2,0x7f,ENM)
#define LIST_PKT_ENM_AR3D_ALU_RESSEL_RSEL(_) \
_(AR3D_ALU_RESSEL,RSEL,R0,0) \
_(AR3D_ALU_RESSEL,RSEL,R1,1) \
_(AR3D_ALU_RESSEL,RSEL,R2,2) \
_(AR3D_ALU_RESSEL,RSEL,R3,3) \
_(AR3D_ALU_RESSEL,RSEL,R4,4) \
_(AR3D_ALU_RESSEL,RSEL,R5,5) \
_(AR3D_ALU_RESSEL,RSEL,R6,6) \
_(AR3D_ALU_RESSEL,RSEL,R7,7) \
_(AR3D_ALU_RESSEL,RSEL,R8,8) \
_(AR3D_ALU_RESSEL,RSEL,R9,9) \
_(AR3D_ALU_RESSEL,RSEL,R10,10) \
_(AR3D_ALU_RESSEL,RSEL,R11,11) \
_(AR3D_ALU_RESSEL,RSEL,R12,12) \
_(AR3D_ALU_RESSEL,RSEL,R13,13) \
_(AR3D_ALU_RESSEL,RSEL,R14,14) \
_(AR3D_ALU_RESSEL,RSEL,R15,15) \
_(AR3D_ALU_RESSEL,RSEL,S0,16) \
_(AR3D_ALU_RESSEL,RSEL,S1,17) \
_(AR3D_ALU_RESSEL,RSEL,S2,18) \
_(AR3D_ALU_RESSEL,RSEL,S3,19) \
_(AR3D_ALU_RESSEL,RSEL,S4,20) \
_(AR3D_ALU_RESSEL,RSEL,S5,21) \
_(AR3D_ALU_RESSEL,RSEL,S6,22) \
_(AR3D_ALU_RESSEL,RSEL,S7,23) \
_(AR3D_ALU_RESSEL,RSEL,RES0,24) \
_(AR3D_ALU_RESSEL,RSEL,RES1,25) \
_(AR3D_ALU_RESSEL,RSEL,RES2,26) \
_(AR3D_ALU_RESSEL,RSEL,RES3,27) \
_(AR3D_ALU_RESSEL,RSEL,IMM0,28) \
_(AR3D_ALU_RESSEL,RSEL,IMM1,29) \
_(AR3D_ALU_RESSEL,RSEL,IMM2,30) \
_(AR3D_ALU_RESSEL,RSEL,C01,31) \
_(AR3D_ALU_RESSEL,RSEL,G0,32) \
_(AR3D_ALU_RESSEL,RSEL,G1,33) \
_(AR3D_ALU_RESSEL,RSEL,G2,34) \
_(AR3D_ALU_RESSEL,RSEL,G3,35) \
_(AR3D_ALU_RESSEL,RSEL,G4,36) \
_(AR3D_ALU_RESSEL,RSEL,G5,37) \
_(AR3D_ALU_RESSEL,RSEL,G6,38) \
_(AR3D_ALU_RESSEL,RSEL,G7,39) \
_(AR3D_ALU_RESSEL,RSEL,G8,40) \
_(AR3D_ALU_RESSEL,RSEL,G9,41) \
_(AR3D_ALU_RESSEL,RSEL,G10,42) \
_(AR3D_ALU_RESSEL,RSEL,G11,43) \
_(AR3D_ALU_RESSEL,RSEL,G12,44) \
_(AR3D_ALU_RESSEL,RSEL,G13,45) \
_(AR3D_ALU_RESSEL,RSEL,G14,46) \
_(AR3D_ALU_RESSEL,RSEL,G15,47) \
_(AR3D_ALU_RESSEL,RSEL,G16,48) \
_(AR3D_ALU_RESSEL,RSEL,G17,49) \
_(AR3D_ALU_RESSEL,RSEL,G18,50) \
_(AR3D_ALU_RESSEL,RSEL,G19,51) \
_(AR3D_ALU_RESSEL,RSEL,G20,52) \
_(AR3D_ALU_RESSEL,RSEL,G21,53) \
_(AR3D_ALU_RESSEL,RSEL,G22,54) \
_(AR3D_ALU_RESSEL,RSEL,G23,55) \
_(AR3D_ALU_RESSEL,RSEL,G24,56) \
_(AR3D_ALU_RESSEL,RSEL,G25,57) \
_(AR3D_ALU_RESSEL,RSEL,G26,58) \
_(AR3D_ALU_RESSEL,RSEL,G27,59) \
_(AR3D_ALU_RESSEL,RSEL,G28,60) \
_(AR3D_ALU_RESSEL,RSEL,G29,61) \
_(AR3D_ALU_RESSEL,RSEL,G30,62) \
_(AR3D_ALU_RESSEL,RSEL,G31,63) \
_(AR3D_ALU_RESSEL,RSEL,P0,64) \
_(AR3D_ALU_RESSEL,RSEL,P1,65) \
_(AR3D_ALU_RESSEL,RSEL,P2,66) \
_(AR3D_ALU_RESSEL,RSEL,P3,67) \
_(AR3D_ALU_RESSEL,RSEL,P4,68) \
_(AR3D_ALU_RESSEL,RSEL,P5,69) \
_(AR3D_ALU_RESSEL,RSEL,P6,70) \
_(AR3D_ALU_RESSEL,RSEL,P7,71) \
_(AR3D_ALU_RESSEL,RSEL,X,72) \
_(AR3D_ALU_RESSEL,RSEL,Y,73) \
_(AR3D_ALU_RESSEL,RSEL,PCOV,74) \
_(AR3D_ALU_RESSEL,RSEL,FF,75) \
_(AR3D_ALU_RESSEL,RSEL,KC,76)
// Destination select.  Only use FP20_L if sending an FP20 output to a register that shares 2 values (predicates); FP20 should be used in all other cases.  When not writing a predicate, FP20_L will be considered a NOP and nothing will be written.  Note, the RES bus will have the FP20 representation of the predicate value (0.0 or 1.0) if the predicate is written with the FP20 or FP20_L modifier.  Output modifiers are performed in the precision of the destination.
#define PKT_FLD_AR3D_ALU_RESSEL_DSTSEL(_) _(AR3D_ALU_RESSEL,DSTSEL,0,2,1,0,0x3,ENM)
#define LIST_PKT_ENM_AR3D_ALU_RESSEL_DSTSEL(_) \
_(AR3D_ALU_RESSEL,DSTSEL,FP20,3) \
_(AR3D_ALU_RESSEL,DSTSEL,FX10_H,2) \
_(AR3D_ALU_RESSEL,DSTSEL,FX10_L,1) \
_(AR3D_ALU_RESSEL,DSTSEL,FP20_L,0)
//
// P2CX table offset: controls what indirect entry in the p2cx table gets accessed.
// INDEX auto-increments with each access to P2CX_DATA.
//

// Register AR3D_ALU_P2CX_OFFSET 
#define LIST_REG_FLD_AR3D_ALU_P2CX_OFFSET(_) \
_(AR3D_ALU,P2CX_OFFSET,INDEX)
#define REG_AR3D_ALU_P2CX_OFFSET(_) _(AR3D_ALU,P2CX_OFFSET,0x805,0x5,1,1,0x3f,0x0,NOARY,FLD)
// current read or write
// target in P2CX_DATA
#define REG_FLD_AR3D_ALU_P2CX_OFFSET_INDEX(_) _(AR3D_ALU,P2CX_OFFSET,INDEX,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_P2CX_OFFSET_INDEX(_)

// P2CX does the following operation on the pixel packet CX bit for each row.
// The pixel indexes into the P2CX table by its sequence number
// 
//  -predicate is all the predicates where predicate[0] is P0.L and
//      predicate[15] is P7.H.
//  -op, mask, and reference come from the instruction
//  -op overlaps both mask and reference.
//
// switch(op)
// { 
// case EXECUTE:    cx = EXECUTE;       break;
// case NO_EXECUTE: cx = NO_EXECUTE;    break;
// case KEEP:       cx = cx;            break;
// case INVERT:     cx = !cx;           break;
// default:
//      cx = ((predicate[15:0] & mask) == reference) ?
//              EXECUTE : NO_EXECUTE
//      break;
// }

// Register AR3D_ALU_P2CX_DATA 
#define LIST_REG_FLD_AR3D_ALU_P2CX_DATA(_) \
_(AR3D_ALU,P2CX_DATA,MASK) \
_(AR3D_ALU,P2CX_DATA,REFERENCE) \
_(AR3D_ALU,P2CX_DATA,OPCODE)
#define REG_AR3D_ALU_P2CX_DATA(_) _(AR3D_ALU,P2CX_DATA,0x806,0x6,1,1,0xffffffff,0x0,NOARY,FLD)
// Predicate mask used to mask the compare
#define REG_FLD_AR3D_ALU_P2CX_DATA_MASK(_) _(AR3D_ALU,P2CX_DATA,MASK,16,31,16,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_P2CX_DATA_MASK(_)

// Predicate value to compare against
#define REG_FLD_AR3D_ALU_P2CX_DATA_REFERENCE(_) _(AR3D_ALU,P2CX_DATA,REFERENCE,16,15,0,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_P2CX_DATA_REFERENCE(_)

// A small set of values are treated as opcodes
#define REG_FLD_AR3D_ALU_P2CX_DATA_OPCODE(_) _(AR3D_ALU,P2CX_DATA,OPCODE,32,31,0,3,0xffffffff,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_ALU_P2CX_DATA_OPCODE(_) \
_(AR3D_ALU,P2CX_DATA,OPCODE,KEEP,0) \
_(AR3D_ALU,P2CX_DATA,OPCODE,INVERT,1) \
_(AR3D_ALU,P2CX_DATA,OPCODE,EXECUTE,2) \
_(AR3D_ALU,P2CX_DATA,OPCODE,NO_EXECUTE,3)
#define AR3D_ALU_P2CX_DATA_OPCODE_KEEP                  _MK_ENUM_CONST(0)
#define AR3D_ALU_P2CX_DATA_OPCODE_INVERT                        _MK_ENUM_CONST(1)
#define AR3D_ALU_P2CX_DATA_OPCODE_EXECUTE                       _MK_ENUM_CONST(2)
#define AR3D_ALU_P2CX_DATA_OPCODE_NO_EXECUTE                    _MK_ENUM_CONST(3)

//
// Global values (available as Gxx registers)
// G0-G31 are readable.  G8-G31 are read-only.
// An ALU write (not a register write) to G[n] (where n is in the range 0-7) is mapped to G[8*interleave + n] 
// (where interleave is defined as the pixel number in the quad, 0-3).  
// This allows inter-pixel communication.  For example:
//     G0 = R0;  // pixel 0's R0 is written to G0
//               // pixel 1's R0 is written to G8
//               // pixel 2's R0 is written to G16
//               // pixel 3's R0 is written to G24
//     R0 = G0;  // each pixel's R0 gets G0 (which is pixel 0's R0); there is no aliasing on reads

// Register AR3D_ALU_GLOBALS 
#define LIST_REG_FLD_AR3D_ALU_GLOBALS(_) \
_(AR3D_ALU,GLOBALS,L10) \
_(AR3D_ALU,GLOBALS,H10) \
_(AR3D_ALU,GLOBALS,VAL)
#define REG_AR3D_ALU_GLOBALS(_) _(AR3D_ALU,GLOBALS,0x820,0x20,32,1,0xfffff,0x0,ARY,FLD)
// 10b low subfield already in s1.8 format
#define REG_FLD_AR3D_ALU_GLOBALS_L10(_) _(AR3D_ALU,GLOBALS,L10,10,9,0,3,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_GLOBALS_L10(_)

// 10b high subfield already in s1.8 format
#define REG_FLD_AR3D_ALU_GLOBALS_H10(_) _(AR3D_ALU,GLOBALS,H10,10,19,10,3,0x3ff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_GLOBALS_H10(_)

// RAST_R format, same as pixel packet registers
#define REG_FLD_AR3D_ALU_GLOBALS_VAL(_) _(AR3D_ALU,GLOBALS,VAL,20,19,0,3,0xfffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_ALU_GLOBALS_VAL(_)

//
// Immediates can hold up to 3 FP20 values, 6 FX10 values,
// or combinations of the two precisions (i.e. 1 Fp20, 4 FX10)
//
//

// Packet AR3D_ALU_IMMEDIATE
#define LIST_PKT_FLD_AR3D_ALU_IMMEDIATE(_) \
_(AR3D_ALU_IMMEDIATE,IMM2FP) \
_(AR3D_ALU_IMMEDIATE,IMM2FXH) \
_(AR3D_ALU_IMMEDIATE,IMM2FXL) \
_(AR3D_ALU_IMMEDIATE,IMM1FP) \
_(AR3D_ALU_IMMEDIATE,IMM1FXH) \
_(AR3D_ALU_IMMEDIATE,IMM1FXL) \
_(AR3D_ALU_IMMEDIATE,IMM0FP) \
_(AR3D_ALU_IMMEDIATE,IMM0FXH) \
_(AR3D_ALU_IMMEDIATE,IMM0FXL)
#define PKT_AR3D_ALU_IMMEDIATE(_) _(AR3D_ALU_IMMEDIATE,64,FLD)
// Imediate2   as FP20
#define PKT_FLD_AR3D_ALU_IMMEDIATE_IMM2FP(_) _(AR3D_ALU_IMMEDIATE,IMM2FP,0,20,63,44,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_IMMEDIATE_IMM2FP(_)
// Imediate2.H as FX10
#define PKT_FLD_AR3D_ALU_IMMEDIATE_IMM2FXH(_) _(AR3D_ALU_IMMEDIATE,IMM2FXH,0,10,63,54,0x3ff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_IMMEDIATE_IMM2FXH(_)
// Imediate2.L as FX10
#define PKT_FLD_AR3D_ALU_IMMEDIATE_IMM2FXL(_) _(AR3D_ALU_IMMEDIATE,IMM2FXL,0,10,53,44,0x3ff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_IMMEDIATE_IMM2FXL(_)
// Imediate1   as FP20
#define PKT_FLD_AR3D_ALU_IMMEDIATE_IMM1FP(_) _(AR3D_ALU_IMMEDIATE,IMM1FP,0,20,43,24,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_IMMEDIATE_IMM1FP(_)
// Imediate1.H as FX10
#define PKT_FLD_AR3D_ALU_IMMEDIATE_IMM1FXH(_) _(AR3D_ALU_IMMEDIATE,IMM1FXH,0,10,43,34,0x3ff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_IMMEDIATE_IMM1FXH(_)
// Imediate1.L as FX10
#define PKT_FLD_AR3D_ALU_IMMEDIATE_IMM1FXL(_) _(AR3D_ALU_IMMEDIATE,IMM1FXL,0,10,33,24,0x3ff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_IMMEDIATE_IMM1FXL(_)
// Imediate0   as FP20
#define PKT_FLD_AR3D_ALU_IMMEDIATE_IMM0FP(_) _(AR3D_ALU_IMMEDIATE,IMM0FP,0,20,23,4,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_IMMEDIATE_IMM0FP(_)
// Imediate0.H as FX10
#define PKT_FLD_AR3D_ALU_IMMEDIATE_IMM0FXH(_) _(AR3D_ALU_IMMEDIATE,IMM0FXH,0,10,23,14,0x3ff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_IMMEDIATE_IMM0FXH(_)
// Imediate0.L as FX10
#define PKT_FLD_AR3D_ALU_IMMEDIATE_IMM0FXL(_) _(AR3D_ALU_IMMEDIATE,IMM0FXL,0,10,13,4,0x3ff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_IMMEDIATE_IMM0FXL(_)

// Packet AR3D_ALU_DATA_VEC
#define LIST_PKT_FLD_AR3D_ALU_DATA_VEC(_) \
_(AR3D_ALU_DATA_VEC,R0) \
_(AR3D_ALU_DATA_VEC,R1) \
_(AR3D_ALU_DATA_VEC,R2) \
_(AR3D_ALU_DATA_VEC,R3) \
_(AR3D_ALU_DATA_VEC,R4) \
_(AR3D_ALU_DATA_VEC,R5) \
_(AR3D_ALU_DATA_VEC,R6) \
_(AR3D_ALU_DATA_VEC,R7) \
_(AR3D_ALU_DATA_VEC,R8) \
_(AR3D_ALU_DATA_VEC,R9) \
_(AR3D_ALU_DATA_VEC,R10) \
_(AR3D_ALU_DATA_VEC,R11) \
_(AR3D_ALU_DATA_VEC,R12) \
_(AR3D_ALU_DATA_VEC,R13) \
_(AR3D_ALU_DATA_VEC,R14) \
_(AR3D_ALU_DATA_VEC,R15) \
_(AR3D_ALU_DATA_VEC,S0) \
_(AR3D_ALU_DATA_VEC,S1) \
_(AR3D_ALU_DATA_VEC,S2) \
_(AR3D_ALU_DATA_VEC,S3) \
_(AR3D_ALU_DATA_VEC,S4) \
_(AR3D_ALU_DATA_VEC,S5) \
_(AR3D_ALU_DATA_VEC,S6) \
_(AR3D_ALU_DATA_VEC,S7) \
_(AR3D_ALU_DATA_VEC,G0) \
_(AR3D_ALU_DATA_VEC,G1) \
_(AR3D_ALU_DATA_VEC,G2) \
_(AR3D_ALU_DATA_VEC,G3) \
_(AR3D_ALU_DATA_VEC,G4) \
_(AR3D_ALU_DATA_VEC,G5) \
_(AR3D_ALU_DATA_VEC,G6) \
_(AR3D_ALU_DATA_VEC,G7) \
_(AR3D_ALU_DATA_VEC,P0) \
_(AR3D_ALU_DATA_VEC,P1) \
_(AR3D_ALU_DATA_VEC,P2) \
_(AR3D_ALU_DATA_VEC,P3) \
_(AR3D_ALU_DATA_VEC,P4) \
_(AR3D_ALU_DATA_VEC,P5) \
_(AR3D_ALU_DATA_VEC,P6) \
_(AR3D_ALU_DATA_VEC,P7) \
_(AR3D_ALU_DATA_VEC,P8) \
_(AR3D_ALU_DATA_VEC,P9) \
_(AR3D_ALU_DATA_VEC,P10) \
_(AR3D_ALU_DATA_VEC,P11) \
_(AR3D_ALU_DATA_VEC,P12) \
_(AR3D_ALU_DATA_VEC,P13) \
_(AR3D_ALU_DATA_VEC,P14) \
_(AR3D_ALU_DATA_VEC,P15) \
_(AR3D_ALU_DATA_VEC,KC) \
_(AR3D_ALU_DATA_VEC,R0_15) \
_(AR3D_ALU_DATA_VEC,S0_7)
#define PKT_AR3D_ALU_DATA_VEC(_) _(AR3D_ALU_DATA_VEC,659,FLD)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R0(_) _(AR3D_ALU_DATA_VEC,R0,0,20,19,0,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R0(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R1(_) _(AR3D_ALU_DATA_VEC,R1,0,20,39,20,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R1(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R2(_) _(AR3D_ALU_DATA_VEC,R2,0,20,59,40,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R2(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R3(_) _(AR3D_ALU_DATA_VEC,R3,0,20,79,60,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R3(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R4(_) _(AR3D_ALU_DATA_VEC,R4,0,20,99,80,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R4(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R5(_) _(AR3D_ALU_DATA_VEC,R5,0,20,119,100,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R5(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R6(_) _(AR3D_ALU_DATA_VEC,R6,0,20,139,120,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R6(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R7(_) _(AR3D_ALU_DATA_VEC,R7,0,20,159,140,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R7(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R8(_) _(AR3D_ALU_DATA_VEC,R8,0,20,179,160,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R8(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R9(_) _(AR3D_ALU_DATA_VEC,R9,0,20,199,180,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R9(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R10(_) _(AR3D_ALU_DATA_VEC,R10,0,20,219,200,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R10(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R11(_) _(AR3D_ALU_DATA_VEC,R11,0,20,239,220,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R11(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R12(_) _(AR3D_ALU_DATA_VEC,R12,0,20,259,240,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R12(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R13(_) _(AR3D_ALU_DATA_VEC,R13,0,20,279,260,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R13(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R14(_) _(AR3D_ALU_DATA_VEC,R14,0,20,299,280,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R14(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R15(_) _(AR3D_ALU_DATA_VEC,R15,0,20,319,300,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R15(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_S0(_) _(AR3D_ALU_DATA_VEC,S0,0,20,339,320,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_S0(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_S1(_) _(AR3D_ALU_DATA_VEC,S1,0,20,359,340,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_S1(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_S2(_) _(AR3D_ALU_DATA_VEC,S2,0,20,379,360,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_S2(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_S3(_) _(AR3D_ALU_DATA_VEC,S3,0,20,399,380,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_S3(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_S4(_) _(AR3D_ALU_DATA_VEC,S4,0,20,419,400,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_S4(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_S5(_) _(AR3D_ALU_DATA_VEC,S5,0,20,439,420,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_S5(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_S6(_) _(AR3D_ALU_DATA_VEC,S6,0,20,459,440,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_S6(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_S7(_) _(AR3D_ALU_DATA_VEC,S7,0,20,479,460,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_S7(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_G0(_) _(AR3D_ALU_DATA_VEC,G0,0,20,499,480,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_G0(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_G1(_) _(AR3D_ALU_DATA_VEC,G1,0,20,519,500,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_G1(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_G2(_) _(AR3D_ALU_DATA_VEC,G2,0,20,539,520,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_G2(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_G3(_) _(AR3D_ALU_DATA_VEC,G3,0,20,559,540,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_G3(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_G4(_) _(AR3D_ALU_DATA_VEC,G4,0,20,579,560,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_G4(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_G5(_) _(AR3D_ALU_DATA_VEC,G5,0,20,599,580,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_G5(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_G6(_) _(AR3D_ALU_DATA_VEC,G6,0,20,619,600,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_G6(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_G7(_) _(AR3D_ALU_DATA_VEC,G7,0,20,639,620,0xfffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_G7(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P0(_) _(AR3D_ALU_DATA_VEC,P0,0,1,640,640,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P0(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P1(_) _(AR3D_ALU_DATA_VEC,P1,0,1,641,641,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P1(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P2(_) _(AR3D_ALU_DATA_VEC,P2,0,1,642,642,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P2(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P3(_) _(AR3D_ALU_DATA_VEC,P3,0,1,643,643,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P3(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P4(_) _(AR3D_ALU_DATA_VEC,P4,0,1,644,644,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P4(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P5(_) _(AR3D_ALU_DATA_VEC,P5,0,1,645,645,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P5(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P6(_) _(AR3D_ALU_DATA_VEC,P6,0,1,646,646,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P6(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P7(_) _(AR3D_ALU_DATA_VEC,P7,0,1,647,647,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P7(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P8(_) _(AR3D_ALU_DATA_VEC,P8,0,1,648,648,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P8(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P9(_) _(AR3D_ALU_DATA_VEC,P9,0,1,649,649,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P9(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P10(_) _(AR3D_ALU_DATA_VEC,P10,0,1,650,650,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P10(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P11(_) _(AR3D_ALU_DATA_VEC,P11,0,1,651,651,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P11(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P12(_) _(AR3D_ALU_DATA_VEC,P12,0,1,652,652,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P12(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P13(_) _(AR3D_ALU_DATA_VEC,P13,0,1,653,653,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P13(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P14(_) _(AR3D_ALU_DATA_VEC,P14,0,1,654,654,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P14(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_P15(_) _(AR3D_ALU_DATA_VEC,P15,0,1,655,655,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_P15(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_KC(_) _(AR3D_ALU_DATA_VEC,KC,0,3,658,656,0x7,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_KC(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_R0_15(_) _(AR3D_ALU_DATA_VEC,R0_15,0,320,319,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_R0_15(_)
#define PKT_FLD_AR3D_ALU_DATA_VEC_S0_7(_) _(AR3D_ALU_DATA_VEC,S0_7,0,160,479,320,0xffffffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_VEC_S0_7(_)

// Packet AR3D_ALU_DATA_WE
#define LIST_PKT_FLD_AR3D_ALU_DATA_WE(_) \
_(AR3D_ALU_DATA_WE,R0_LO) \
_(AR3D_ALU_DATA_WE,R0_HI) \
_(AR3D_ALU_DATA_WE,R1_LO) \
_(AR3D_ALU_DATA_WE,R1_HI) \
_(AR3D_ALU_DATA_WE,R2_LO) \
_(AR3D_ALU_DATA_WE,R2_HI) \
_(AR3D_ALU_DATA_WE,R3_LO) \
_(AR3D_ALU_DATA_WE,R3_HI) \
_(AR3D_ALU_DATA_WE,R4_LO) \
_(AR3D_ALU_DATA_WE,R4_HI) \
_(AR3D_ALU_DATA_WE,R5_LO) \
_(AR3D_ALU_DATA_WE,R5_HI) \
_(AR3D_ALU_DATA_WE,R6_LO) \
_(AR3D_ALU_DATA_WE,R6_HI) \
_(AR3D_ALU_DATA_WE,R7_LO) \
_(AR3D_ALU_DATA_WE,R7_HI) \
_(AR3D_ALU_DATA_WE,R8_LO) \
_(AR3D_ALU_DATA_WE,R8_HI) \
_(AR3D_ALU_DATA_WE,R9_LO) \
_(AR3D_ALU_DATA_WE,R9_HI) \
_(AR3D_ALU_DATA_WE,R10_LO) \
_(AR3D_ALU_DATA_WE,R10_HI) \
_(AR3D_ALU_DATA_WE,R11_LO) \
_(AR3D_ALU_DATA_WE,R11_HI) \
_(AR3D_ALU_DATA_WE,R12_LO) \
_(AR3D_ALU_DATA_WE,R12_HI) \
_(AR3D_ALU_DATA_WE,R13_LO) \
_(AR3D_ALU_DATA_WE,R13_HI) \
_(AR3D_ALU_DATA_WE,R14_LO) \
_(AR3D_ALU_DATA_WE,R14_HI) \
_(AR3D_ALU_DATA_WE,R15_LO) \
_(AR3D_ALU_DATA_WE,R15_HI) \
_(AR3D_ALU_DATA_WE,S0_LO) \
_(AR3D_ALU_DATA_WE,S0_HI) \
_(AR3D_ALU_DATA_WE,S1_LO) \
_(AR3D_ALU_DATA_WE,S1_HI) \
_(AR3D_ALU_DATA_WE,S2_LO) \
_(AR3D_ALU_DATA_WE,S2_HI) \
_(AR3D_ALU_DATA_WE,S3_LO) \
_(AR3D_ALU_DATA_WE,S3_HI) \
_(AR3D_ALU_DATA_WE,S4_LO) \
_(AR3D_ALU_DATA_WE,S4_HI) \
_(AR3D_ALU_DATA_WE,S5_LO) \
_(AR3D_ALU_DATA_WE,S5_HI) \
_(AR3D_ALU_DATA_WE,S6_LO) \
_(AR3D_ALU_DATA_WE,S6_HI) \
_(AR3D_ALU_DATA_WE,S7_LO) \
_(AR3D_ALU_DATA_WE,S7_HI) \
_(AR3D_ALU_DATA_WE,G0_LO) \
_(AR3D_ALU_DATA_WE,G0_HI) \
_(AR3D_ALU_DATA_WE,G1_LO) \
_(AR3D_ALU_DATA_WE,G1_HI) \
_(AR3D_ALU_DATA_WE,G2_LO) \
_(AR3D_ALU_DATA_WE,G2_HI) \
_(AR3D_ALU_DATA_WE,G3_LO) \
_(AR3D_ALU_DATA_WE,G3_HI) \
_(AR3D_ALU_DATA_WE,G4_LO) \
_(AR3D_ALU_DATA_WE,G4_HI) \
_(AR3D_ALU_DATA_WE,G5_LO) \
_(AR3D_ALU_DATA_WE,G5_HI) \
_(AR3D_ALU_DATA_WE,G6_LO) \
_(AR3D_ALU_DATA_WE,G6_HI) \
_(AR3D_ALU_DATA_WE,G7_LO) \
_(AR3D_ALU_DATA_WE,G7_HI) \
_(AR3D_ALU_DATA_WE,P0) \
_(AR3D_ALU_DATA_WE,P1) \
_(AR3D_ALU_DATA_WE,P2) \
_(AR3D_ALU_DATA_WE,P3) \
_(AR3D_ALU_DATA_WE,P4) \
_(AR3D_ALU_DATA_WE,P5) \
_(AR3D_ALU_DATA_WE,P6) \
_(AR3D_ALU_DATA_WE,P7) \
_(AR3D_ALU_DATA_WE,P8) \
_(AR3D_ALU_DATA_WE,P9) \
_(AR3D_ALU_DATA_WE,P10) \
_(AR3D_ALU_DATA_WE,P11) \
_(AR3D_ALU_DATA_WE,P12) \
_(AR3D_ALU_DATA_WE,P13) \
_(AR3D_ALU_DATA_WE,P14) \
_(AR3D_ALU_DATA_WE,P15) \
_(AR3D_ALU_DATA_WE,KC) \
_(AR3D_ALU_DATA_WE,R0_15) \
_(AR3D_ALU_DATA_WE,S0_7)
#define PKT_AR3D_ALU_DATA_WE(_) _(AR3D_ALU_DATA_WE,81,FLD)
#define PKT_FLD_AR3D_ALU_DATA_WE_R0_LO(_) _(AR3D_ALU_DATA_WE,R0_LO,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R0_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R0_HI(_) _(AR3D_ALU_DATA_WE,R0_HI,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R0_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R1_LO(_) _(AR3D_ALU_DATA_WE,R1_LO,0,1,2,2,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R1_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R1_HI(_) _(AR3D_ALU_DATA_WE,R1_HI,0,1,3,3,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R1_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R2_LO(_) _(AR3D_ALU_DATA_WE,R2_LO,0,1,4,4,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R2_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R2_HI(_) _(AR3D_ALU_DATA_WE,R2_HI,0,1,5,5,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R2_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R3_LO(_) _(AR3D_ALU_DATA_WE,R3_LO,0,1,6,6,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R3_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R3_HI(_) _(AR3D_ALU_DATA_WE,R3_HI,0,1,7,7,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R3_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R4_LO(_) _(AR3D_ALU_DATA_WE,R4_LO,0,1,8,8,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R4_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R4_HI(_) _(AR3D_ALU_DATA_WE,R4_HI,0,1,9,9,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R4_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R5_LO(_) _(AR3D_ALU_DATA_WE,R5_LO,0,1,10,10,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R5_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R5_HI(_) _(AR3D_ALU_DATA_WE,R5_HI,0,1,11,11,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R5_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R6_LO(_) _(AR3D_ALU_DATA_WE,R6_LO,0,1,12,12,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R6_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R6_HI(_) _(AR3D_ALU_DATA_WE,R6_HI,0,1,13,13,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R6_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R7_LO(_) _(AR3D_ALU_DATA_WE,R7_LO,0,1,14,14,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R7_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R7_HI(_) _(AR3D_ALU_DATA_WE,R7_HI,0,1,15,15,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R7_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R8_LO(_) _(AR3D_ALU_DATA_WE,R8_LO,0,1,16,16,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R8_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R8_HI(_) _(AR3D_ALU_DATA_WE,R8_HI,0,1,17,17,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R8_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R9_LO(_) _(AR3D_ALU_DATA_WE,R9_LO,0,1,18,18,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R9_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R9_HI(_) _(AR3D_ALU_DATA_WE,R9_HI,0,1,19,19,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R9_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R10_LO(_) _(AR3D_ALU_DATA_WE,R10_LO,0,1,20,20,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R10_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R10_HI(_) _(AR3D_ALU_DATA_WE,R10_HI,0,1,21,21,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R10_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R11_LO(_) _(AR3D_ALU_DATA_WE,R11_LO,0,1,22,22,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R11_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R11_HI(_) _(AR3D_ALU_DATA_WE,R11_HI,0,1,23,23,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R11_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R12_LO(_) _(AR3D_ALU_DATA_WE,R12_LO,0,1,24,24,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R12_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R12_HI(_) _(AR3D_ALU_DATA_WE,R12_HI,0,1,25,25,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R12_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R13_LO(_) _(AR3D_ALU_DATA_WE,R13_LO,0,1,26,26,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R13_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R13_HI(_) _(AR3D_ALU_DATA_WE,R13_HI,0,1,27,27,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R13_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R14_LO(_) _(AR3D_ALU_DATA_WE,R14_LO,0,1,28,28,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R14_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R14_HI(_) _(AR3D_ALU_DATA_WE,R14_HI,0,1,29,29,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R14_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R15_LO(_) _(AR3D_ALU_DATA_WE,R15_LO,0,1,30,30,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R15_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R15_HI(_) _(AR3D_ALU_DATA_WE,R15_HI,0,1,31,31,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R15_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S0_LO(_) _(AR3D_ALU_DATA_WE,S0_LO,0,1,32,32,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S0_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S0_HI(_) _(AR3D_ALU_DATA_WE,S0_HI,0,1,33,33,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S0_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S1_LO(_) _(AR3D_ALU_DATA_WE,S1_LO,0,1,34,34,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S1_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S1_HI(_) _(AR3D_ALU_DATA_WE,S1_HI,0,1,35,35,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S1_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S2_LO(_) _(AR3D_ALU_DATA_WE,S2_LO,0,1,36,36,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S2_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S2_HI(_) _(AR3D_ALU_DATA_WE,S2_HI,0,1,37,37,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S2_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S3_LO(_) _(AR3D_ALU_DATA_WE,S3_LO,0,1,38,38,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S3_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S3_HI(_) _(AR3D_ALU_DATA_WE,S3_HI,0,1,39,39,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S3_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S4_LO(_) _(AR3D_ALU_DATA_WE,S4_LO,0,1,40,40,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S4_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S4_HI(_) _(AR3D_ALU_DATA_WE,S4_HI,0,1,41,41,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S4_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S5_LO(_) _(AR3D_ALU_DATA_WE,S5_LO,0,1,42,42,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S5_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S5_HI(_) _(AR3D_ALU_DATA_WE,S5_HI,0,1,43,43,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S5_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S6_LO(_) _(AR3D_ALU_DATA_WE,S6_LO,0,1,44,44,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S6_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S6_HI(_) _(AR3D_ALU_DATA_WE,S6_HI,0,1,45,45,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S6_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S7_LO(_) _(AR3D_ALU_DATA_WE,S7_LO,0,1,46,46,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S7_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S7_HI(_) _(AR3D_ALU_DATA_WE,S7_HI,0,1,47,47,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S7_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G0_LO(_) _(AR3D_ALU_DATA_WE,G0_LO,0,1,48,48,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G0_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G0_HI(_) _(AR3D_ALU_DATA_WE,G0_HI,0,1,49,49,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G0_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G1_LO(_) _(AR3D_ALU_DATA_WE,G1_LO,0,1,50,50,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G1_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G1_HI(_) _(AR3D_ALU_DATA_WE,G1_HI,0,1,51,51,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G1_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G2_LO(_) _(AR3D_ALU_DATA_WE,G2_LO,0,1,52,52,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G2_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G2_HI(_) _(AR3D_ALU_DATA_WE,G2_HI,0,1,53,53,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G2_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G3_LO(_) _(AR3D_ALU_DATA_WE,G3_LO,0,1,54,54,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G3_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G3_HI(_) _(AR3D_ALU_DATA_WE,G3_HI,0,1,55,55,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G3_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G4_LO(_) _(AR3D_ALU_DATA_WE,G4_LO,0,1,56,56,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G4_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G4_HI(_) _(AR3D_ALU_DATA_WE,G4_HI,0,1,57,57,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G4_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G5_LO(_) _(AR3D_ALU_DATA_WE,G5_LO,0,1,58,58,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G5_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G5_HI(_) _(AR3D_ALU_DATA_WE,G5_HI,0,1,59,59,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G5_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G6_LO(_) _(AR3D_ALU_DATA_WE,G6_LO,0,1,60,60,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G6_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G6_HI(_) _(AR3D_ALU_DATA_WE,G6_HI,0,1,61,61,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G6_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G7_LO(_) _(AR3D_ALU_DATA_WE,G7_LO,0,1,62,62,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G7_LO(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_G7_HI(_) _(AR3D_ALU_DATA_WE,G7_HI,0,1,63,63,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_G7_HI(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P0(_) _(AR3D_ALU_DATA_WE,P0,0,1,64,64,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P0(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P1(_) _(AR3D_ALU_DATA_WE,P1,0,1,65,65,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P1(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P2(_) _(AR3D_ALU_DATA_WE,P2,0,1,66,66,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P2(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P3(_) _(AR3D_ALU_DATA_WE,P3,0,1,67,67,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P3(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P4(_) _(AR3D_ALU_DATA_WE,P4,0,1,68,68,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P4(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P5(_) _(AR3D_ALU_DATA_WE,P5,0,1,69,69,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P5(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P6(_) _(AR3D_ALU_DATA_WE,P6,0,1,70,70,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P6(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P7(_) _(AR3D_ALU_DATA_WE,P7,0,1,71,71,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P7(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P8(_) _(AR3D_ALU_DATA_WE,P8,0,1,72,72,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P8(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P9(_) _(AR3D_ALU_DATA_WE,P9,0,1,73,73,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P9(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P10(_) _(AR3D_ALU_DATA_WE,P10,0,1,74,74,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P10(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P11(_) _(AR3D_ALU_DATA_WE,P11,0,1,75,75,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P11(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P12(_) _(AR3D_ALU_DATA_WE,P12,0,1,76,76,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P12(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P13(_) _(AR3D_ALU_DATA_WE,P13,0,1,77,77,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P13(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P14(_) _(AR3D_ALU_DATA_WE,P14,0,1,78,78,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P14(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_P15(_) _(AR3D_ALU_DATA_WE,P15,0,1,79,79,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_P15(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_KC(_) _(AR3D_ALU_DATA_WE,KC,0,1,80,80,0x1,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_KC(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_R0_15(_) _(AR3D_ALU_DATA_WE,R0_15,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_R0_15(_)
#define PKT_FLD_AR3D_ALU_DATA_WE_S0_7(_) _(AR3D_ALU_DATA_WE,S0_7,0,16,47,32,0xffff,NOENM)
#define LIST_PKT_ENM_AR3D_ALU_DATA_WE_S0_7(_)
// --------------------------------------------------------------------------
// 
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
// 
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
// 
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
// 
// --------------------------------------------------------------------------
// 
// ar3d_dw.spec
//
// OVERVIEW:
// --------------------------------------
// DWR lives at the end of the pixel pipe before recirculating to pseq
//
// DWR uses the instruction indexed by the pixel's sequence number to
// decide whether components of that row should be written to memory.
//
// DITHERING:
// --------------------------------------
// None of the 8b components undergoes dithering on write.
// Alpha, even if in reduced precision, never gets dithered.
// The RGB components with less than 8b of precision get dithered on
// write if the surface has the DITHER bit set in the SURFDESC
// register
//
// The exact dithering algorithm is specified in ar3d_pixelpath.spec.
// INST -- dwr instruction table
//
// OP -- Opcode.  No operation is performed if one of the following is true:
//   * OP is NOP
//   * CX bit of the pixel packet is NO_EXECUTE
//   * The ST_ENABLE field selected by CONDITION_SELECT ENABLE is set to DISABLE 
//   Otherwize ST, ST_R20, or ST_R80 will perform memory stores.
//
// SURF -- Surface index.  Indexes into SURFADDR and SURFDESC tables
//
// WRITE_KILLED -- If enabled pixels are written even if not in Z_PASS state
//                  This include S_FAIL Z_FAIL, NON_CENTER, KILL states.
//
// WRITE_NON_CENTER -- If enabled pixels are written even if in NON_CENTER state
//
// ARGS -- Opcode specific fields; described below.
//
//
// ST:  --non-register store
// Data is written to memory according to certain rules 
// controlled by the SURFACE_DESCRIPTOR.  The format is defined by the
// type field of the SURFACE_DESCRIPTOR.
// Supported formats: (S=stencil, C=coverage/predicate,
//                     L=luminance, A=alpha, B=blue, G=green, R=red, 
//                     Z=depth, P=pixel_packet)
//  8 bpp:  L8, A8, B2G3R3, S8, C4X4
// 16 bpp:  L8A8, B5G6R5, A1B5G5R5, B5G5R5A1, A4B4G4R4, B4G4R4A4, Z16, Z16NL
//          A16_float, L16_float
// 32 bpp: R8G8B8A8, B8G8R8A8, L16A16_float, R11G11B10_float
// 64 bpp: R16G16B16A16_float, 
//
// Not Supported: DXT1, DXT1C, DXT3, DXT5, ETC, ETC3, ETC5, LATC1, LATC2,
//                R10G10B10_float_A2, B8G8R8G8, G8B8G8R8
//
// The data from the store comes from the pixel register starting from R0 
// except for a few special cases (alpha, depth).  All formats except
// Z, S, C and _float formats will preform logic op after conversion to output
// format if LOP_EN == ENABLE.
// Logic op is described in detail below. The raw destination color for LOP
// is sourced from R2R3
//
// If UPPER is set, the sources R0R1 and R2R3 are swapped.  For example: logic op
// raw will come from R2R3, and most pixel formats will start from R2.
//
// Format      Source  Dest_Format   Description
// L8          R0.L    bits ( 7: 0)  Luminance
//
// A8          R1.H    bits ( 7: 0)  Alpha
//
// B2G3R3      R0.L    bits ( 7: 5)  Red
//             R0.H    bits ( 4: 2)  Green
//             R1.L    bits ( 1: 0)  Blue
//
// S8          R0.L    bits ( 7: 0)  Stencil -- If this format is selected
//                                         and STENCIL_EN == ENABLE then 
//                                         stencil op is performed as
//                                         described below.
//
// C4X4        P0..P3  bits ( 3: 0)  Predicate bits
//                     bits ( 7: 4)  Padding
//
// L8A8        R0.L    bits ( 7: 0)  Luminance
//             R1.H    bits (15: 8)  Alpha
//
// B5G6R5      R0.L    bits (15:11)  Red
//             R0.H    bits (10: 5)  Green
//             R1.L    bits ( 4: 0)  Blue
//
// A1B5G5R5    R0.L    bits (15:11)  Red
//             R0.H    bits (10: 6)  Green
//             R1.L    bits ( 5: 1)  Blue
//             R1.H    bits ( 0: 0)  Alpha
//
// B5G5R5A1    R0.L    bits (14:10)  Red
//             R0.H    bits ( 9: 5)  Green
//             R1.L    bits ( 4: 0)  Blue
//             R1.H    bits (15:15)  Alpha
//
// A4B4G4R4    R0.L    bits (15:12)  Red
//             R0.H    bits (11: 8)  Green
//             R1.L    bits ( 7: 4)  Blue
//             R1.H    bits ( 3: 0)  Alpha
//
// B4G4R4A4    R0.L    bits (11: 8)  Red
//             R0.H    bits ( 7: 4)  Green
//             R1.L    bits ( 3: 0)  Blue
//             R1.H    bits (15:12)  Alpha
//
// Z16         R3      bits (15: 0)  Depth
// 
// Z16NL       R3      bits (15: 0)  Non-Linear Depth
//
// L16_float   R0      bits (15: 0)  Luminance
//
// A16_float   R1      bits (15: 0)  Alpha
//
// B8G8R8A8    R0.L    bits (23:16)  Red
//             R0.H    bits (15: 8)  Green
//             R1.L    bits ( 7: 0)  Blue
//             R1.H    bits (31:24)  Alpha
//
// R8G8B8A8    R0.L    bits ( 7: 0)  Red
//             R0.H    bits (15: 8)  Green
//             R1.L    bits (23:16)  Blue
//             R1.H    bits (31:24)  Alpha
//
// L16A16_float
//             R0      bits (15: 0)  Luminance
//             R1      bits (31:16)  Alpha
//
// R11G11B10_float
//             R0      bits (10: 0)  Red
//             R1      bits (21:11)  Green 
//             R2      bits (31:22)  Blue
// 
// R16G16B16A16_float
//             R0      bits (15: 0)  Red
//             R1      bits (31:16)  Green 
//             R2      bits (47:32)  Blue
//             R3      bits (63:48)  Alpha
//
// CONDITION_SELECT -- Selects which ST_ENABLE field can disable the ST
//
// If the ST instruction's CONDITION_SELECT field is set to:
//   * ALWAYS        -- the ST will ignore this register
//   * Z_WRITE       -- the ST will be disabled if 
//                      ((Z_TEST == DISABLE) 
//                       || (SURFACES_ENABLE[INST_DATA_SURF] == DISABLE))
//   * SURFACE_WRITE -- the ST will be disabled if 
//                            SURFACES_ENABLE[INST_DATA_SURF] == DISABLE
//
//
// ST_R20: 20 bit register store
// This opcode indicates a register store operation.  The only supported formats
// are P32_float and P128
//
// P32_float   R#.L    bits ( 9:   0) 
//             R#.H    bits ( 25: 16) 
//
// Pick byte enables set for one of RA, RB, RC, RD.  The rest are 
// disabled. RA, RB, RC, RD are selected by the lower two bits of the offset
// P128        R#.L    bits ( 9:   0)  RA.L  
//             R#.H    bits ( 25: 16)  RA.H 
//             R#.L    bits ( 41: 32)  RB.L
//             R#.H    bits ( 57: 48)  RB.H
//             R#.L    bits ( 73: 64)  RC.L
//             R#.H    bits ( 89: 80)  RC.H
//             R#.L    bits (105: 96)  RD.L
//             R#.H    bits (121:112)  RD.H
//
// REG selects which FP20 register will be stored
//
// WRITE_MASK select which registers get written where the LSB masks R0.L
//
// OFFSET_REG_EN  select between OFFSET_IMM and OFFSET_REG for array index.
//
// OFFSET_IMM  If OFFSET_REG_EN == DISABLE then the OFFSET_IMM field is used
// to index into the register array
//
// OFFSET_REG, OFFSET_MOD -- If OFSET_REG_EN == ENABLE then the value in the
// selected 10 bit register is used to index into the register array 
//
// OFFSET_TYPE -- Selects between GLOBAL and LOCAL register store access.
// GLOBAL is shared by all pixels, LOCAL is unique to each pixel in the pipe
//
//
//
// ST_R80: 80 bit register store
// This opcode indicates a register store operation.  The only supported format
// is P128
//
// P128        R0.L    bits ( 9: 0)
//             R0.H    bits (25:16)
//             R1.L    bits (41:32)
//             R1.H    bits (57:48)
//             R2.L    bits (73:64)
//             R2.H    bits (89:80)
//             R3.L    bits (104:96)
//             R3.H    bits (112:121)
//
// WRITE_MASK select which registers get written where the LSB masks R0.L
//
// OFFSET_REG_EN  select between OFFSET_IMM and OFFSET_REG for array index.
//
// OFFSET_IMM  If OFFSET_REG_EN == DISABLE then the OFFSET_IMM field is used
// to index into the register array
//
// OFFSET_REG, OFFSET_MOD -- If OFSET_REG_EN == ENABLE then the value in the
// selected 10 bit register is used to index into the register array 
//
// OFFSET_TYPE -- Selects between GLOBAL and LOCAL register store access.
// GLOBAL is shared by all pixels, LOCAL is unique to each pixel in the pipe
//
//
// GLOBAL register address is determined by 
//     SURFADDR + offset * bpp
// LOCAL register address is determined by 
//     SURFADDR + offset * bpp + pixelhash(x,y) * bpp 

// Packet ST_ARGS
#define LIST_PKT_FLD_ST_ARGS(_) \
_(ST_ARGS,STENCIL_EN) \
_(ST_ARGS,LOP_EN) \
_(ST_ARGS,UPPER) \
_(ST_ARGS,CONDITION_SELECT) \
_(ST_ARGS,RESERVED)
#define PKT_ST_ARGS(_) _(ST_ARGS,16,FLD)
//Perform stencil op on stencil value before writing
#define PKT_FLD_ST_ARGS_STENCIL_EN(_) _(ST_ARGS,STENCIL_EN,0,1,0,0,0x1,ENM)
#define LIST_PKT_ENM_ST_ARGS_STENCIL_EN(_) \
_(ST_ARGS,STENCIL_EN,DISABLE,0) \
_(ST_ARGS,STENCIL_EN,ENABLE,1)
// Perform logic op on color after dither
// but before writing
#define PKT_FLD_ST_ARGS_LOP_EN(_) _(ST_ARGS,LOP_EN,0,1,4,4,0x1,ENM)
#define LIST_PKT_ENM_ST_ARGS_LOP_EN(_) \
_(ST_ARGS,LOP_EN,DISABLE,0) \
_(ST_ARGS,LOP_EN,ENABLE,1)
// select colors starting from R2 instead of R0
// this wraps, so inputs that were R0R1R2R3 will
// now be R2R3R0R1
#define PKT_FLD_ST_ARGS_UPPER(_) _(ST_ARGS,UPPER,0,1,5,5,0x1,NOENM)
#define LIST_PKT_ENM_ST_ARGS_UPPER(_)
// which ST_ENABLE to use when deciding to store
// or not.
#define PKT_FLD_ST_ARGS_CONDITION_SELECT(_) _(ST_ARGS,CONDITION_SELECT,0,2,7,6,0x3,ENM)
#define LIST_PKT_ENM_ST_ARGS_CONDITION_SELECT(_) \
_(ST_ARGS,CONDITION_SELECT,ALWAYS,0) \
_(ST_ARGS,CONDITION_SELECT,Z_WRITE,1) \
_(ST_ARGS,CONDITION_SELECT,SURFACE_WRITE,2)
#define PKT_FLD_ST_ARGS_RESERVED(_) _(ST_ARGS,RESERVED,0,8,15,8,0xff,NOENM)
#define LIST_PKT_ENM_ST_ARGS_RESERVED(_)

// Packet ST_R20_ARGS
#define LIST_PKT_FLD_ST_R20_ARGS(_) \
_(ST_R20_ARGS,REG) \
_(ST_R20_ARGS,WRITE_MASK) \
_(ST_R20_ARGS,OFFSET_IMM) \
_(ST_R20_ARGS,OFFSET_REG) \
_(ST_R20_ARGS,OFFSET_MOD) \
_(ST_R20_ARGS,OFFSET_REG_EN) \
_(ST_R20_ARGS,OFFSET_TYPE)
#define PKT_ST_R20_ARGS(_) _(ST_R20_ARGS,16,FLD)
// Which FP20 register to store
#define PKT_FLD_ST_R20_ARGS_REG(_) _(ST_R20_ARGS,REG,0,2,1,0,0x3,ENM)
#define LIST_PKT_ENM_ST_R20_ARGS_REG(_) \
_(ST_R20_ARGS,REG,R0,0) \
_(ST_R20_ARGS,REG,R1,1) \
_(ST_R20_ARGS,REG,R2,2) \
_(ST_R20_ARGS,REG,R3,3)
// Which FX10 halves to store
#define PKT_FLD_ST_R20_ARGS_WRITE_MASK(_) _(ST_R20_ARGS,WRITE_MASK,0,2,3,2,0x3,NOENM)
#define LIST_PKT_ENM_ST_R20_ARGS_WRITE_MASK(_)
// offset -- used for array formats, 
//           index into the array if
//           OFFSET_REG_EN == DISABLE
#define PKT_FLD_ST_R20_ARGS_OFFSET_IMM(_) _(ST_R20_ARGS,OFFSET_IMM,0,8,11,4,0xff,NOENM)
#define LIST_PKT_ENM_ST_R20_ARGS_OFFSET_IMM(_)
// which register contains the 8 bit offset
#define PKT_FLD_ST_R20_ARGS_OFFSET_REG(_) _(ST_R20_ARGS,OFFSET_REG,0,2,9,8,0x3,ENM)
#define LIST_PKT_ENM_ST_R20_ARGS_OFFSET_REG(_) \
_(ST_R20_ARGS,OFFSET_REG,R0,0) \
_(ST_R20_ARGS,OFFSET_REG,R1,1) \
_(ST_R20_ARGS,OFFSET_REG,R2,2) \
_(ST_R20_ARGS,OFFSET_REG,R3,3)
// which half word contains the 8 bit offset
#define PKT_FLD_ST_R20_ARGS_OFFSET_MOD(_) _(ST_R20_ARGS,OFFSET_MOD,0,1,10,10,0x1,ENM)
#define LIST_PKT_ENM_ST_R20_ARGS_OFFSET_MOD(_) \
_(ST_R20_ARGS,OFFSET_MOD,L,0) \
_(ST_R20_ARGS,OFFSET_MOD,H,1)
// enable offset reg
#define PKT_FLD_ST_R20_ARGS_OFFSET_REG_EN(_) _(ST_R20_ARGS,OFFSET_REG_EN,0,1,14,14,0x1,ENM)
#define LIST_PKT_ENM_ST_R20_ARGS_OFFSET_REG_EN(_) \
_(ST_R20_ARGS,OFFSET_REG_EN,DISABLE,0) \
_(ST_R20_ARGS,OFFSET_REG_EN,ENABLE,1)
// Is the offset a local offset or global offset
// a local offset uses x,y,offset to determine
// address, a global offset just uses offset.
#define PKT_FLD_ST_R20_ARGS_OFFSET_TYPE(_) _(ST_R20_ARGS,OFFSET_TYPE,0,1,15,15,0x1,ENM)
#define LIST_PKT_ENM_ST_R20_ARGS_OFFSET_TYPE(_) \
_(ST_R20_ARGS,OFFSET_TYPE,LOCAL,0) \
_(ST_R20_ARGS,OFFSET_TYPE,GLOBAL,1)

// Packet ST_R80_ARGS
#define LIST_PKT_FLD_ST_R80_ARGS(_) \
_(ST_R80_ARGS,WRITE_MASK) \
_(ST_R80_ARGS,OFFSET_IMM) \
_(ST_R80_ARGS,OFFSET_REG) \
_(ST_R80_ARGS,OFFSET_MOD) \
_(ST_R80_ARGS,OFFSET_REG_EN) \
_(ST_R80_ARGS,OFFSET_TYPE)
#define PKT_ST_R80_ARGS(_) _(ST_R80_ARGS,16,FLD)
// Which FX10 registers to store
#define PKT_FLD_ST_R80_ARGS_WRITE_MASK(_) _(ST_R80_ARGS,WRITE_MASK,0,8,7,0,0xff,NOENM)
#define LIST_PKT_ENM_ST_R80_ARGS_WRITE_MASK(_)
// offset -- used for array formats, 
//          index into the array if
//          OFFSET_REG_EN == DISABLE
#define PKT_FLD_ST_R80_ARGS_OFFSET_IMM(_) _(ST_R80_ARGS,OFFSET_IMM,0,6,13,8,0x3f,NOENM)
#define LIST_PKT_ENM_ST_R80_ARGS_OFFSET_IMM(_)
// which register contains the 8 bit offset
#define PKT_FLD_ST_R80_ARGS_OFFSET_REG(_) _(ST_R80_ARGS,OFFSET_REG,0,2,9,8,0x3,ENM)
#define LIST_PKT_ENM_ST_R80_ARGS_OFFSET_REG(_) \
_(ST_R80_ARGS,OFFSET_REG,R0,0) \
_(ST_R80_ARGS,OFFSET_REG,R1,1) \
_(ST_R80_ARGS,OFFSET_REG,R2,2) \
_(ST_R80_ARGS,OFFSET_REG,R3,3)
// which half word contains the 8 bit offset
#define PKT_FLD_ST_R80_ARGS_OFFSET_MOD(_) _(ST_R80_ARGS,OFFSET_MOD,0,1,10,10,0x1,ENM)
#define LIST_PKT_ENM_ST_R80_ARGS_OFFSET_MOD(_) \
_(ST_R80_ARGS,OFFSET_MOD,L,0) \
_(ST_R80_ARGS,OFFSET_MOD,H,1)
// enable offset reg
#define PKT_FLD_ST_R80_ARGS_OFFSET_REG_EN(_) _(ST_R80_ARGS,OFFSET_REG_EN,0,1,14,14,0x1,ENM)
#define LIST_PKT_ENM_ST_R80_ARGS_OFFSET_REG_EN(_) \
_(ST_R80_ARGS,OFFSET_REG_EN,DISABLE,0) \
_(ST_R80_ARGS,OFFSET_REG_EN,ENABLE,1)
//Is the offset a local offset or global offset
//a local offset uses x,y,offset to determine
//address, a global offset just uses offset.
#define PKT_FLD_ST_R80_ARGS_OFFSET_TYPE(_) _(ST_R80_ARGS,OFFSET_TYPE,0,1,15,15,0x1,ENM)
#define LIST_PKT_ENM_ST_R80_ARGS_OFFSET_TYPE(_) \
_(ST_R80_ARGS,OFFSET_TYPE,LOCAL,0) \
_(ST_R80_ARGS,OFFSET_TYPE,GLOBAL,1)
//
// Instruction table offset: controls what indirect entry in the instruction table gets accessed.
// INDEX auto-increments with each access to INST_DATA.
//

// Register AR3D_DW_INST_OFFSET 
#define LIST_REG_FLD_AR3D_DW_INST_OFFSET(_) \
_(AR3D_DW,INST_OFFSET,INDEX)
#define REG_AR3D_DW_INST_OFFSET(_) _(AR3D_DW,INST_OFFSET,0x900,0x0,1,1,0x3f,0x0,NOARY,FLD)
// current read or write target in INST_DATA
#define REG_FLD_AR3D_DW_INST_OFFSET_INDEX(_) _(AR3D_DW,INST_OFFSET,INDEX,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_DW_INST_OFFSET_INDEX(_)

//
// Instruction indirect port.
//

// Register AR3D_DW_INST_DATA // INST_DATA is indexed by INST_OFFSET, and will increment INST_OFFSET
// on reads or writes
//
#define LIST_REG_FLD_AR3D_DW_INST_DATA(_) \
_(AR3D_DW,INST_DATA,OP) \
_(AR3D_DW,INST_DATA,SURF) \
_(AR3D_DW,INST_DATA,WRITE_KILLED) \
_(AR3D_DW,INST_DATA,WRITE_NON_CENTER) \
_(AR3D_DW,INST_DATA,CACHE_PERSISTENT) \
_(AR3D_DW,INST_DATA,CACHE_READ_CLEAN) \
_(AR3D_DW,INST_DATA,ARGS)
#define REG_AR3D_DW_INST_DATA(_) _(AR3D_DW,INST_DATA,0x901,0x1,1,1,0x3ffffff,0x0,NOARY,FLD)
// Opcode values can be:
// NOP     -- no store is performed
// ST      -- normal store to memory
// ST_R20  -- store a FP20 and C to memory
// ST_R80 -- store a FX10x8 to memory
#define REG_FLD_AR3D_DW_INST_DATA_OP(_) _(AR3D_DW,INST_DATA,OP,2,1,0,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_INST_DATA_OP(_) \
_(AR3D_DW,INST_DATA,OP,NOP,0) \
_(AR3D_DW,INST_DATA,OP,ST,1) \
_(AR3D_DW,INST_DATA,OP,ST_R20,2) \
_(AR3D_DW,INST_DATA,OP,ST_R80,3)
#define AR3D_DW_INST_DATA_OP_NOP                        _MK_ENUM_CONST(0)
#define AR3D_DW_INST_DATA_OP_ST                 _MK_ENUM_CONST(1)
#define AR3D_DW_INST_DATA_OP_ST_R20                     _MK_ENUM_CONST(2)
#define AR3D_DW_INST_DATA_OP_ST_R80                     _MK_ENUM_CONST(3)

// Specifies which surface descriptor to use
#define REG_FLD_AR3D_DW_INST_DATA_SURF(_) _(AR3D_DW,INST_DATA,SURF,4,5,2,3,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_DW_INST_DATA_SURF(_)

// If ENABLED write pixel even if not in Z_PASS state.
#define REG_FLD_AR3D_DW_INST_DATA_WRITE_KILLED(_) _(AR3D_DW,INST_DATA,WRITE_KILLED,1,6,6,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_INST_DATA_WRITE_KILLED(_) \
_(AR3D_DW,INST_DATA,WRITE_KILLED,DISABLE,0) \
_(AR3D_DW,INST_DATA,WRITE_KILLED,ENABLE,1)
#define AR3D_DW_INST_DATA_WRITE_KILLED_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_DW_INST_DATA_WRITE_KILLED_ENABLE                   _MK_ENUM_CONST(1)

// If ENABLED write pixel even if in NON_CENTER state.
#define REG_FLD_AR3D_DW_INST_DATA_WRITE_NON_CENTER(_) _(AR3D_DW,INST_DATA,WRITE_NON_CENTER,1,7,7,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_INST_DATA_WRITE_NON_CENTER(_) \
_(AR3D_DW,INST_DATA,WRITE_NON_CENTER,DISABLE,0) \
_(AR3D_DW,INST_DATA,WRITE_NON_CENTER,ENABLE,1)
#define AR3D_DW_INST_DATA_WRITE_NON_CENTER_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_DW_INST_DATA_WRITE_NON_CENTER_ENABLE                       _MK_ENUM_CONST(1)

// Should FDC try to hold on to this data
#define REG_FLD_AR3D_DW_INST_DATA_CACHE_PERSISTENT(_) _(AR3D_DW,INST_DATA,CACHE_PERSISTENT,1,8,8,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_DW_INST_DATA_CACHE_PERSISTENT(_)

// Should FDC throw away this data on read
#define REG_FLD_AR3D_DW_INST_DATA_CACHE_READ_CLEAN(_) _(AR3D_DW,INST_DATA,CACHE_READ_CLEAN,1,9,9,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_DW_INST_DATA_CACHE_READ_CLEAN(_)

// Arguments for opcode
// (ST_ARGS, ST_R20_ARGS, or ST_R80_ARGS)
#define REG_FLD_AR3D_DW_INST_DATA_ARGS(_) _(AR3D_DW,INST_DATA,ARGS,16,25,10,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_DW_INST_DATA_ARGS(_)

// all the fragment op control goes here (s=source, d=destination).  The result
// of these ops are written to the calculated memory location (based on x,y and
// SURFDESC) m=mem[calcaddr] d=R0.l.
// KEEP        m = d
// ZERO        m = 0
// REPLACE     m = ref
// INCR        m = sat(d+1)
// DECR        m = sat(d-1)
// INVERT      m = ~d
// INCR_WRAP   m = wrap(d+1)
// DECR_WRAP   m = wrap(d-1)
//
// logic op: (m=mem[calcaddr], s=formatconvert(R0R1), d=raw(R2R3)
// CLEAR                  m = all bits cleared (0)
// AND                    m = s & d
// AND_REVERSE    m = s & ~d
// COPY                   m = s
// AND_INVERTED   m = ~s & d
// NOOP                   m = d
// XOR                    m = s ^ d
// OR                     m = s | d
// NOR                    m = ~(s | d)
// EQUIV                  m = ~(s ^ d)
// INVERT                 m = ~d
// OR_REVERSE     m = s | ~d
// COPY_INVERTED  m = ~s
// OR_INVERTED    m = ~s | d
// NAND                   m = ~(s & d)
// SET                    m = all bits set (0xffffffff)
// See S_OPERATION for stencil op details

// Register AR3D_DW_LOGIC_OP 
#define LIST_REG_FLD_AR3D_DW_LOGIC_OP(_) \
_(AR3D_DW,LOGIC_OP,OP)
#define REG_AR3D_DW_LOGIC_OP(_) _(AR3D_DW,LOGIC_OP,0x902,0x2,1,1,0xf,0x0,NOARY,FLD)
// logic op (always operates with R0R1 as source (s) 
// and R2R3 as destination (d))
#define REG_FLD_AR3D_DW_LOGIC_OP_OP(_) _(AR3D_DW,LOGIC_OP,OP,4,3,0,3,0xf,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_LOGIC_OP_OP(_) \
_(AR3D_DW,LOGIC_OP,OP,CLEAR,0) \
_(AR3D_DW,LOGIC_OP,OP,AND,1) \
_(AR3D_DW,LOGIC_OP,OP,AND_REVERSE,2) \
_(AR3D_DW,LOGIC_OP,OP,COPY,3) \
_(AR3D_DW,LOGIC_OP,OP,AND_INVERTED,4) \
_(AR3D_DW,LOGIC_OP,OP,NOOP,5) \
_(AR3D_DW,LOGIC_OP,OP,XOR,6) \
_(AR3D_DW,LOGIC_OP,OP,OR,7) \
_(AR3D_DW,LOGIC_OP,OP,NOR,8) \
_(AR3D_DW,LOGIC_OP,OP,EQUIV,9) \
_(AR3D_DW,LOGIC_OP,OP,INVERT,10) \
_(AR3D_DW,LOGIC_OP,OP,OR_REVERSE,11) \
_(AR3D_DW,LOGIC_OP,OP,COPY_INVERTED,12) \
_(AR3D_DW,LOGIC_OP,OP,OR_INVERTED,13) \
_(AR3D_DW,LOGIC_OP,OP,NAND,14) \
_(AR3D_DW,LOGIC_OP,OP,SET,15)
#define AR3D_DW_LOGIC_OP_OP_CLEAR                       _MK_ENUM_CONST(0)
#define AR3D_DW_LOGIC_OP_OP_AND                 _MK_ENUM_CONST(1)
#define AR3D_DW_LOGIC_OP_OP_AND_REVERSE                 _MK_ENUM_CONST(2)
#define AR3D_DW_LOGIC_OP_OP_COPY                        _MK_ENUM_CONST(3)
#define AR3D_DW_LOGIC_OP_OP_AND_INVERTED                        _MK_ENUM_CONST(4)
#define AR3D_DW_LOGIC_OP_OP_NOOP                        _MK_ENUM_CONST(5)
#define AR3D_DW_LOGIC_OP_OP_XOR                 _MK_ENUM_CONST(6)
#define AR3D_DW_LOGIC_OP_OP_OR                  _MK_ENUM_CONST(7)
#define AR3D_DW_LOGIC_OP_OP_NOR                 _MK_ENUM_CONST(8)
#define AR3D_DW_LOGIC_OP_OP_EQUIV                       _MK_ENUM_CONST(9)
#define AR3D_DW_LOGIC_OP_OP_INVERT                      _MK_ENUM_CONST(10)
#define AR3D_DW_LOGIC_OP_OP_OR_REVERSE                  _MK_ENUM_CONST(11)
#define AR3D_DW_LOGIC_OP_OP_COPY_INVERTED                       _MK_ENUM_CONST(12)
#define AR3D_DW_LOGIC_OP_OP_OR_INVERTED                 _MK_ENUM_CONST(13)
#define AR3D_DW_LOGIC_OP_OP_NAND                        _MK_ENUM_CONST(14)
#define AR3D_DW_LOGIC_OP_OP_SET                 _MK_ENUM_CONST(15)

// ST_ENABLE enables/disables properly flagged ST instructions
//
// If the ST instruction's CONDITION_SELECT field is set to:
//   * ALWAYS        -- the ST will ignore this register
//   * Z_WRITE       -- the ST will be disabled if 
//                      ((Z_TEST == DISABLE) 
//                       || (SURFACES_ENABLE[INST_DATA_SURF] == DISABLE))
//   * SURFACE_WRITE -- the ST will be disabled if 
//                            SURFACES_ENABLE[INST_DATA_SURF] == DISABLE

// Register AR3D_DW_ST_ENABLE 
#define LIST_REG_FLD_AR3D_DW_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_0_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_1_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_2_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_3_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_4_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_5_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_6_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_7_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_8_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_9_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_10_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_11_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_12_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_13_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_14_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACE_15_ST_ENABLE) \
_(AR3D_DW,ST_ENABLE,SURFACES_ENABLE) \
_(AR3D_DW,ST_ENABLE,Z_TEST)
#define REG_AR3D_DW_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,0x903,0x3,1,1,0x1ffff,0x0,NOARY,FLD)
#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_0_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_0_ST_ENABLE,1,0,0,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_0_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_0_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_0_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_0_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_0_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_1_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_1_ST_ENABLE,1,1,1,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_1_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_1_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_1_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_1_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_1_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_2_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_2_ST_ENABLE,1,2,2,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_2_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_2_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_2_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_2_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_2_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_3_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_3_ST_ENABLE,1,3,3,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_3_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_3_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_3_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_3_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_3_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_4_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_4_ST_ENABLE,1,4,4,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_4_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_4_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_4_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_4_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_4_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_5_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_5_ST_ENABLE,1,5,5,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_5_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_5_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_5_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_5_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_5_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_6_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_6_ST_ENABLE,1,6,6,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_6_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_6_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_6_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_6_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_6_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_7_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_7_ST_ENABLE,1,7,7,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_7_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_7_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_7_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_7_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_7_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_8_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_8_ST_ENABLE,1,8,8,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_8_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_8_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_8_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_8_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_8_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_9_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_9_ST_ENABLE,1,9,9,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_9_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_9_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_9_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_9_ST_ENABLE_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_9_ST_ENABLE_ENABLE                    _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_10_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_10_ST_ENABLE,1,10,10,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_10_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_10_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_10_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_10_ST_ENABLE_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_10_ST_ENABLE_ENABLE                   _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_11_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_11_ST_ENABLE,1,11,11,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_11_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_11_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_11_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_11_ST_ENABLE_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_11_ST_ENABLE_ENABLE                   _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_12_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_12_ST_ENABLE,1,12,12,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_12_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_12_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_12_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_12_ST_ENABLE_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_12_ST_ENABLE_ENABLE                   _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_13_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_13_ST_ENABLE,1,13,13,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_13_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_13_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_13_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_13_ST_ENABLE_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_13_ST_ENABLE_ENABLE                   _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_14_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_14_ST_ENABLE,1,14,14,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_14_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_14_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_14_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_14_ST_ENABLE_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_14_ST_ENABLE_ENABLE                   _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACE_15_ST_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACE_15_ST_ENABLE,1,15,15,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACE_15_ST_ENABLE(_) \
_(AR3D_DW,ST_ENABLE,SURFACE_15_ST_ENABLE,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,SURFACE_15_ST_ENABLE,ENABLE,1)
#define AR3D_DW_ST_ENABLE_SURFACE_15_ST_ENABLE_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_SURFACE_15_ST_ENABLE_ENABLE                   _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_DW_ST_ENABLE_SURFACES_ENABLE(_) _(AR3D_DW,ST_ENABLE,SURFACES_ENABLE,16,15,0,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_SURFACES_ENABLE(_)

// can disable ST with 
// CONDITION_SELECT == Z_WRITE
#define REG_FLD_AR3D_DW_ST_ENABLE_Z_TEST(_) _(AR3D_DW,ST_ENABLE,Z_TEST,1,16,16,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_DW_ST_ENABLE_Z_TEST(_) \
_(AR3D_DW,ST_ENABLE,Z_TEST,DISABLE,0) \
_(AR3D_DW,ST_ENABLE,Z_TEST,ENABLE,1)
#define AR3D_DW_ST_ENABLE_Z_TEST_DISABLE                        _MK_ENUM_CONST(0)
#define AR3D_DW_ST_ENABLE_Z_TEST_ENABLE                 _MK_ENUM_CONST(1)

// --------------------------------------------------------------------------
//
// Copyright (c) 2005, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
// 
// This file has all the reg definitions related to FDC unit in AR20
// This file is included by ar3d.spec
// --------------------------------------------------------------------------
// FDC notes:
//
// - FDC is a unified cache for the 3D QRAST, PSEQ, and DWR clients.
// Each read and write client has multiple 64-bit L1 latency-hiding
// buffers, and the L2 cache is a fully associative, 64 line x 256 bit =
// 2 KByte write-back cache that has tags based on the GPU address. 
// - FDC register accesses are received through the QRAST interface and
// are immediately updated even if there are outstanding FDC transactions
// later in the pipe (such as PSEQ/DWR). Thus changing FDC registers may
// have an affect on operations that entered the 3D pipe before the FDC
// register operation. Changing FDC registers is generally okay during 
// a non-idle 3D pipe, with exceptions noted in the register definitions.
// - FDC will flush the cache to MC in the background, and do a full flush
// when a Raise is received by DWR, or is the FLUSH register field is set.
//
// --------------------------------------------------------------------------
//
// register definitions
//
#define NV_FDC_MAX_LINES_CNT_WIDTH      9
//
// Main control register for FDC, notes:
//   flush: Note that fdc is auto-flushed on a gr3d raise/wait when
//          dwr receives the raise, and dwr will not release the raise
//          until the flush has completed. This register is provided
//          as an alternative way to flush the fdc cache without using
//          a raise/wait. The flush bit will be auto-reset to 0 after
//          flush is complete so sw can poll this register to determine
//          when the flush is complete. The 3d pipe should be idle before
//          writing to this flush register. The reason is that fdc will
//          receive the register write at its qrast ports, but fdc does not
//          know whether dwr is active or idle, so dwr may still be
//          writing when fdc does the flush. If the 3d pipe is not idle,
//          Fdc still guarantees correctness (ie, no data will be dropped
//          or corrupted), but there is no guarantee on whether active
//          dwr writes made it in before the flush and will be flushed to
//          memory or whether they are too late and will remain dirty
//          in the cache.
//
//   invalidate: the pipeline MUST be idle before invalidating the fdc
//               cache, otherwise corruption/hw freeze can occur
//               The proper way to invalidate the cache is:
//                 (1) issue raise/wait to idle pipeline (which also forces a flush)
//                 (2) write 1 to CONTROL.INVALIDATE
//                 (3) issue raise/wait to ensure reads don't get into
//                     pipeline before fdc receives invalidate request
//
// Programming note regarding fdc buffer synchronization:
// (1) if fdc is only reading from a buffer that another (non-fdc) unit needs 
//     to write to, then fdc should be idle while the other unit is writing,
//     and fdc must be invalidated before starting to read the modified buffer   
// (2) if fdc is only writing to a buffer that another (non-fdc) unit needs to
//     read from, then fdc must be flushed before the other unit starts reading
//     from the buffer, and fdc should be idle while the other unit is reading
// (3) if fdc is reading from and writing to a buffer that another (non-fdc)
//     unit needs to access to, then fdc should be flushed, then the other unit
//     can begin accessing the buffer while fdc remains idle, and after the 
//     other unit is done accessing the buffer, fdc must be invalidated.
//

// Register AR3D_FDC_CONTROL // FDC Main Control Register
#define LIST_REG_FLD_AR3D_FDC_CONTROL(_) \
_(AR3D_FDC,CONTROL,INVALIDATE) \
_(AR3D_FDC,CONTROL,FLUSH) \
_(AR3D_FDC,CONTROL,STRICT_RI_ARB) \
_(AR3D_FDC,CONTROL,STRICT_L2_ARB) \
_(AR3D_FDC,CONTROL,DISABLE_AUTO_FLUSH) \
_(AR3D_FDC,CONTROL,PERSISTENT_CLEAR) \
_(AR3D_FDC,CONTROL,STRICT_MC_WR_ARB) \
_(AR3D_FDC,CONTROL,DISABLE_PERSISTENT) \
_(AR3D_FDC,CONTROL,DISABLE_READ_CLEAN) \
_(AR3D_FDC,CONTROL,STRICT_DP_Q_RI_ARB) \
_(AR3D_FDC,CONTROL,MCCIF_PORT_ASSIGN) \
_(AR3D_FDC,CONTROL,READ_BUF_MIN_LINE)
#define REG_AR3D_FDC_CONTROL(_) _(AR3D_FDC,CONTROL,0xa00,0x0,1,1,0xfff,0xe00,NOARY,FLD)
// invalidate entire cache, auto-reset to 0 when complete
#define REG_FLD_AR3D_FDC_CONTROL_INVALIDATE(_) _(AR3D_FDC,CONTROL,INVALIDATE,1,0,0,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_INVALIDATE(_)

// flush entire cache, auto-reset to zero when complete
#define REG_FLD_AR3D_FDC_CONTROL_FLUSH(_) _(AR3D_FDC,CONTROL,FLUSH,1,1,1,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_FLUSH(_)

// keep request interface arbitration between QRAST z and
// stencil+vcaa in strict order 
#define REG_FLD_AR3D_FDC_CONTROL_STRICT_RI_ARB(_) _(AR3D_FDC,CONTROL,STRICT_RI_ARB,1,2,2,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_STRICT_RI_ARB(_)

// keep L2 arbitration between QRAST z and stencil+vcaa 
// in strict order
#define REG_FLD_AR3D_FDC_CONTROL_STRICT_L2_ARB(_) _(AR3D_FDC,CONTROL,STRICT_L2_ARB,1,3,3,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_STRICT_L2_ARB(_)

// disable auto flush feature
#define REG_FLD_AR3D_FDC_CONTROL_DISABLE_AUTO_FLUSH(_) _(AR3D_FDC,CONTROL,DISABLE_AUTO_FLUSH,1,4,4,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_DISABLE_AUTO_FLUSH(_)

// command to clear persistent bits
// of all cache lines
#define REG_FLD_AR3D_FDC_CONTROL_PERSISTENT_CLEAR(_) _(AR3D_FDC,CONTROL,PERSISTENT_CLEAR,1,5,5,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_PERSISTENT_CLEAR(_)

// If set to 1, memory reads have absolute priority
// when writing data to L2. 
// If set to 0, ping-pong arbitration between memory
// reads writing to L2 client writing to L2 applies.
#define REG_FLD_AR3D_FDC_CONTROL_STRICT_MC_WR_ARB(_) _(AR3D_FDC,CONTROL,STRICT_MC_WR_ARB,1,6,6,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_STRICT_MC_WR_ARB(_)

// causes fdc to ignore the persistent attribute
// of all client requests (everything marked as
// non-persistent)
#define REG_FLD_AR3D_FDC_CONTROL_DISABLE_PERSISTENT(_) _(AR3D_FDC,CONTROL,DISABLE_PERSISTENT,1,7,7,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_DISABLE_PERSISTENT(_)

// causes fdc to ignore the read_clean attribute
// of all client requests (everything marked as 
// non-read_clean)
#define REG_FLD_AR3D_FDC_CONTROL_DISABLE_READ_CLEAN(_) _(AR3D_FDC,CONTROL,DISABLE_READ_CLEAN,1,8,8,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_DISABLE_READ_CLEAN(_)

// keep request interface arbitration between PSEQ/DWR and
// QRAST clients in strict order 
#define REG_FLD_AR3D_FDC_CONTROL_STRICT_DP_Q_RI_ARB(_) _(AR3D_FDC,CONTROL,STRICT_DP_Q_RI_ARB,1,9,9,3,0x1,0x1,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_STRICT_DP_Q_RI_ARB(_)

// FDC MCCIF client assignment. This bit controls whether FDC
// splits MC accesses between MCCIFs according to their
// destination or according to the which memory bank is being
// accessed EXT_INT:  Internal/External memory
// EVEN_ODD: Even/Odd memory accesses 
#define REG_FLD_AR3D_FDC_CONTROL_MCCIF_PORT_ASSIGN(_) _(AR3D_FDC,CONTROL,MCCIF_PORT_ASSIGN,1,10,10,3,0x1,0x1,EVEN_ODD,ENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_MCCIF_PORT_ASSIGN(_) \
_(AR3D_FDC,CONTROL,MCCIF_PORT_ASSIGN,EXT_INT,0) \
_(AR3D_FDC,CONTROL,MCCIF_PORT_ASSIGN,EVEN_ODD,1)
#define AR3D_FDC_CONTROL_MCCIF_PORT_ASSIGN_EXT_INT                      _MK_ENUM_CONST(0)
#define AR3D_FDC_CONTROL_MCCIF_PORT_ASSIGN_EVEN_ODD                     _MK_ENUM_CONST(1)

// allow each read buffer to lock at least one cache line
// even if client hit max line count
#define REG_FLD_AR3D_FDC_CONTROL_READ_BUF_MIN_LINE(_) _(AR3D_FDC,CONTROL,READ_BUF_MIN_LINE,1,11,11,3,0x1,0x1,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_CONTROL_READ_BUF_MIN_LINE(_)

//
// status register
//

// Register AR3D_FDC_STATUS // FDC Status Register
#define LIST_REG_FLD_AR3D_FDC_STATUS(_) \
_(AR3D_FDC,STATUS,FLUSH_DONE) \
_(AR3D_FDC,STATUS,CSIM_SHUTDOWN_STATUS)
#define REG_AR3D_FDC_STATUS(_) _(AR3D_FDC,STATUS,0xa01,0x1,1,1,0x80000001,0x0,NOARY,FLD)
// set when flush completed
#define REG_FLD_AR3D_FDC_STATUS_FLUSH_DONE(_) _(AR3D_FDC,STATUS,FLUSH_DONE,1,0,0,1,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_STATUS_FLUSH_DONE(_)

// csim simulation use only
// set to 1 when self-checking fdc csim
// code detects an error at shutdown
#define REG_FLD_AR3D_FDC_STATUS_CSIM_SHUTDOWN_STATUS(_) _(AR3D_FDC,STATUS,CSIM_SHUTDOWN_STATUS,1,31,31,1,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_STATUS_CSIM_SHUTDOWN_STATUS(_)

//
// Client max line counts
// - *_NO_SHADER_DEFAULT are used by sw to reprogram the max lines
//   registers when pseq is not active
//
#define AR3D_FDC_MAX_QZ_LINES_NO_SHADER_DEFAULT 511

// Register AR3D_FDC_MAX_QZ_LINES // Maximum Line Count for QRAST Z Reads
#define LIST_REG_FLD_AR3D_FDC_MAX_QZ_LINES(_) \
_(AR3D_FDC,MAX_QZ_LINES,MAX_QZ_LINES)
#define REG_AR3D_FDC_MAX_QZ_LINES(_) _(AR3D_FDC,MAX_QZ_LINES,0xa02,0x2,1,1,0x1ff,0x1ff,NOARY,FLD)
// max number of L2 cache lines allowed
// to be locked by qrast z 
#define REG_FLD_AR3D_FDC_MAX_QZ_LINES_MAX_QZ_LINES(_) _(AR3D_FDC,MAX_QZ_LINES,MAX_QZ_LINES,9,8,0,3,0x1ff,0x1ff,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_MAX_QZ_LINES_MAX_QZ_LINES(_)

#define AR3D_FDC_MAX_QV_LINES_NO_SHADER_DEFAULT 511

// Register AR3D_FDC_MAX_QV_LINES // Maximum Line Count for QRAST VCAA Reads
#define LIST_REG_FLD_AR3D_FDC_MAX_QV_LINES(_) \
_(AR3D_FDC,MAX_QV_LINES,MAX_QV_LINES)
#define REG_AR3D_FDC_MAX_QV_LINES(_) _(AR3D_FDC,MAX_QV_LINES,0xa03,0x3,1,1,0x1ff,0x1ff,NOARY,FLD)
// max number of L2 cache lines allowed
// to be locked by qrast vcaa
#define REG_FLD_AR3D_FDC_MAX_QV_LINES_MAX_QV_LINES(_) _(AR3D_FDC,MAX_QV_LINES,MAX_QV_LINES,9,8,0,3,0x1ff,0x1ff,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_MAX_QV_LINES_MAX_QV_LINES(_)

#define AR3D_FDC_MAX_QS_LINES_NO_SHADER_DEFAULT 511

// Register AR3D_FDC_MAX_QS_LINES // Maximum Line Count for QRAST Stencil Reads
#define LIST_REG_FLD_AR3D_FDC_MAX_QS_LINES(_) \
_(AR3D_FDC,MAX_QS_LINES,MAX_QS_LINES)
#define REG_AR3D_FDC_MAX_QS_LINES(_) _(AR3D_FDC,MAX_QS_LINES,0xa04,0x4,1,1,0x1ff,0x1ff,NOARY,FLD)
// max number of L2 cache lines allowed
// to be locked by qrast stencil
#define REG_FLD_AR3D_FDC_MAX_QS_LINES_MAX_QS_LINES(_) _(AR3D_FDC,MAX_QS_LINES,MAX_QS_LINES,9,8,0,3,0x1ff,0x1ff,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_MAX_QS_LINES_MAX_QS_LINES(_)

#define AR3D_FDC_MAX_PS_LINES_NO_SHADER_DEFAULT 48

// Register AR3D_FDC_MAX_PS_LINES // Maximum Line Count for PSEQ Reads
#define LIST_REG_FLD_AR3D_FDC_MAX_PS_LINES(_) \
_(AR3D_FDC,MAX_PS_LINES,MAX_PS_LINES)
#define REG_AR3D_FDC_MAX_PS_LINES(_) _(AR3D_FDC,MAX_PS_LINES,0xa05,0x5,1,1,0x1ff,0x30,NOARY,FLD)
// max number of L2 cache lines allowed
// to be locked by pseq
#define REG_FLD_AR3D_FDC_MAX_PS_LINES_MAX_PS_LINES(_) _(AR3D_FDC,MAX_PS_LINES,MAX_PS_LINES,9,8,0,3,0x1ff,0x30,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_MAX_PS_LINES_MAX_PS_LINES(_)

#define AR3D_FDC_MAX_Q_LINES_NO_SHADER_DEFAULT  48

// Register AR3D_FDC_MAX_Q_LINES // Maximum Line Count for Combined QRAST Reads
#define LIST_REG_FLD_AR3D_FDC_MAX_Q_LINES(_) \
_(AR3D_FDC,MAX_Q_LINES,MAX_Q_LINES)
#define REG_AR3D_FDC_MAX_Q_LINES(_) _(AR3D_FDC,MAX_Q_LINES,0xa06,0x6,1,1,0x1ff,0x20,NOARY,FLD)
// max number of L2 cache lines allowed
// to be locked by pseq
#define REG_FLD_AR3D_FDC_MAX_Q_LINES_MAX_Q_LINES(_) _(AR3D_FDC,MAX_Q_LINES,MAX_Q_LINES,9,8,0,3,0x1ff,0x20,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_MAX_Q_LINES_MAX_Q_LINES(_)

#define AR3D_FDC_MAX_Q_P_LINES_NO_SHADER_DEFAULT        48

// Register AR3D_FDC_MAX_Q_P_LINES // Maximum Line Count for combines QRAST & PSEQ Reads
#define LIST_REG_FLD_AR3D_FDC_MAX_Q_P_LINES(_) \
_(AR3D_FDC,MAX_Q_P_LINES,MAX_Q_P_LINES)
#define REG_AR3D_FDC_MAX_Q_P_LINES(_) _(AR3D_FDC,MAX_Q_P_LINES,0xa07,0x7,1,1,0x1ff,0x1ff,NOARY,FLD)
// max number of L2 cache lines allowed
// to be locked by pseq
#define REG_FLD_AR3D_FDC_MAX_Q_P_LINES_MAX_Q_P_LINES(_) _(AR3D_FDC,MAX_Q_P_LINES,MAX_Q_P_LINES,9,8,0,3,0x1ff,0x1ff,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_MAX_Q_P_LINES_MAX_Q_P_LINES(_)


// Register AR3D_FDC_FLUSH_CTL // FDC Flush Control
#define LIST_REG_FLD_AR3D_FDC_FLUSH_CTL(_) \
_(AR3D_FDC,FLUSH_CTL,DISABLE_AGGRESSIVE_FLUSH1) \
_(AR3D_FDC,FLUSH_CTL,DISABLE_AGGRESSIVE_FLUSH0) \
_(AR3D_FDC,FLUSH_CTL,MAX_FLUSH_STALLS) \
_(AR3D_FDC,FLUSH_CTL,AUTO_FLUSH_DELAY)
#define REG_AR3D_FDC_FLUSH_CTL(_) _(AR3D_FDC,FLUSH_CTL,0xa08,0x8,1,1,0x31fff,0x100,NOARY,FLD)
#define REG_FLD_AR3D_FDC_FLUSH_CTL_DISABLE_AGGRESSIVE_FLUSH1(_) _(AR3D_FDC,FLUSH_CTL,DISABLE_AGGRESSIVE_FLUSH1,1,17,17,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_FLUSH_CTL_DISABLE_AGGRESSIVE_FLUSH1(_)

#define REG_FLD_AR3D_FDC_FLUSH_CTL_DISABLE_AGGRESSIVE_FLUSH0(_) _(AR3D_FDC,FLUSH_CTL,DISABLE_AGGRESSIVE_FLUSH0,1,16,16,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_FLUSH_CTL_DISABLE_AGGRESSIVE_FLUSH0(_)

// Defines for how long the L2 arbiter can stall Flush
// access to L2 
// automatic flush proceeds to the next dirty line.
#define REG_FLD_AR3D_FDC_FLUSH_CTL_MAX_FLUSH_STALLS(_) _(AR3D_FDC,FLUSH_CTL,MAX_FLUSH_STALLS,5,12,8,3,0x1f,0x1,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_FLUSH_CTL_MAX_FLUSH_STALLS(_)

// Sets the number of clock cycles to wait before
// automatic flush proceeds to the next dirty line.
#define REG_FLD_AR3D_FDC_FLUSH_CTL_AUTO_FLUSH_DELAY(_) _(AR3D_FDC,FLUSH_CTL,AUTO_FLUSH_DELAY,8,7,0,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_FLUSH_CTL_AUTO_FLUSH_DELAY(_)

//      L1 input timeout
#define NV_FDC_L1_TIMEOUT_CNT_W 5

// Register AR3D_FDC_L1_TIMEOUT // FDC L1 Coalescing Timeout Control
#define LIST_REG_FLD_AR3D_FDC_L1_TIMEOUT(_) \
_(AR3D_FDC,L1_TIMEOUT,D_TIMEOUT) \
_(AR3D_FDC,L1_TIMEOUT,QW_TIMEOUT) \
_(AR3D_FDC,L1_TIMEOUT,P_TIMEOUT) \
_(AR3D_FDC,L1_TIMEOUT,QR_TIMEOUT)
#define REG_AR3D_FDC_L1_TIMEOUT(_) _(AR3D_FDC,L1_TIMEOUT,0xa09,0x9,1,1,0x1f1f1f1f,0xf0f0f0f,NOARY,FLD)
// Timeout (down)counter preset for dwr client
#define REG_FLD_AR3D_FDC_L1_TIMEOUT_D_TIMEOUT(_) _(AR3D_FDC,L1_TIMEOUT,D_TIMEOUT,5,28,24,3,0x1f,0xf,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_L1_TIMEOUT_D_TIMEOUT(_)

// Timeout (down)counter preset for qrast write clients
#define REG_FLD_AR3D_FDC_L1_TIMEOUT_QW_TIMEOUT(_) _(AR3D_FDC,L1_TIMEOUT,QW_TIMEOUT,5,20,16,3,0x1f,0xf,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_L1_TIMEOUT_QW_TIMEOUT(_)

// Timeout (down)counter preset for pseq client
#define REG_FLD_AR3D_FDC_L1_TIMEOUT_P_TIMEOUT(_) _(AR3D_FDC,L1_TIMEOUT,P_TIMEOUT,5,12,8,3,0x1f,0xf,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_L1_TIMEOUT_P_TIMEOUT(_)

// Timeout (down)counter preset for qrast read clients
#define REG_FLD_AR3D_FDC_L1_TIMEOUT_QR_TIMEOUT(_) _(AR3D_FDC,L1_TIMEOUT,QR_TIMEOUT,5,4,0,3,0x1f,0xf,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_L1_TIMEOUT_QR_TIMEOUT(_)


// Register AR3D_FDC_INSTRUMENT // statistics enable method - gates stat collection for FDC
#define LIST_REG_FLD_AR3D_FDC_INSTRUMENT(_) \
_(AR3D_FDC,INSTRUMENT,STAT_EN)
#define REG_AR3D_FDC_INSTRUMENT(_) _(AR3D_FDC,INSTRUMENT,0xa0a,0xa,1,1,0x1,0x0,NOARY,FLD)
// Enables Performance Monitoring
#define REG_FLD_AR3D_FDC_INSTRUMENT_STAT_EN(_) _(AR3D_FDC,INSTRUMENT,STAT_EN,1,0,0,3,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_FDC_INSTRUMENT_STAT_EN(_)

// Second-level clock enable override register
//
// This can override the 2nd level clock enables in case of malfunction.
// Only exposed to software when needed.
//

// Register AR3D_FDC_CLKEN_OVERRIDE 
#define LIST_REG_FLD_AR3D_FDC_CLKEN_OVERRIDE(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDC_CLKEN_OVR) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCPR_CLKEN_OVR) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCZR_CLKEN_OVR) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCSR_CLKEN_OVR) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCVR_CLKEN_OVR) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCDW_CLKEN_OVR) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCZW_CLKEN_OVR) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCSW_CLKEN_OVR) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCVW_CLKEN_OVR) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCSB_CLKEN_OVR)
#define REG_AR3D_FDC_CLKEN_OVERRIDE(_) _(AR3D_FDC,CLKEN_OVERRIDE,0xa0b,0xb,1,1,0x3ff,0x0,NOARY,FLD)
// Fine Grain override for the gr3dfdcclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDC_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDC_CLKEN_OVR,1,0,0,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDC_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDC_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDC_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDC_CLKEN_OVR_CLK_GATED                 _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDC_CLKEN_OVR_CLK_ALWAYS_ON                     _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dfdcprclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDCPR_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDCPR_CLKEN_OVR,1,1,1,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDCPR_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCPR_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCPR_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCPR_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCPR_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dfdczrclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDCZR_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDCZR_CLKEN_OVR,1,2,2,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDCZR_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCZR_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCZR_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCZR_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCZR_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dfdcsrclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDCSR_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDCSR_CLKEN_OVR,1,3,3,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDCSR_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCSR_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCSR_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCSR_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCSR_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dfdcvrclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDCVR_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDCVR_CLKEN_OVR,1,4,4,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDCVR_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCVR_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCVR_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCVR_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCVR_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dfdcdwclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDCDW_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDCDW_CLKEN_OVR,1,5,5,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDCDW_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCDW_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCDW_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCDW_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCDW_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dfdczwclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDCZW_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDCZW_CLKEN_OVR,1,6,6,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDCZW_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCZW_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCZW_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCZW_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCZW_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dfdcswclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDCSW_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDCSW_CLKEN_OVR,1,7,7,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDCSW_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCSW_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCSW_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCSW_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCSW_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dfdcvwclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDCVW_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDCVW_CLKEN_OVR,1,8,8,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDCVW_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCVW_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCVW_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCVW_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCVW_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

// Fine Grain override for the gr3dfdcsbclk
#define REG_FLD_AR3D_FDC_CLKEN_OVERRIDE_FDCSB_CLKEN_OVR(_) _(AR3D_FDC,CLKEN_OVERRIDE,FDCSB_CLKEN_OVR,1,9,9,3,0x1,0x0,CLK_GATED,ENM)
#define LIST_REG_ENM_AR3D_FDC_CLKEN_OVERRIDE_FDCSB_CLKEN_OVR(_) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCSB_CLKEN_OVR,CLK_GATED,0) \
_(AR3D_FDC,CLKEN_OVERRIDE,FDCSB_CLKEN_OVR,CLK_ALWAYS_ON,1)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCSB_CLKEN_OVR_CLK_GATED                       _MK_ENUM_CONST(0)
#define AR3D_FDC_CLKEN_OVERRIDE_FDCSB_CLKEN_OVR_CLK_ALWAYS_ON                   _MK_ENUM_CONST(1)

//
// Memory Client Interface Async Fifo Optimization Register
// This can only be changed while the pipeline is completely idle.
// Read-only instance.
//
// Memory Client Interface Fifo Control Register.
// The registers below allow to optimize the synchronization timing in
// the memory client asynchronous fifos. When they can be used depend on
// the client and memory controller clock ratio.
// Additionally, the RDMC_RDFAST/RDCL_RDFAST fields can increase power
// consumption if the asynchronous fifo is implemented as a real ram.
// There is no power impact on latch-based fifos. Flipflop-based fifos
// do not use these fields.
// See recommended settings below.
//
// !! IMPORTANT !!
// The register fields can only be changed when the memory client async
// fifos are empty.
//
// The register field ending with WRCL_MCLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one client clock cycle if
// the memory controller clock frequency is less or equal to twice the client
// clock frequency:
//
//      mcclk_freq <= 2 * clientclk_freq
//
// The register field ending with WRMC_CLLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one memory controller clock
// cycle if the client clock frequency is less or equal to twice the memory
// controller clock frequency:
//
//      clientclk_freq <= 2 * mcclk_freq
//
// The register field ending with RDMC_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one memory controller clock cycle.
//
// !! WARNING !!
// RDMC_RDFAST can be used along with WRCL_MCLE2X only when:
//
//       mcclk_freq <= clientclk_freq
//
// The register field ending with RDCL_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one client clock cycle.
//
// !! WARNING !!
// RDCL_RDFAST can be used along with WRMC_CLLE2X only when:
//
//       clientclk_freq <= mcclk_freq
//
// RECOMMENDED SETTINGS
// # Client writing to fifo, memory controller reading from fifo
// - mcclk_freq <= clientclk_freq
//     You can enable both RDMC_RDFAST and WRCL_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.
// - clientclk_freq < mcclk_freq <= 2 * clientclk_freq
//     You can enable RDMC_RDFAST or WRCL_MCLE2X, but because the client clock
//     is slower, you should enable only WRCL_MCLE2X.
// - 2 * clientclk_freq < mcclk_freq
//     You can only enable RDMC_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDMC_RDFAST.
//
// # Memory controller writing to fifo, client reading from fifo
// - clientclk_freq <= mcclk_freq
//     You can enable both RDCL_RDFAST and WRMC_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.
// - mcclk_freq < clientclk_freq <= 2 * mcclk_freq
//     You can enable RDCL_RDFAST or WRMC_CLLE2X, but because the memory controller
//     clock is slower, you should enable only WRMC_CLLE2X.
// - 2 * mcclk_freq < clientclk_freq
//     You can only enable RDCL_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDCL_RDFAST.
//

// Register AR3D_FDC_NV_MCCIF_FIFOCTRL_RO 
#define LIST_REG_FLD_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO(_) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST)
#define REG_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO(_) _(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,0xa0c,0xc,1,1,0xf,0x0,NOARY,FLD)
#define REG_FLD_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X(_) _(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X,1,0,0,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X(_) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X,DISABLE,0) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRCL_MCLE2X,ENABLE,1)
#define AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRCL_MCLE2X_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST(_) _(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST,1,1,1,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST(_) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST,DISABLE,0) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDMC_RDFAST,ENABLE,1)
#define AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDMC_RDFAST_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X(_) _(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X,1,2,2,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X(_) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X,DISABLE,0) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_WRMC_CLLE2X,ENABLE,1)
#define AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_WRMC_CLLE2X_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST(_) _(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST,1,3,3,1,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST(_) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST,DISABLE,0) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,NV_MCCIF_RDCL_RDFAST,ENABLE,1)
#define AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_FDC_NV_MCCIF_FIFOCTRL_RO_NV_MCCIF_RDCL_RDFAST_ENABLE                       _MK_ENUM_CONST(1)

// last two blocks (2 * 2^AR3D_ADDRBITS_PER_UNIT) are reserved for global registers
// Global Definitions here
// SURFADDR -- base address for framebuffer surfaces
// Note:
//   There are logically N surfaces, and the instruction set allows the
//   drawing surface, the z surface, the stencil surface, the coverage surface,
//   the register spill surface to be chosen amongst any of them.  However,
//   different surfaaces should remain seperate because there is no guarantee
//   of coherence between them by the hardware.
//   FDC was designed to use 32B
//   cache lines stored in alternate banks.  If
//   a surface wraps a cacheline off the end of
//   one line and into the beginning of the next
//   line, there can be a loss of performance
//   because one cacheline resides in two lines.
//   See bug 201949 for details.  Bottom line is
//   while functional down to 16B alignment,
//   better performance is obtained with 32B
//   alignment.

// Register AR3D_GLOBAL_SURFADDR 
#define LIST_REG_FLD_AR3D_GLOBAL_SURFADDR(_) \
_(AR3D_GLOBAL,SURFADDR,BASE_ADDRESS)
#define REG_AR3D_GLOBAL_SURFADDR(_) _(AR3D_GLOBAL,SURFADDR,0xe00,0x0,16,1,0xffffffff,0x0,ARY,FLD)
// This surface base address must be NV_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES aligned
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in
// project_mg20.spec
//
// While NV_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES alignment will work, NV_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment
// may provide better performance in some cases
#define REG_FLD_AR3D_GLOBAL_SURFADDR_BASE_ADDRESS(_) _(AR3D_GLOBAL,SURFADDR,BASE_ADDRESS,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_SURFADDR_BASE_ADDRESS(_)

// This table describes surface properties.
// In the nomenclature Cc below, 'C' represents the color component,
//  and 'c' is the number of bits for that component.
//
// There is support for both D3D style packing (B at the ls end, then G,
// then R, then A), as well as OGL style packing (A at the ls end, then B,
// then G, then R), for in-memory format.  However, no matter what the memory
// packing arrangement is, the internal pipeline is arranged so that R
// is always at the LS end, then G, then B, then A.
//
// All color formats are described in little endian format below, as 4-tuples
// in (red, green, blue, alpha) order.
//
//      A8           --  8bpp; produces (0x00,0x00,0x00,A8)
//      A16_float    -- 16bpp; produces (0.0,A20)
//      L8           --  8bpp; produces (L8,L8,L8,0xFF)
//      L16_float    -- 16bpp; produces (L20,1.0)
//      L8A8         -- 16bpp; produces (L8,L8,L8,A8)
//      L16A16_float -- 32bpp; produces (L20,A20)
//      B2G3R3       --  8bpp; produces (R3,G3,B2,0xFF)
//      B5G6R5       -- 16bpp; produces (R5,G6,B5,0xFF)
//      R11G11B10_float
//                   -- 32bpp; produces (R20,G20,B20)
//      B5G5R5A1     -- 16bpp; produces (R5,G5,B5,A1)
//      A1B5G5R5     -- 16bpp; produces (R5,G5,B5,A1)
//      B4G4R4A4     -- 16bpp; produces (R4,G4,B4,A4)
//      A4B4G4R4     -- 16bpp; produces (R4,G4,B4,A4)
//      B8G8R8A8     -- 32bpp; produces (R8,G8,B8,A8)
//      R8G8B8A8     -- 32bpp; produces (R8,G8,B8,A8)
//      R16G16B16A16_float
//                   -- 64bpp; produces (R20,G20,B20,A20)
//      R10G10B10_float_A2
//                   -- 32bpp; produces (R20,G20,B20,A20) (sc25 P1)
//      B8G8R8G8     -- 32bpp; compressed YUV 4:2:2 texture (EXT_texture_compression_422)
//                      produces (R8,G8,B8,0xFF) (sc25 only)
//      G8B8G8R8     -- 32bpp; compressed YUV 4:2:2 texture (EXT_texture_compression_422)
//                      produces (R8,G8,B8,0xFF) (sc25 only)
//      DXT1         -- compressed texture with transparency
//      DXT1C        -- compressed texture with black
//      DXT3         -- compressed texture with explicit transparency
//      DXT5         -- compressed texture with encoded transparency
//      ETC          -- compressed ETC1 texture (from GLES2.0 spec)
//      ETC3         -- compressed ETC1 texture with DXT3 explicit transparency
//      ETC5         -- compressed ETC1 texture with DXT5 encoded transparency
//      LATC1        -- compressed unsigned luminance texture
//      LATC2        -- compressed unsigned luminance texture with encoded transparency
//      Z16          -- 16bpp; 16b Z
//      Z16NL        -- 16bpp; 16b Z
//
// Most entries are fixed point values.  where all ones indicates 1.0 and
// all zeros indicates 0.0.
//
// The 16_float format is
//             <15>    sign (S)
//             <14:10> exponent (E)
//             < 9: 0> mantissa (M)
//    (-1)^S * 0.0                        if E == 0 and M == 0,
//    (-1)^S * 2^-14 * (M / 2^10)         if E == 0 and M !- 0, (denorm)
//    (-1)^S * 2^(E-15) * (1 + M / 2^10), if 0 < E < 31,
//    (-1)^S * 2^(E-15) * (1 + M / 2^10), if E == 31 and M == 0,
//    (-1)^S * 2^(E-15) * (1 + M / 2^10), if E == 31 and M != 0
//
// The 11_float format is
//             <10: 6> exponent (E)
//             < 5: 0> mantissa (M)
//    0.0,                      if E == 0 and M == 0,
//    2^-14 * (M / 2^6),        if E == 0 and M != 0, (denorm)
//    2^(E-15) * (1 + M / 2^6), if 0 < E < 31,
//    2^(E-15) * (1 + M / 2^6), if E == 31 and M == 0,
//    2^(E-15) * (1 + M / 2^6), if E == 31 and M != 0
//
// The 10_float formats are
//
// R11G11B10_float:
//             < 9: 5> exponent (E)
//             < 4: 0> mantissa (M)
//    0.0,                      if E == 0 and M == 0,
//    2^-14 * (M / 2^5),        if E == 0 and M != 0, (denorm)
//    2^(E-15) * (1 + M / 2^5), if 0 < E < 31,
//    2^(E-15) * (1 + M / 2^5), if E == 31 and M == 0,
//    2^(E-15) * (1 + M / 2^5), if E == 31 and M != 0
//
// R10G10B10_float_A2
//             <31:30> alpha
//             <29:26> blue exponent (E)
//             <25:20> blue mantissa (M)
//             <19:16> green exponent (E)
//             <15:10> green mantissa (M)
//             < 9: 6> red exponent (E)
//             < 5: 0> red mantissa (M)
//    0.0,                      if E == 0 and M == 0,
//    2^-6 * (M / 2^6),         if E == 0 and M != 0, (denorm)
//    2^(E-7) * (1 + M / 2^6),  if 0 < E < 15,
//    2^(E-7) * (1 + M / 2^6),  if E == 15 and M == 0,
//    2^(E-7) * (1 + M / 2^6),  if E == 15 and M != 0
//
//
// Bit field assignments for the surface formats in memory is:
//
// B2G3R3      <1:0>    blue
//             <4:2>    green
//             <7:5>    red
//
// B5G6R5      <4:0>    blue
//             <10:5>   green
//             <15:11>  red
//
// A4B4G4R4    <3:0>    alpha
//             <7:4>    blue
//             <11:8>   green
//             <15:12>  red
//
// B4G4R4A4    <3:0>    blue
//             <7:4>    green
//             <11:8>   red
//             <15:12>  alpha
//
// A1B5G5R5    <0>      alpha
//             <5:1>    blue
//             <10:6>   green
//             <15:11>  red
//
// B5G5R5A1    <4:0>    blue
//             <9:5>    green
//             <14:10>  red
//             <15>     alpha
//
// A8          <7:0>    alpha
//
// A16_float   <15:0>   alpha (fp16)
//
// L8          <7:0>    luminance
//
// L16_float   <15:0>   luminance (fp16)
//
// L8A8        <7:0>    luminance
//             <15:8>   alpha
//
// L16A16_float<15:0>   luminance (fp16)
//             <31:16>  alpha (fp16)
//
// R16G16B16A16_float
//             <15:0>   red (fp16)
//             <31:16>  green (fp16)
//             <47:32>  blue (fp16)
//             <63:48>  alpha (fp16)
//
// R11G11B10_float
//             <10:0>   red (fp11 - 6e5)
//             <21:11>  green (fp11 - 6e5)
//             <31:22>  blue (fp10 - 5e5)
//
// R10G10B10_float_A2
//             <9:0>    red (fp10 - 6e4)
//             <19:10>  green (fp10 - 6e4)
//             <29:20>  blue (fp10 - 6e4)
//             <31:30>  alpha
//
// B8G8R8A8    <7:0>    blue
//             <15:8>   green
//             <23:16>  red
//             <31:24>  alpha
//
// R8G8B8A8    <7:0>    red
//             <15:8>   green
//             <23:16>  blue
//             <31:24>  alpha
//
// Z16         <15:0>   16 bit linear depth
//
// Z16NL       <12:0>   the remaining msb bits after removing the first 7 leading
//                      ones from the 20 bit linear depth
//             <15:13>  leading ones count from the 20 bit linear depth
//
// B8G8R8G8    <7:0>    blue0
//             <15:8>   green0
//             <23:16>  red
//             <31:24>  green1
//
//             If (x%2 == 0) then
//                 color = (red, green0, blue); alpha = 0xFF
//             else
//                 color = (red, green1, blue); alpha = 0xFF
//
// G8B8G8R8    <7:0>    green0
//             <15:8>   blue
//             <23:16>  green1
//             <31:24>  red
//
//             If (x%2 == 0) then
//                 color = (red, green0, blue); alpha = 0xFF
//             else
//                 color = (red, green1, blue); alpha = 0xFF
//
// DXT1        < 4: 0>    color0.blue
//             <10: 5>    color0.green
//             <15:11>    color0.red
//             <20:16>    color1.blue
//             <26:21>    color1.green
//             <31:27>    color1.red
//             <33:32>    index (0,0)
//             <35:34>    index (0,1)
//             <37:36>    index (0,2)
//             <39:38>    index (0,3)
//             <41:40>    index (1,0)
//             <43:42>    index (1,1)
//             <45:44>    index (1,2)
//             <47:46>    index (1,3)
//             <49:48>    index (2,0)
//             <51:50>    index (2,1)
//             <53:52>    index (2,2)
//             <55:54>    index (2,3)
//             <57:56>    index (3,0)
//             <59:58>    index (3,1)
//             <61:60>    index (3,2)
//             <63:62>    index (3,3)
//
//             idx = index(y%4, x%4)
//             (r0,g0,b0) = expand555to888(color0)
//             (r1,g1,b1) = expand555to888(color1)
//             If (color0 <= color1) then
//                 // the block has alpha
//                 switch (idx)
//                   case 0: alpha = FF; color = (r0,g0,b0)
//                   case 1: alpha = FF; color = (r1,g1,b1)
//                   case 2: alpha = FF; color = (rgb0+rgb1)/2
//                   case 3: alpha = 00; color = (00,00,00)
//                 endswitch
//             else
//                 // the block has no alpha
//                 switch (idx)
//                   case 0: alpha = FF; color = (r0,g0,b0)
//                   case 1: alpha = FF; color = (r1,g1,b1)
//                   case 2: alpha = FF; color = (2*rgb0+rgb1+1)/3
//                   case 3: alpha = FF; color = (rgb0+2*rgb1+1)/3
//                 endswitch
//
// DXT1C       Identical to DXT1, except that in the one case that
//             produces transparency, opaque black is produced instead
//             (color0 <= color1 && idx=3).
//
// DXT3
//           <  3:  0>    alpha (0,0)
//           <  7:  4>    alpha (0,1)
//           < 11:  8>    alpha (0,2)
//           < 15: 12>    alpha (0,3)
//           < 19: 16>    alpha (1,0)
//           < 23: 20>    alpha (1,1)
//           < 27: 24>    alpha (1,2)
//           < 31: 28>    alpha (1,3)
//           < 35: 32>    alpha (2,0)
//           < 39: 36>    alpha (2,1)
//           < 43: 40>    alpha (2,2)
//           < 47: 44>    alpha (2,3)
//           < 51: 48>    alpha (3,0)
//           < 55: 52>    alpha (3,1)
//           < 59: 56>    alpha (3,2)
//           < 63: 60>    alpha (3,3)
//           < 67: 64>    color0.blue
//           < 74: 68>    color0.green
//           < 79: 75>    color0.red
//           < 84: 80>    color1.blue
//           < 90: 85>    color1.green
//           < 95: 91>    color1.red
//           < 97: 96>    index (0,0)
//           < 99: 98>    index (0,1)
//           <101:100>    index (0,2)
//           <103:102>    index (0,3)
//           <105:104>    index (1,0)
//           <107:106>    index (1,1)
//           <109:108>    index (1,2)
//           <111:110>    index (1,3)
//           <113:112>    index (2,0)
//           <115:114>    index (2,1)
//           <117:116>    index (2,2)
//           <119:118>    index (2,3)
//           <121:120>    index (3,0)
//           <123:122>    index (3,1)
//           <125:124>    index (3,2)
//           <127:126>    index (3,3)
//
//           Color is computed the same as DXT1 except the color
//           compare "if (color0 <= color1)" is changed to "if (FALSE)".
//           In other words, the color is always in 4 color mode.
//
//           alpha = expand4to8(alpha(y%4, x%4))
//
//
// DXT5      <  7:  0>    alpha_0
//           < 15:  8>    alpha_1
//           < 18: 16>    index_a (0,0)
//           < 21: 19>    index_a (0,1)
//           < 24: 22>    index_a (0,2)
//           < 27: 25>    index_a (0,3)
//           < 30: 28>    index_a (1,0)
//           < 33: 31>    index_a (1,1)
//           < 36: 34>    index_a (1,2)
//           < 39: 37>    index_a (1,3)
//           < 42: 40>    index_a (2,0)
//           < 45: 43>    index_a (2,1)
//           < 48: 46>    index_a (2,2)
//           < 51: 49>    index_a (2,3)
//           < 54: 52>    index_a (3,0)
//           < 57: 55>    index_a (3,1)
//           < 60: 58>    index_a (3,2)
//           < 63: 61>    index_a (3,3)
//           < 67: 64>    color0.blue
//           < 74: 68>    color0.green
//           < 79: 75>    color0.red
//           < 84: 80>    color1.blue
//           < 90: 85>    color1.green
//           < 95: 91>    color1.red
//           < 97: 96>    index (0,0)
//           < 99: 98>    index (0,1)
//           <101:100>    index (0,2)
//           <103:102>    index (0,3)
//           <105:104>    index (1,0)
//           <107:106>    index (1,1)
//           <109:108>    index (1,2)
//           <111:110>    index (1,3)
//           <113:112>    index (2,0)
//           <115:114>    index (2,1)
//           <117:116>    index (2,2)
//           <119:118>    index (2,3)
//           <121:120>    index (3,0)
//           <123:122>    index (3,1)
//           <125:124>    index (3,2)
//           <127:126>    index (3,3)
//
//           Color is computed exactly as DXT3 is.
//
//           idx = index_a(y%4, x%4)
//
//           //8-alpha or 6-alpha block?
//           if (alpha_0 > alpha_1) then
//               //8-alpha block.
//               switch(idx)
//                 case 0: alpha = alpha_0;
//                 case 1: alpha = alpha_1
//                 case 2: alpha = (6 * alpha_0 + 1 * alpha_1 + 3) / 7;
//                 case 3: alpha = (5 * alpha_0 + 2 * alpha_1 + 3) / 7;
//                 case 4: alpha = (4 * alpha_0 + 3 * alpha_1 + 3) / 7;
//                 case 5: alpha = (3 * alpha_0 + 4 * alpha_1 + 3) / 7;
//                 case 6: alpha = (2 * alpha_0 + 5 * alpha_1 + 3) / 7;
//                 case 7: alpha = (1 * alpha_0 + 6 * alpha_1 + 3) / 7;
//               endswitch
//           else
//               //6-alpha block.
//               switch(idx)
//                 case 0: alpha = alpha_0;
//                 case 1: alpha = alpha_1
//                 case 2: alpha = (4 * alpha_0 + 1 * alpha_1 + 2) / 5;
//                 case 3: alpha = (3 * alpha_0 + 2 * alpha_1 + 2) / 5;
//                 case 4: alpha = (2 * alpha_0 + 3 * alpha_1 + 2) / 5;
//                 case 5: alpha = (1 * alpha_0 + 4 * alpha_1 + 2) / 5;
//                 case 6: alpha = 0;
//                 case 7: alpha = 255;
//               endswitch
//
//           The Ericsson Texture Compression (ETC) format is defined in OpenGL ES.
// ETC       < 63: 0>     ETC color block
//
// ETC3      < 63: 0>     DXT3 alpha block with ETC pixel layout
//           <127:64>     ETC color block
//
// ETC5      < 63: 0>     DXT5 alpha block with ETC pixel layout
//           <127:64>     ETC color block
//
//           Only unsigned LATC is supported, the signed mode can be implemented in the shader.
// LATC1     < 63: 0>     DXT5 alpha block
//                        Produces (A,A,A,0xFF).
//
// LATC2     < 63: 0>     DXT5 alpha block 0
//           <127:64>     DXT5 alpha block 1
//                        Produces (A0,A0,A0,A1)
//
// Texture storage -- This should go in the ar3d_tex.spec file -- mmahan
//
// Besides normal mipmaps, ar3d supports non-mipmapped textures of rectangluar
// shapes whose dimensions are power of two as a degenerate case of a mipmap,
// by setting both LOD_MIN and LOD_MAX to 0 (effectively disabling mipmapping).
// Ar3d does _not_ support non-mipmapped rectangular textures whose dimensions
// are not powers of 2 (simply referred to as 'rectangular textures' in GL
// lingo), i.e. it does not support the Nvidia defined OpenGL extension
// GL_NV_texture_rectangle.  Another way of saying it is whether mipmapped or
// not, all textures in AR01 must have dimensions that are powers of two.
// MG20, however, supports non-mipmapped non-power-of-2 textures, cubemaps,
// and texture arrays.
//
// The levels of a mipmap are stored in consecutive (abutting) blocks of
// memory, but each level may contain some padding based on the row length
// restrictions as detailed below. The levels of a mipmap are stored such
// that the starting address of level N+1 is higher than the starting address
// of level N. So mipmap level 0 is stored at the lowest address, followed by
// level 1 above it, and so on.
//
// A row must be a multiple of a NV_GR3D_TEX_MIN_STRIDE_BYTES in length.
// For SC15, this value is 16 bytes.  So for a texture of width W texels and
// height H texels we program the HW with a height of H and a pitch of
//     (width * (bpp/8) + 16-1) / 16.
//
// There is also the requirement that a given mipmap level must be at least
// NV_GR3D_TEX_MIN_SIZE_BYTES in size.  This only matters for the smallest
// maps.  For SC15, this is value is 16 bytes.
//
// Another requirement is that a given texture level must begin at an
// aligned memory address, given by NV_GR3D_TEX_ALIGNMENT_BYTES.  For SC15,
// this quantity is 16 bytes.
//
// Textures can be stored linearly (QUADLIN = 0) or swizzled (QUADLIN = 1).
// The storage convention is orthogonal to the texture format. The basic
// organizational unit of texture memory is a texture cache line, which on
// sc15 is 16 bytes.  Symbolically it is defined as NV_DF_TEXLINE_BYTES_LOG2
// and NV_DF_TEXLINE_BYTES.
//
// A texture cache line is comprised of bytes stored in little endian fashion.
//
// In linear mode, texels are stored as follows:
//
// 64bpp: D< 63:  0> = texel (x,  y)
//        D<127: 64> = texel (x+1,y)
//
// 32bpp: D< 31:  0> = texel (x,  y)
//        D< 63: 32> = texel (x+1,y)
//        D< 95: 64> = texel (x+2,y)
//        D<127: 96> = texel (x+3,y)
//
// 16bpp: D< 15:  0> = texel (x,  y)
//        D< 31: 16> = texel (x+1,y)
//        D< 47: 32> = texel (x+2,y)
//        D< 63: 48> = texel (x+3,y)
//        D< 79: 64> = texel (x+4,y)
//        D< 95: 80> = texel (x+5,y)
//        D<111: 96> = texel (x+6,y)
//        D<127:112> = texel (x+7,y)
//
//  8bpp: D<  7:  0> = texel (x,  y)
//        D< 15:  8> = texel (x+1,y)
//        D< 23: 16> = texel (x+2,y)
//        D< 31: 24> = texel (x+3,y)
//        D< 39: 32> = texel (x+4,y)
//        D< 47: 40> = texel (x+5,y)
//        D< 55: 48> = texel (x+6,y)
//        D< 63: 56> = texel (x+7,y)
//        D< 71: 64> = texel (x+8,y)
//        D< 79: 72> = texel (x+9,y)
//        D< 87: 80> = texel (x+10,y)
//        D< 95: 88> = texel (x+11,y)
//        D<103: 96> = texel (x+12,y)
//        D<111:104> = texel (x+13,y)
//        D<119:112> = texel (x+14,y)
//        D<127:120> = texel (x+15,y)
//
//  4bpp: D<  3:  0> = texel (x,   y)
//        D<  7:  4> = texel (x+1, y)
//        D< 11:  8> = texel (x+2, y)
//        ...
//        D<115:112> = texel (x+20,y)
//        D<119:116> = texel (x+29,y)
//        D<123:120> = texel (x+30,y)
//        D<127:124> = texel (x+31,y)
//
//  DXT1, DXT1C, DXT3, DXT5: Not allowed
//
// Swizzled mode mixes the texels from 2 or 4 adjacent rows for higher
// performance memory access, thus organizing the surface into tiles,
// which are 2x2 texels for 32bpp formats, 4x2 texels for 16bpp formats,
// 4x4 texels for 8bpp formats, and 8x4 texels for 4 bpp formats.  64bit
// DXT formats store 4x4-texel compressed texture blocks in 2x1 tiles.
// 128bit DXT formats store a single 4x4-texel compressed texture block
// in a tile.
//
//  Texels are stored as follows in swizzled mode:
//
// 64bpp: D< 63:  0> = texel (x  ,y)       y must be even
//        D<127: 64> = texel (x  ,y+1)       
// 
// 32bpp: D< 31:  0> = texel (x  ,y)       x and y are both even
//        D< 63: 32> = texel (x+1,y)
//        D< 95: 64> = texel (x  ,y+1)
//        D<127: 96> = texel (x+1,y+1)
//
// 16bpp: D< 15:  0> = texel (x  ,y)       x must be divisible by 4
//        D< 31: 16> = texel (x+1,y)       y must be even
//        D< 47: 32> = texel (x+2,y)
//        D< 63: 48> = texel (x+3,y)
//        D< 79: 64> = texel (x  ,y+1)
//        D< 95: 80> = texel (x+1,y+1)
//        D<111: 96> = texel (x+2,y+1)
//        D<127:112> = texel (x+3,y+1)
//
//  8bpp: D<  7:  0> = texel (x  ,y)       x must be divisible by 4
//        D< 15:  8> = texel (x+1,y)       y must be divisible by 4
//        D< 23: 16> = texel (x+2,y)
//        D< 31: 24> = texel (x+3,y)
//        D< 39: 32> = texel (x  ,y+1)
//        D< 47: 40> = texel (x+1,y+1)
//        D< 55: 48> = texel (x+2,y+1)
//        D< 63: 56> = texel (x+3,y+1)
//        D< 71: 64> = texel (x  ,y+2)
//        D< 79: 72> = texel (x+1,y+2)
//        D< 87: 80> = texel (x+2,y+2)
//        D< 95: 88> = texel (x+3,y+2)
//        D<103: 96> = texel (x  ,y+3)
//        D<111:104> = texel (x+1,y+3)
//        D<119:112> = texel (x+2,y+3)
//        D<127:120> = texel (x+3,y+3)
//
//  4bpp: D<  3:  0> = texel (x  ,y)       x must be divisible by 8
//        D<  7:  4> = texel (x+1,y)       y must be divisible by 4
//        D< 11:  8> = texel (x+2,y)
//        D< 15: 12> = texel (x+3,y)
//        D< 19: 16> = texel (x+4,y)
//        D< 23: 20> = texel (x+5,y)
//        D< 27: 24> = texel (x+6,y)
//        D< 31: 28> = texel (x+7,y)
//        D< 35: 32> = texel (x,  y+1)
//        D< 39: 36> = texel (x+1,y+1)
//        D< 43: 40> = texel (x+2,y+1)
//        D< 47: 44> = texel (x+3,y+1)
//        D< 51: 48> = texel (x+4,y+1)
//        D< 55: 52> = texel (x+5,y+1)
//        D< 59: 56> = texel (x+6,y+1)
//        D< 63: 60> = texel (x+7,y+1)
//        D< 67: 64> = texel (x  ,y+2)
//        D< 71: 68> = texel (x+1,y+2)
//        D< 75: 72> = texel (x+2,y+2)
//        D< 79: 76> = texel (x+3,y+2)
//        D< 83: 80> = texel (x+4,y+2)
//        D< 87: 84> = texel (x+5,y+2)
//        D< 91: 88> = texel (x+6,y+2)
//        D< 95: 92> = texel (x+7,y+2)
//        D< 99: 96> = texel (x  ,y+3)
//        D<103:100> = texel (x+1,y+3)
//        D<107:104> = texel (x+2,y+3)
//        D<111:108> = texel (x+3,y+3)
//        D<115:112> = texel (x+4,y+3)
//        D<119:116> = texel (x+5,y+3)
//        D<123:120> = texel (x+6,y+3)
//        D<127:124> = texel (x+7,y+3)
//
//  DXT1, DXT1C, ETC, LATC1:
//        D< 63:  0> = compressed_texel (x, y)   x must be divisible by 8
//        D<127: 64> = compressed_texel (x+4, y) y must be divisible by 4
//
//  DXT3, DXT5, ETC3, ETC5, LATC2:
//        D<127:  0> = compressed_texel (x, y)   x must be divisible by 4
//                                               y must be divisible by 4
//
//
// Note that in a swizzled format, the pad bytes to make the row a multiple
// of a cache line are not contiguous. In general, the pad bytes will occupy
// the bytes of a line whose associated texel coordinates are outside the
// texture the defined texture rectangle. For example, with a 2x8 texture
// using a 8bpp format, bytes 2,3,6,7,10,11,14,15 of each of the two lines
// constituting the texture are filled with pad bytes.  Any value will do
// since they aren't referenced by the hardware, but filling them with 0x00
// is recommended.  A visual display of this is shown below.
//
//     2x8 texture      memory
//      +-----+        +---------------------------------+
//      | a b |        | a b . . c d . . e f . . g h . . |
//      | c d |        +---------------------------------+
//      | e f |        | i j . . k l . . m n . . o p . . |
//      | g h |        +---------------------------------+
//      | i j |
//      | k l |
//      | m n |
//      | o p |
//      +-----+
//
// In general, GL has a requirement that one can update arbitrary rectangular
// subregions of a texture via the glTexSubImage2D (transfer from system
// memory to video memory) and glCopyTexSubImage2D (transfer from video
// memory to video memory) functions. Note that this leads to non-contiguous
// writes (and in the case of glCopyTexSubImage2D, non-contigiuous reads),
// and in the case of 4bpp texels requires RMW accesses at the byte level.
//
// Example (assumes 16b subcomponents are ls to ms (a is 15:0, b is
// 31:16, etc):
//
// mipmap level 8x4, 8bpp   storage tiled, pitch=16, height=4
//
// a b c d e f g h           +---------+---------+---------+---------+
// i j k l m n o p           | a b i j | c d k l | e f m n | g h o p |
// q r s t u v w x           +---------+---------+---------+---------+
// y z ? @ $ % & =           | q r y z | s t ? @ | t u $ % | w x & = |
//                           +---------+---------+---------+---------+
//
// download new subimage (1,1)-(3,3) inclusive:
//
// a b c d e f g h           +---------+---------+---------+---------+
// i * * * m n o p           | a b i * | c d * * | e f m n | g h o p |
// q * . . u v w x           +---------+---------+---------+---------+
// y * . . $ % & =           | q * y * | . . . . | t u $ % | w x & = |
//                           +---------+---------+---------+---------+
//
// The SC15 blit engine does not support scatter/gather operations to
// support reading from or writing to a rectangular region that is part
// of a surface that uses swizzled storage. When transferring texture data
// from system memory to video memory, SW must perform a gather operation
// to fill in T$ lines in proper order during the host blit. The blitter
// can only be used to copy an inscribed rectangle of the desired region
// which is aligned at tile boundaries. In the above example this means
// the rectangle (2,2)-(3,3).
//
// For vidmem-to-vidmem transfers, SW must provide gather/scatter operation
// for all texels of the region outside of the blittable rectangle inside
// the copied region.
//
//
// In MG20, both linear and swizzled textures can be tiled by setting the
// LAYOUT field in TEXDESC register to either TILED_LINEAR or TILED_SWIZZLED.
// Tiling attempts to distribute ddr bank accesses evenly to minimize page
// breaks, by xor'ing the msb of the bank number 
// (addr[NV_MC_POORMANS_TILING_ADDR_BIT]) with the lsb of the row number 
// (addr[NV_MC_POORMANS_TILING_ADDR_XOR]) to form a new address.
//      offset  = f(u,v)
//      address = base + offset
//      if (tiling)
//          address[NV_MC_POORMANS_TILING_ADDR_BIT] ^= address[NV_MC_POORMANS_TILING_ADDR_XOR]
//
// In AP15, a new tile mode (xytiled) was added.  This tile mode is documented
// in //hw/ar/doc/<project>/mc/tiling/AP15_programmers_guide.doc
// This new tiling mode is controlled by SURFDESC for render surfaces, and 
// TEXDESC for textures.  Swizzling in xytiled mode is altered.
// 
// for 64, 32, 16 bits per pixel:
//   new_xbytes = (xbytes & ~0x8) | ((ylines & 0x1) << 3);
//   new_ylines = (ylines & ~0x1) | ((xbytes & 0x8) >> 3);
//
// for 8, 4 bits per pixel:
//   new_xbytes = (xbytes & ~0xc) | ((ylines & 0x3) << 2);
//   new_ylines = (ylines & ~0x3) | ((xbytes & 0xc) >> 2);
//
// visually this looks like this:
// 
//   * >= 16 bits per pixel
//       Each entry represents 64 bits
//       Linear:
//       00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f ....
//       10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
//       20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
//       30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f
//       40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f
//       50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f
//       60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f
//       .
//       .
//       .
//
//       Swizzled:
//       00 10 02 12 04 14 06 16 08 18 0a 1a 0c 1c 0e 1e ....
//       01 11 03 13 05 15 07 17 09 19 0c 1b 0d 1d 0f 1f
//       20 30 22 32 24 34 26 36 28 38 2a 3a 2c 3c 2e 3e
//       21 31 23 33 25 35 27 37 29 39 2c 3b 2d 3d 2f 3f
//       40 50 42 52 44 54 46 56 48 58 4a 5a 4c 5c 4e 5e
//       41 51 43 53 45 55 47 57 49 59 4c 5b 4d 5d 4f 5f
//       60 .. 62 .. 64 .. 66 .. 68 .. 6a .. 6c .. 6e ..
//       61 .. 63 .. 65 .. 67 .. 69 .. 6c .. 6d .. 6f ..
//
//   * <= 8 bits per pixel
//       Each entry represents 32 bits
//       Linear:
//       00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f ....
//       10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
//       20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
//       30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f
//       40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f
//       50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f
//       60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f
//       .
//       .
//       .
//
//       Swizzled:
//       00 10 20 30 04 14 24 34 08 18 28 38 0c 1c 2c 3c ....
//       01 11 21 31 05 15 25 35 09 19 29 39 0d 1d 2d 3d
//       02 12 22 32 06 16 26 36 0a 1a 2a 3a 0e 1e 2e 3e
//       03 13 23 33 07 17 27 37 0b 1b 2b 3b 0f 1f 2f 3f
//       40 50 60 .. 44 54 64 .. 48 58 68 .. 4c 5c 6c ..
//       41 51 61 .. 45 55 65 .. 49 59 69 .. 4d 5d 6d ..
//       42 52 62 .. 46 56 66 .. 4a 5a 6a .. 4e 5e 6e ..
//       43 53 63 .. 47 57 67 .. 4b 5b 6b .. 4f 5f 6f ..
//       .
//       .
//       .
//
// Notes:
//    * xytiled surfaces must be multiples of NV_MC_TILE_WIDTH bytes wide
//      and NV_MC_TILE_HEIGHT tall
//    * textures have special rules, see the TEXDESC register for more details
//
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
// Notes on SURFDESC
//
// ARRAY_STRIDE
// Units are bytes
// Used by P32_float and P128 formats.  Overlaps with the STRIDE field so don't
// write both fields in the same regiser. Indicates How many bytes between
// array entries for the same pixel.  Must be a multiple of
// NV_GR3D_SURF_BYTE_QUANTUM (bytes), or equivalently,
// NV_GR3D_SURF_W_QUANTUM (16b pixels).
// The ARRAY_STRIDE must also follow the following rule for LOCAL OFFSET_TYPES
// (see PSEQ.INST for info about OFFSET_TYPES)
//   Surface Format  Rule
//   P32_float       ARRAY_STRIDE >= ((PIX_ATTR.MAX_QID + 1) * 4 * 4
//   P128            ARRAY_STRIDE >= ((PIX_ATTR.MAX_QID + 1) * 4 * 16
//
// STRIDE
// Units are bytes.
// Used by all surface formats except P32_float and P128 float. Overlaps
// with the ARRAY_STRIDE field, so don't write both fields in the same register.
// For non-texture surfaces, the stride must be non-zero and must be a
// multiple of NV_GR3D_SURF_BYTE_QUANTUM (bytes), or equivalently,
// NV_GR3D_SURF_W_QUANTUM (16b pixels).
//
// QUADLIN
// When this signal is TILED in means that each 128b chuck of memory
// has swizzled pixel order which are described in detail above.
//
// UNDITHER
// The surface should be dithered on writes or undithered on reads using the
// DITHER table described below
// --------------------------------------------------------------------------
//
// The width of a surface (stride) must be a positive multiple of a certain
// number, which can be viewed in terms of 16b pixels or bytes.
//
// Additionally, FDC was designed to use 32B cache lines stored in
// alternate banks.  If a surface wraps a cacheline off the end of one
// line and into the beginning of the next line, there can be a loss of
// performance because one cacheline resides in two lines.  See bug
// 201949 for details.  Bottom line is while functional down to 16B
// alignment, better performance is obtained with 32B alignment.
//
// Note that some units place restrictions on the SURFDESC index
// associated with some surfaces.  In particular, QRAST only supports
// the depth buffer in the SURFDESC index given by NV_GR3D_Z_SURF_PTR,
// the stencil buffer in the SURFDESC index given by
// NV_GR3D_S_SURF_PTR, and the coverage buffer in the SURFDESC index
// given by NV_GR3D_V_SURF_PTR
// Also Note that if any of the Z_SURF S_SURF or V_SURF surfaces have
// STRUCTURE set to XY_TILED, they all must have STRUCTURE set to XY_TILED
// for example Z_SURF of XY_TILED and S_SURF of TILED is not allowed.
#define NV_GR3D_SURF_W_QUANTUM  8
// 8 16b pixels
#define NV_GR3D_SURF_BYTE_QUANTUM       16
// 16 bytes

// Register AR3D_GLOBAL_SURFDESC 
#define LIST_REG_FLD_AR3D_GLOBAL_SURFDESC(_) \
_(AR3D_GLOBAL,SURFDESC,STRUCTURE) \
_(AR3D_GLOBAL,SURFDESC,ARRAY_STRIDE) \
_(AR3D_GLOBAL,SURFDESC,STRIDE) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT) \
_(AR3D_GLOBAL,SURFDESC,QUADLIN) \
_(AR3D_GLOBAL,SURFDESC,DITHER)
#define REG_AR3D_GLOBAL_SURFDESC(_) _(AR3D_GLOBAL,SURFDESC,0xe10,0x10,16,1,0x7ffffff,0x0,ARY,FLD)
// page tiling LINEAR   -- no tiling
// TILED    -- tiled by adjusting address:
// XY_TILED -- tiled by adjusting x/y
#define REG_FLD_AR3D_GLOBAL_SURFDESC_STRUCTURE(_) _(AR3D_GLOBAL,SURFDESC,STRUCTURE,2,26,25,3,0x3,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_SURFDESC_STRUCTURE(_) \
_(AR3D_GLOBAL,SURFDESC,STRUCTURE,LINEAR,0) \
_(AR3D_GLOBAL,SURFDESC,STRUCTURE,TILED,1) \
_(AR3D_GLOBAL,SURFDESC,STRUCTURE,XY_TILED,2)
#define AR3D_GLOBAL_SURFDESC_STRUCTURE_LINEAR                   _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_SURFDESC_STRUCTURE_TILED                    _MK_ENUM_CONST(1)
#define AR3D_GLOBAL_SURFDESC_STRUCTURE_XY_TILED                 _MK_ENUM_CONST(2)

// Array stride in bytes (must be 1d surface)
#define REG_FLD_AR3D_GLOBAL_SURFDESC_ARRAY_STRIDE(_) _(AR3D_GLOBAL,SURFDESC,ARRAY_STRIDE,17,24,8,3,0x1ffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_SURFDESC_ARRAY_STRIDE(_)

// Surface stride in bytes
#define REG_FLD_AR3D_GLOBAL_SURFDESC_STRIDE(_) _(AR3D_GLOBAL,SURFDESC,STRIDE,16,23,8,3,0xffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_SURFDESC_STRIDE(_)

// Surface format
#define REG_FLD_AR3D_GLOBAL_SURFDESC_SURF_FORMAT(_) _(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,6,7,2,3,0x3f,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_SURFDESC_SURF_FORMAT(_) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,C4X4,0) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,A8,1) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,L8,2) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,S8,3) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,L8A8,4) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,B2G3R3,5) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,B5G6R5,6) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,B5G5R5A1,7) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,B4G4R4A4,8) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,A1B5G5R5,9) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,A4B4G4R4,10) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,Z16,11) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,Z16NL,12) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,R8G8B8A8,13) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,B8G8R8A8,14) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,A16_float,15) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,L16_float,16) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,L16A16_float,17) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,R16G16B16A16_float,18) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,R11G11B10_float,19) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,P128,20) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,P32_float,21) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,DXT1,22) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,DXT1C,23) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,DXT3,24) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,DXT5,25) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,ETC,26) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,ETC3,27) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,ETC5,28) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,LATC1,29) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,LATC2,30) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,B8G8R8G8,31) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,G8B8G8R8,32) \
_(AR3D_GLOBAL,SURFDESC,SURF_FORMAT,R10G10B10_float_A2,33)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_C4X4                   _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_A8                     _MK_ENUM_CONST(1)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_L8                     _MK_ENUM_CONST(2)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_S8                     _MK_ENUM_CONST(3)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_L8A8                   _MK_ENUM_CONST(4)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_B2G3R3                 _MK_ENUM_CONST(5)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_B5G6R5                 _MK_ENUM_CONST(6)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_B5G5R5A1                       _MK_ENUM_CONST(7)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_B4G4R4A4                       _MK_ENUM_CONST(8)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_A1B5G5R5                       _MK_ENUM_CONST(9)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_A4B4G4R4                       _MK_ENUM_CONST(10)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_Z16                    _MK_ENUM_CONST(11)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_Z16NL                  _MK_ENUM_CONST(12)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_R8G8B8A8                       _MK_ENUM_CONST(13)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_B8G8R8A8                       _MK_ENUM_CONST(14)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_A16_float                      _MK_ENUM_CONST(15)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_L16_float                      _MK_ENUM_CONST(16)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_L16A16_float                   _MK_ENUM_CONST(17)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_R16G16B16A16_float                     _MK_ENUM_CONST(18)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_R11G11B10_float                        _MK_ENUM_CONST(19)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_P128                   _MK_ENUM_CONST(20)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_P32_float                      _MK_ENUM_CONST(21)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_DXT1                   _MK_ENUM_CONST(22)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_DXT1C                  _MK_ENUM_CONST(23)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_DXT3                   _MK_ENUM_CONST(24)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_DXT5                   _MK_ENUM_CONST(25)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_ETC                    _MK_ENUM_CONST(26)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_ETC3                   _MK_ENUM_CONST(27)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_ETC5                   _MK_ENUM_CONST(28)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_LATC1                  _MK_ENUM_CONST(29)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_LATC2                  _MK_ENUM_CONST(30)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_B8G8R8G8                       _MK_ENUM_CONST(31)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_G8B8G8R8                       _MK_ENUM_CONST(32)
#define AR3D_GLOBAL_SURFDESC_SURF_FORMAT_R10G10B10_float_A2                     _MK_ENUM_CONST(33)

// SC25+ only (ignored in mg20) When this signal is TILED, it means
// that each 128b chunk of memory has swizzled pixel order,
// which is described in detail above.
#define REG_FLD_AR3D_GLOBAL_SURFDESC_QUADLIN(_) _(AR3D_GLOBAL,SURFDESC,QUADLIN,1,1,1,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_SURFDESC_QUADLIN(_) \
_(AR3D_GLOBAL,SURFDESC,QUADLIN,LINEAR,0) \
_(AR3D_GLOBAL,SURFDESC,QUADLIN,TILED,1)
#define AR3D_GLOBAL_SURFDESC_QUADLIN_LINEAR                     _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_SURFDESC_QUADLIN_TILED                      _MK_ENUM_CONST(1)

// The surface should be dithered on write, and undithered on read.
#define REG_FLD_AR3D_GLOBAL_SURFDESC_DITHER(_) _(AR3D_GLOBAL,SURFDESC,DITHER,1,0,0,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_SURFDESC_DITHER(_) \
_(AR3D_GLOBAL,SURFDESC,DITHER,DISABLE,0) \
_(AR3D_GLOBAL,SURFDESC,DITHER,ENABLE,1)
#define AR3D_GLOBAL_SURFDESC_DITHER_DISABLE                     _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_SURFDESC_DITHER_ENABLE                      _MK_ENUM_CONST(1)

// Notes on PIX_ATTR
// Specifies First Sequence, Num Rows, Max Quad Id
// This register must be programmed correctly
// before any pixels enter the pipeline.  The FIRST_SEQUENCE
// is only used when in passthrough mode (AR3D_PSEQ_CTL.fMAX_OUT==0)
// otherwise the FIRST_SEQUENCE comes from the AR3D_PSEQ_COMMAND table

// Register AR3D_GLOBAL_PIX_ATTR 
#define LIST_REG_FLD_AR3D_GLOBAL_PIX_ATTR(_) \
_(AR3D_GLOBAL,PIX_ATTR,NUM_ROWS) \
_(AR3D_GLOBAL,PIX_ATTR,FIRST_SEQUENCE) \
_(AR3D_GLOBAL,PIX_ATTR,MAX_QID)
#define REG_AR3D_GLOBAL_PIX_ATTR(_) _(AR3D_GLOBAL,PIX_ATTR,0xe20,0x20,1,1,0xff003f03,0x0,NOARY,FLD)
// Set the number of rows minus 1 that RS will
// populate in the RAST_R packet (i.e. setting
// to 0 indicates 1 row).  Up to 4 rows are
// allowed
#define REG_FLD_AR3D_GLOBAL_PIX_ATTR_NUM_ROWS(_) _(AR3D_GLOBAL,PIX_ATTR,NUM_ROWS,2,1,0,3,0x3,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_PIX_ATTR_NUM_ROWS(_)

// first sequence number for a program
#define REG_FLD_AR3D_GLOBAL_PIX_ATTR_FIRST_SEQUENCE(_) _(AR3D_GLOBAL,PIX_ATTR,FIRST_SEQUENCE,6,13,8,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_PIX_ATTR_FIRST_SEQUENCE(_)

// max quad_id
// What point do we wrap the QID values generated by
// pseq (in quads so the size of the field is
// NV_MAX_FRAGMENT_LOOP_DEPTH_LOG2-2)
// For best performance this should set to follow this rule:
// MAX_QID >= (PSEQ_CTL.MAX_OUT - 1) / (4 * (PIX_ATTR.NUM_ROWS + 1))
// Larger MAX_QID values will require larger P32_float 
// or P128 surface array_strides.  See SURFDESC's 
// ARRAY_STRIDE field.  
// If lowering the value of this field, AR3D_PSEQ_QUAD_ID register 
// must be written to 0.
#define REG_FLD_AR3D_GLOBAL_PIX_ATTR_MAX_QID(_) _(AR3D_GLOBAL,PIX_ATTR,MAX_QID,8,31,24,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_PIX_ATTR_MAX_QID(_)

//
// NUM_TRIS and TRI_ROWS control the organization of the TRAM, which is used to pass attributes to
// the fragment shader.  NUM_TRIS indicates the maximum number of concurrent triangles permitted in the fragment pipe.
// The more, the better for performance.  TRI_ROWS indicates the number of TRAM rows per triangle.  Constraints.
// 1. NUM_TRIS * TRI_ROWS <= NV_GR3D_TRAM_ROWS
// 2. NUM_TRIS >= 2  (i.e., two or more triangles in flight)
// 3. TRI_ROWS > 0
//
// This register cannot be changed while pixels are in flight in the pixel pipe.
// a RAISE/WAIT or SYNCPT.RD_DONE before changing this register will be sufficient.
// see bugid: 309929

// Register AR3D_GLOBAL_TRI_ATTR 
#define LIST_REG_FLD_AR3D_GLOBAL_TRI_ATTR(_) \
_(AR3D_GLOBAL,TRI_ATTR,NUM_TRIS) \
_(AR3D_GLOBAL,TRI_ATTR,TRI_ROWS)
#define REG_AR3D_GLOBAL_TRI_ATTR(_) _(AR3D_GLOBAL,TRI_ATTR,0xe21,0x21,1,1,0x7f7f,0x0,NOARY,FLD)
// number of triangles in ATRAST triangle RAM
// (max NV_GR3D_TRAM_ROWS)
#define REG_FLD_AR3D_GLOBAL_TRI_ATTR_NUM_TRIS(_) _(AR3D_GLOBAL,TRI_ATTR,NUM_TRIS,7,6,0,3,0x7f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_TRI_ATTR_NUM_TRIS(_)

// number of rows per triangle in triangle RAM
// (max floor(NV_GR3D_TRAM_ROWS/NUM_TRIS))
#define REG_FLD_AR3D_GLOBAL_TRI_ATTR_TRI_ROWS(_) _(AR3D_GLOBAL,TRI_ATTR,TRI_ROWS,7,14,8,3,0x7f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_TRI_ATTR_TRI_ROWS(_)

//
// INST_OFFSET
//   this instruction indecates the offset PSEQ_INST_OFFSET,
//   ATRAST_REMAP_OFFSET, TEX_INST_OFFSET, ALU_REMAP_OFFSET,
//   P2CX_OFFSET, and DW_INST_OFFSET (measured in sequence numbers)
//
//   because this is in sequence numbers instead of words there is
//   an adjustement based on the size of the unit's instructions
//   PSEQ_INST_OFFSET = INST_OFFSET * NV_GR3D_PIXPKT_PSEQ_INST_NUM_WORDS
//   AT_REMAP_OFSET   = INST_OFFSET * NV_GR3D_PIXPKT_INST_NUM_WORDS
//   TEX_INST_OFFSET  = INST_OFFSET * NV_GR3D_PIXPKT_TEX_INST_NUM_WORDS
//   ALU_REMAP_OFSET  = INST_OFFSET * NV_GR3D_PIXPKT_INST_NUM_WORDS
//   DW_INST_OFFSET   = INST_OFFSET * NV_GR3D_PIXPKT_DW_INST_NUM_WORDS
//   P2CX_OFFSET      = INST_OFFSET * NV_GR3D_PIXPKT_P2CX_INST_NUM_WORDS

// Register AR3D_GLOBAL_INST_OFFSET 
#define LIST_REG_FLD_AR3D_GLOBAL_INST_OFFSET(_) \
_(AR3D_GLOBAL,INST_OFFSET,INDEX)
#define REG_AR3D_GLOBAL_INST_OFFSET(_) _(AR3D_GLOBAL,INST_OFFSET,0xe22,0x22,1,1,0x3f,0x0,NOARY,FLD)
// Sequence Offset
#define REG_FLD_AR3D_GLOBAL_INST_OFFSET_INDEX(_) _(AR3D_GLOBAL,INST_OFFSET,INDEX,6,5,0,3,0x3f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_INST_OFFSET_INDEX(_)

// RAISE method, software now updates this directly (no more RAISE packet)
// When the host sees a raise returned from 3d, all of 3d's read and write memory
// accesses before the raise have finished.

// Register AR3D_GLOBAL_RAISE 
#define LIST_REG_FLD_AR3D_GLOBAL_RAISE(_) \
_(AR3D_GLOBAL,RAISE,SIGNAL) \
_(AR3D_GLOBAL,RAISE,CHANNEL) \
_(AR3D_GLOBAL,RAISE,SYNCPT_INCR)
#define REG_AR3D_GLOBAL_RAISE(_) _(AR3D_GLOBAL,RAISE,0xe23,0x23,1,1,0x80000f1f,0x0,NOARY,FLD)
// GK Module Latches SIGNAL value on its final loop
// through the pipeline to send to Host module
#define REG_FLD_AR3D_GLOBAL_RAISE_SIGNAL(_) _(AR3D_GLOBAL,RAISE,SIGNAL,5,4,0,2,0x1f,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_RAISE_SIGNAL(_)

// channel ID to send raise to
#define REG_FLD_AR3D_GLOBAL_RAISE_CHANNEL(_) _(AR3D_GLOBAL,RAISE,CHANNEL,4,11,8,2,0xf,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_RAISE_CHANNEL(_)

#define REG_FLD_AR3D_GLOBAL_RAISE_SYNCPT_INCR(_) _(AR3D_GLOBAL,RAISE,SYNCPT_INCR,1,31,31,2,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_RAISE_SYNCPT_INCR(_) \
_(AR3D_GLOBAL,RAISE,SYNCPT_INCR,DISABLE,0) \
_(AR3D_GLOBAL,RAISE,SYNCPT_INCR,ENABLE,1)
#define AR3D_GLOBAL_RAISE_SYNCPT_INCR_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_RAISE_SYNCPT_INCR_ENABLE                    _MK_ENUM_CONST(1)

// REFCNT method, software updates this directly
// When the host sees a refcnt returned from 3d, all of 3d's memory read memory
// accesses have finished.

// Register AR3D_GLOBAL_REFCNT 
#define LIST_REG_FLD_AR3D_GLOBAL_REFCNT(_) \
_(AR3D_GLOBAL,REFCNT,VALUE) \
_(AR3D_GLOBAL,REFCNT,SYNCPT_INCR)
#define REG_AR3D_GLOBAL_REFCNT(_) _(AR3D_GLOBAL,REFCNT,0xe24,0x24,1,1,0xffffffff,0x0,NOARY,FLD)
// GK Module Latches VALUE on its final loop and updates the host
#define REG_FLD_AR3D_GLOBAL_REFCNT_VALUE(_) _(AR3D_GLOBAL,REFCNT,VALUE,32,31,0,2,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_REFCNT_VALUE(_)

#define REG_FLD_AR3D_GLOBAL_REFCNT_SYNCPT_INCR(_) _(AR3D_GLOBAL,REFCNT,SYNCPT_INCR,1,31,31,2,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_REFCNT_SYNCPT_INCR(_) \
_(AR3D_GLOBAL,REFCNT,SYNCPT_INCR,DISABLE,0) \
_(AR3D_GLOBAL,REFCNT,SYNCPT_INCR,ENABLE,1)
#define AR3D_GLOBAL_REFCNT_SYNCPT_INCR_DISABLE                  _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_REFCNT_SYNCPT_INCR_ENABLE                   _MK_ENUM_CONST(1)

// statistics enable method (gates stat collection as it flows down the pipeline)

// Register AR3D_GLOBAL_INSTRUMENT 
#define LIST_REG_FLD_AR3D_GLOBAL_INSTRUMENT(_) \
_(AR3D_GLOBAL,INSTRUMENT,STAT_EN)
#define REG_AR3D_GLOBAL_INSTRUMENT(_) _(AR3D_GLOBAL,INSTRUMENT,0xe25,0x25,1,1,0x1,0x0,NOARY,FLD)
// Enables Performance Monitoring
#define REG_FLD_AR3D_GLOBAL_INSTRUMENT_STAT_EN(_) _(AR3D_GLOBAL,INSTRUMENT,STAT_EN,1,0,0,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_INSTRUMENT_STAT_EN(_)

//
// DITHER: This is a dither tables
// shared between pseq and dw. 
// pseq uses the table to undither surfaces that
// have DITHER == ENABLE, and dw uses the table to dither surfaces that
// have DITHER == ENABLE.
// The values in the table are setup for 8->5 bit conversions (really N->(N-3)):
//
//  76543210 <-- 8-bit value
// +     210 <-- dither value
//  --------
//  43210    <-- 5-bit result (truncated)
//
// 8->6 conversions look like:
//
//  76543210 <-- 8-bit value
// +      21 <-- dither value >> 1
//  --------
//  543210   <-- 6-bit result (truncated)
//
// in addition, in order to spread the energy of the dither pattern around, each
// component (R, G, B, A) uses a translated version of the dither table:
//
// R : dither[(x & 1)][(y & 1)]
// G : dither[((x + 1) & 1)][(y & 1)]
// B : dither[(x & 1)][((y + 1) & 1)]
// A : dither[((x + 1) & 1)][((y + 1) & 1)]
//
// DW and PSEQ interpret the lookup table entries as signed values biased by +4 -- they subtract
// 4 from the table entry to yield a dither value in [-4,3].
// DW adds this value to perform dither, while PSEQ performs an undither
// operation by subtracting the same value.
// Note that undithering needs to clamp results to the legal range of values [0..1].
//

// Register AR3D_GLOBAL_DITHER_TABLE // X_Y
#define LIST_REG_FLD_AR3D_GLOBAL_DITHER_TABLE(_) \
_(AR3D_GLOBAL,DITHER_TABLE,DITHER_ALPHA) \
_(AR3D_GLOBAL,DITHER_TABLE,ONE_ONE) \
_(AR3D_GLOBAL,DITHER_TABLE,ONE_ZERO) \
_(AR3D_GLOBAL,DITHER_TABLE,ZERO_ONE) \
_(AR3D_GLOBAL,DITHER_TABLE,ZERO_ZERO)
#define REG_AR3D_GLOBAL_DITHER_TABLE(_) _(AR3D_GLOBAL,DITHER_TABLE,0xe26,0x26,1,1,0x1fff,0x0,NOARY,FLD)
// should color writes dither result alpha (only useful for dest alpha)?
#define REG_FLD_AR3D_GLOBAL_DITHER_TABLE_DITHER_ALPHA(_) _(AR3D_GLOBAL,DITHER_TABLE,DITHER_ALPHA,1,12,12,3,0x1,0x0,NOINITENM,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_DITHER_TABLE_DITHER_ALPHA(_) \
_(AR3D_GLOBAL,DITHER_TABLE,DITHER_ALPHA,DISABLE,0) \
_(AR3D_GLOBAL,DITHER_TABLE,DITHER_ALPHA,ENABLE,1)
#define AR3D_GLOBAL_DITHER_TABLE_DITHER_ALPHA_DISABLE                   _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_DITHER_TABLE_DITHER_ALPHA_ENABLE                    _MK_ENUM_CONST(1)

// dither value at x+1,y+1
#define REG_FLD_AR3D_GLOBAL_DITHER_TABLE_ONE_ONE(_) _(AR3D_GLOBAL,DITHER_TABLE,ONE_ONE,3,11,9,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_DITHER_TABLE_ONE_ONE(_)

// dither value at x+1,y+0
#define REG_FLD_AR3D_GLOBAL_DITHER_TABLE_ONE_ZERO(_) _(AR3D_GLOBAL,DITHER_TABLE,ONE_ZERO,3,8,6,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_DITHER_TABLE_ONE_ZERO(_)

// dither value at x+0,y+1
#define REG_FLD_AR3D_GLOBAL_DITHER_TABLE_ZERO_ONE(_) _(AR3D_GLOBAL,DITHER_TABLE,ZERO_ONE,3,5,3,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_DITHER_TABLE_ZERO_ONE(_)

// dither value at x+0,y+0
#define REG_FLD_AR3D_GLOBAL_DITHER_TABLE_ZERO_ZERO(_) _(AR3D_GLOBAL,DITHER_TABLE,ZERO_ZERO,3,2,0,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_DITHER_TABLE_ZERO_ZERO(_)

//To flush the texture cache
//This can be done a couple of ways.
//1. Will be flushed if below FLUSH register is written to with a 1.
//2. Any write to the texture surface descriptor table (TEXDESC) will also cause a flush
//3. Any write to the texture surface address table (TEXADDR) will also cause a flush
//4. Also the cache will be disabled(continuously flushed) if texctl is set to AR3D_TEX_TEXCTL_0_TEXTURE_CACHE_EN_DISABLE
//
// Note: the FLUSH.TEXTURE bit is a 1-shot: After setting it to 1, it doesn't
//       have to be manually reset to 0
//
// FLUSH.QRAST is a setting which is generated and consumed in QRAST.  It is used to make sure
// that QRAST is not holding onto a triangle ID for a triangle which has been entirely killed.
// Note that QRAST consumes all FLUSH packets that have this bit set.

// Register AR3D_GLOBAL_FLUSH 
#define LIST_REG_FLD_AR3D_GLOBAL_FLUSH(_) \
_(AR3D_GLOBAL,FLUSH,TEXTURE) \
_(AR3D_GLOBAL,FLUSH,QRAST)
#define REG_AR3D_GLOBAL_FLUSH(_) _(AR3D_GLOBAL,FLUSH,0xe27,0x27,1,1,0x3,0x0,NOARY,FLD)
// Explicitly flush the texture cache.
#define REG_FLD_AR3D_GLOBAL_FLUSH_TEXTURE(_) _(AR3D_GLOBAL,FLUSH,TEXTURE,1,0,0,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_FLUSH_TEXTURE(_)

// Internally generated/consumed packet in qrast to flush out TIDs.
#define REG_FLD_AR3D_GLOBAL_FLUSH_QRAST(_) _(AR3D_GLOBAL,FLUSH,QRAST,1,1,1,2,0x1,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_FLUSH_QRAST(_)

// This packet is used in DW and QRAST to define the stencil operation.

// Packet STENCIL_OP
#define LIST_PKT_FLD_STENCIL_OP(_) \
_(STENCIL_OP,OP)
#define PKT_STENCIL_OP(_) _(STENCIL_OP,3,FLD)
#define PKT_FLD_STENCIL_OP_OP(_) _(STENCIL_OP,OP,0,3,2,0,0x7,ENM)
#define LIST_PKT_ENM_STENCIL_OP_OP(_) \
_(STENCIL_OP,OP,ZERO,0) \
_(STENCIL_OP,OP,KEEP,1) \
_(STENCIL_OP,OP,REPLACE,2) \
_(STENCIL_OP,OP,INCR,3) \
_(STENCIL_OP,OP,DECR,4) \
_(STENCIL_OP,OP,INVERT,5) \
_(STENCIL_OP,OP,INCR_WRAP,6) \
_(STENCIL_OP,OP,DECR_WRAP,7)
// S_OPERATION defines the stencil surface and the associated stencil
// update operations.  For stencil operations, we need two entries.  The
// first entry is for front facing triangles.  The second entry is
// for back facing triangles.  Most of this packet is used by DW and RAST
// in AR20.  S_FAIL, Z_FAIL, and ZPASS are per-face and come from StencilOp()
// S_WR_MASK, also per face, comes from StencilMask().  S_REF is the per
// face value from StencilFunc().

// Register AR3D_GLOBAL_S_OPERATION 
#define LIST_REG_FLD_AR3D_GLOBAL_S_OPERATION(_) \
_(AR3D_GLOBAL,S_OPERATION,S_FAIL) \
_(AR3D_GLOBAL,S_OPERATION,Z_FAIL) \
_(AR3D_GLOBAL,S_OPERATION,Z_PASS) \
_(AR3D_GLOBAL,S_OPERATION,S_WR_MASK) \
_(AR3D_GLOBAL,S_OPERATION,S_REF)
#define REG_AR3D_GLOBAL_S_OPERATION(_) _(AR3D_GLOBAL,S_OPERATION,0xe28,0x28,2,1,0x1ffffff,0x0,ARY,FLD)
//stencil op when the pixel is in S_FAIL state
#define REG_FLD_AR3D_GLOBAL_S_OPERATION_S_FAIL(_) _(AR3D_GLOBAL,S_OPERATION,S_FAIL,3,2,0,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_S_OPERATION_S_FAIL(_)

//stencil op when the pixel is in Z_FAIL state
#define REG_FLD_AR3D_GLOBAL_S_OPERATION_Z_FAIL(_) _(AR3D_GLOBAL,S_OPERATION,Z_FAIL,3,5,3,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_S_OPERATION_Z_FAIL(_)

//stencil op when the pixel is in Z_PASS state
#define REG_FLD_AR3D_GLOBAL_S_OPERATION_Z_PASS(_) _(AR3D_GLOBAL,S_OPERATION,Z_PASS,3,8,6,3,0x7,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_S_OPERATION_Z_PASS(_)

//stencil write mask (8 bits)
#define REG_FLD_AR3D_GLOBAL_S_OPERATION_S_WR_MASK(_) _(AR3D_GLOBAL,S_OPERATION,S_WR_MASK,8,16,9,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_S_OPERATION_S_WR_MASK(_)

//stencil reference (8 bits)
#define REG_FLD_AR3D_GLOBAL_S_OPERATION_S_REF(_) _(AR3D_GLOBAL,S_OPERATION,S_REF,8,24,17,3,0xff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_S_OPERATION_S_REF(_)

// SPILLSURFADDR contains the base address of a pixel spill surface
// pseq's command EXECUTE.SPILL will use this surface to temporarily store
// pixels data while the fragment pipe is reloaded with instruction data.
//
// The pixel spill surface should be large enough to hold all the packets
// in the pipeline.  Each packet uses 16 bytes, and  the number of packets
// allowed in the pipeline is determined by the AR3D_PSEQ_CTL register
// Total size in bytes = ((AR3D_PSEQ_CTL.MAX_OUT + 17) * 16)

// Register AR3D_GLOBAL_SPILLSURFADDR 
#define LIST_REG_FLD_AR3D_GLOBAL_SPILLSURFADDR(_) \
_(AR3D_GLOBAL,SPILLSURFADDR,BASE_ADDRESS)
#define REG_AR3D_GLOBAL_SPILLSURFADDR(_) _(AR3D_GLOBAL,SPILLSURFADDR,0xe2a,0x2a,1,1,0xffffffff,0x0,NOARY,FLD)
// This spill surface base address must be aligned to NV_GR3D_SURF_ADDRESS_ALIGNMENT_BYTES
// Address map is described in project_<project>.spec.
// For example, MG20's address map is described in project_mg20.spec
// NV_GR3D_SURF_ADDRESS_ALIGNMENT_FAST_BYTES alignment will provide better performance, but less flexibility
#define REG_FLD_AR3D_GLOBAL_SPILLSURFADDR_BASE_ADDRESS(_) _(AR3D_GLOBAL,SPILLSURFADDR,BASE_ADDRESS,32,31,0,3,0xffffffff,0x0,NOINITENM,NOENM)
#define LIST_REG_ENM_AR3D_GLOBAL_SPILLSURFADDR_BASE_ADDRESS(_)

//
// Memory Client Interface Async Fifo Optimization Register
// This can only be changed while the pipeline is completely idle.
//
// Memory Client Interface Fifo Control Register.
// The registers below allow to optimize the synchronization timing in
// the memory client asynchronous fifos. When they can be used depend on
// the client and memory controller clock ratio.
// Additionally, the RDMC_RDFAST/RDCL_RDFAST fields can increase power
// consumption if the asynchronous fifo is implemented as a real ram.
// There is no power impact on latch-based fifos. Flipflop-based fifos
// do not use these fields.
// See recommended settings below.
//
// !! IMPORTANT !!
// The register fields can only be changed when the memory client async
// fifos are empty.
//
// The register field ending with WRCL_MCLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one client clock cycle if
// the memory controller clock frequency is less or equal to twice the client
// clock frequency:
//
//      mcclk_freq <= 2 * clientclk_freq
//
// The register field ending with WRMC_CLLE2X (if any) can be set to improve
// async fifo synchronization on the write side by one memory controller clock
// cycle if the client clock frequency is less or equal to twice the memory
// controller clock frequency:
//
//      clientclk_freq <= 2 * mcclk_freq
//
// The register field ending with RDMC_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one memory controller clock cycle.
//
// !! WARNING !!
// RDMC_RDFAST can be used along with WRCL_MCLE2X only when:
//
//       mcclk_freq <= clientclk_freq
//
// The register field ending with RDCL_RDFAST (if any) can be set to improve async
// fifo synchronization on the read side by one client clock cycle.
//
// !! WARNING !!
// RDCL_RDFAST can be used along with WRMC_CLLE2X only when:
//
//       clientclk_freq <= mcclk_freq
//
// RECOMMENDED SETTINGS
// # Client writing to fifo, memory controller reading from fifo
// - mcclk_freq <= clientclk_freq
//     You can enable both RDMC_RDFAST and WRCL_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDMC_RDFAST.
// - clientclk_freq < mcclk_freq <= 2 * clientclk_freq
//     You can enable RDMC_RDFAST or WRCL_MCLE2X, but because the client clock
//     is slower, you should enable only WRCL_MCLE2X.
// - 2 * clientclk_freq < mcclk_freq
//     You can only enable RDMC_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDMC_RDFAST.
//
// # Memory controller writing to fifo, client reading from fifo
// - clientclk_freq <= mcclk_freq
//     You can enable both RDCL_RDFAST and WRMC_CLLE2X. If one of the fifos is
//     a real ram and power is a concern, you should avoid enabling RDCL_RDFAST.
// - mcclk_freq < clientclk_freq <= 2 * mcclk_freq
//     You can enable RDCL_RDFAST or WRMC_CLLE2X, but because the memory controller
//     clock is slower, you should enable only WRMC_CLLE2X.
// - 2 * mcclk_freq < clientclk_freq
//     You can only enable RDCL_RDFAST. If one of the fifos is a real ram and
//     power is a concern, you should avoid enabling RDCL_RDFAST.
//

// Register AR3D_GLOBAL_NV_MCCIF_FIFOCTRL 
#define LIST_REG_FLD_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL(_) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_WRCL_MCLE2X) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_RDMC_RDFAST) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_WRMC_CLLE2X) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_RDCL_RDFAST)
#define REG_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL(_) _(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,0xe2b,0x2b,1,1,0xf,0x0,NOARY,FLD)
#define REG_FLD_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_WRCL_MCLE2X(_) _(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_WRCL_MCLE2X,1,0,0,3,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_WRCL_MCLE2X(_) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_WRCL_MCLE2X,DISABLE,0) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_WRCL_MCLE2X,ENABLE,1)
#define AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_WRCL_MCLE2X_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_WRCL_MCLE2X_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_RDMC_RDFAST(_) _(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_RDMC_RDFAST,1,1,1,3,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_RDMC_RDFAST(_) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_RDMC_RDFAST,DISABLE,0) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_RDMC_RDFAST,ENABLE,1)
#define AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_RDMC_RDFAST_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_RDMC_RDFAST_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_WRMC_CLLE2X(_) _(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_WRMC_CLLE2X,1,2,2,3,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_WRMC_CLLE2X(_) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_WRMC_CLLE2X,DISABLE,0) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_WRMC_CLLE2X,ENABLE,1)
#define AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_WRMC_CLLE2X_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_WRMC_CLLE2X_ENABLE                       _MK_ENUM_CONST(1)

#define REG_FLD_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_RDCL_RDFAST(_) _(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_RDCL_RDFAST,1,3,3,3,0x1,0x0,DISABLE,ENM)
#define LIST_REG_ENM_AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_RDCL_RDFAST(_) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_RDCL_RDFAST,DISABLE,0) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,NV_MCCIF_RDCL_RDFAST,ENABLE,1)
#define AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_RDCL_RDFAST_DISABLE                      _MK_ENUM_CONST(0)
#define AR3D_GLOBAL_NV_MCCIF_FIFOCTRL_NV_MCCIF_RDCL_RDFAST_ENABLE                       _MK_ENUM_CONST(1)

// --------------------------------------------------------------------------
//
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// ########################## Internal packet definitions ######################
//
// This file contains implementation details that programmers don't need to see
#define AR_SNAP_BITS    4
#define SETUP_PACKET_WIDTH      96
#define SETUP_SB_WIDTH  11
// Global defines
//--------------------------------------
//FP20 used all over the
//3d pipe. TD stands for 3d.
//---------------------------------------

// Packet TD_FLOAT
#define LIST_PKT_FLD_TD_FLOAT(_) \
_(TD_FLOAT,FLOAT) \
_(TD_FLOAT,MANT) \
_(TD_FLOAT,EXP) \
_(TD_FLOAT,SIGN)
#define PKT_TD_FLOAT(_) _(TD_FLOAT,20,FLD)
#define PKT_FLD_TD_FLOAT_FLOAT(_) _(TD_FLOAT,FLOAT,0,20,19,0,0xfffff,NOENM)
#define LIST_PKT_ENM_TD_FLOAT_FLOAT(_)
#define PKT_FLD_TD_FLOAT_MANT(_) _(TD_FLOAT,MANT,0,13,12,0,0x1fff,NOENM)
#define LIST_PKT_ENM_TD_FLOAT_MANT(_)
#define PKT_FLD_TD_FLOAT_EXP(_) _(TD_FLOAT,EXP,0,6,18,13,0x3f,NOENM)
#define LIST_PKT_ENM_TD_FLOAT_EXP(_)
#define PKT_FLD_TD_FLOAT_SIGN(_) _(TD_FLOAT,SIGN,0,1,19,19,0x1,NOENM)
#define LIST_PKT_ENM_TD_FLOAT_SIGN(_)

// Packet IEEE_FLOAT
#define LIST_PKT_FLD_IEEE_FLOAT(_) \
_(IEEE_FLOAT,FLOAT) \
_(IEEE_FLOAT,MANT) \
_(IEEE_FLOAT,EXP) \
_(IEEE_FLOAT,SIGN)
#define PKT_IEEE_FLOAT(_) _(IEEE_FLOAT,32,FLD)
#define PKT_FLD_IEEE_FLOAT_FLOAT(_) _(IEEE_FLOAT,FLOAT,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_IEEE_FLOAT_FLOAT(_)
#define PKT_FLD_IEEE_FLOAT_MANT(_) _(IEEE_FLOAT,MANT,0,23,22,0,0x7fffff,NOENM)
#define LIST_PKT_ENM_IEEE_FLOAT_MANT(_)
#define PKT_FLD_IEEE_FLOAT_EXP(_) _(IEEE_FLOAT,EXP,0,8,30,23,0xff,NOENM)
#define LIST_PKT_ENM_IEEE_FLOAT_EXP(_)
#define PKT_FLD_IEEE_FLOAT_SIGN(_) _(IEEE_FLOAT,SIGN,0,1,31,31,0x1,NOENM)
#define LIST_PKT_ENM_IEEE_FLOAT_SIGN(_)
// FP22 used in ATRAST

// Packet FP22_FLOAT
#define LIST_PKT_FLD_FP22_FLOAT(_) \
_(FP22_FLOAT,FLOAT) \
_(FP22_FLOAT,MANT) \
_(FP22_FLOAT,EXP) \
_(FP22_FLOAT,SIGN)
#define PKT_FP22_FLOAT(_) _(FP22_FLOAT,22,FLD)
#define PKT_FLD_FP22_FLOAT_FLOAT(_) _(FP22_FLOAT,FLOAT,0,22,21,0,0x3fffff,NOENM)
#define LIST_PKT_ENM_FP22_FLOAT_FLOAT(_)
#define PKT_FLD_FP22_FLOAT_MANT(_) _(FP22_FLOAT,MANT,0,15,14,0,0x7fff,NOENM)
#define LIST_PKT_ENM_FP22_FLOAT_MANT(_)
#define PKT_FLD_FP22_FLOAT_EXP(_) _(FP22_FLOAT,EXP,0,6,20,15,0x3f,NOENM)
#define LIST_PKT_ENM_FP22_FLOAT_EXP(_)
#define PKT_FLD_FP22_FLOAT_SIGN(_) _(FP22_FLOAT,SIGN,0,1,21,21,0x1,NOENM)
#define LIST_PKT_ENM_FP22_FLOAT_SIGN(_)
// FP16 used in DWR

// Packet FP16_FLOAT
#define LIST_PKT_FLD_FP16_FLOAT(_) \
_(FP16_FLOAT,FLOAT) \
_(FP16_FLOAT,MANT) \
_(FP16_FLOAT,EXP) \
_(FP16_FLOAT,SIGN)
#define PKT_FP16_FLOAT(_) _(FP16_FLOAT,16,FLD)
#define PKT_FLD_FP16_FLOAT_FLOAT(_) _(FP16_FLOAT,FLOAT,0,16,15,0,0xffff,NOENM)
#define LIST_PKT_ENM_FP16_FLOAT_FLOAT(_)
#define PKT_FLD_FP16_FLOAT_MANT(_) _(FP16_FLOAT,MANT,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_FP16_FLOAT_MANT(_)
#define PKT_FLD_FP16_FLOAT_EXP(_) _(FP16_FLOAT,EXP,0,5,14,10,0x1f,NOENM)
#define LIST_PKT_ENM_FP16_FLOAT_EXP(_)
#define PKT_FLD_FP16_FLOAT_SIGN(_) _(FP16_FLOAT,SIGN,0,1,15,15,0x1,NOENM)
#define LIST_PKT_ENM_FP16_FLOAT_SIGN(_)
// FP11 used in DWR

// Packet FP11_FLOAT
#define LIST_PKT_FLD_FP11_FLOAT(_) \
_(FP11_FLOAT,FLOAT) \
_(FP11_FLOAT,MANT) \
_(FP11_FLOAT,EXP)
#define PKT_FP11_FLOAT(_) _(FP11_FLOAT,11,FLD)
#define PKT_FLD_FP11_FLOAT_FLOAT(_) _(FP11_FLOAT,FLOAT,0,11,10,0,0x7ff,NOENM)
#define LIST_PKT_ENM_FP11_FLOAT_FLOAT(_)
#define PKT_FLD_FP11_FLOAT_MANT(_) _(FP11_FLOAT,MANT,0,6,5,0,0x3f,NOENM)
#define LIST_PKT_ENM_FP11_FLOAT_MANT(_)
#define PKT_FLD_FP11_FLOAT_EXP(_) _(FP11_FLOAT,EXP,0,5,10,6,0x1f,NOENM)
#define LIST_PKT_ENM_FP11_FLOAT_EXP(_)
// 5e5 FP10 used in DWR

// Packet FP10_FLOAT
#define LIST_PKT_FLD_FP10_FLOAT(_) \
_(FP10_FLOAT,FLOAT) \
_(FP10_FLOAT,MANT) \
_(FP10_FLOAT,EXP)
#define PKT_FP10_FLOAT(_) _(FP10_FLOAT,10,FLD)
#define PKT_FLD_FP10_FLOAT_FLOAT(_) _(FP10_FLOAT,FLOAT,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_FP10_FLOAT_FLOAT(_)
#define PKT_FLD_FP10_FLOAT_MANT(_) _(FP10_FLOAT,MANT,0,5,4,0,0x1f,NOENM)
#define LIST_PKT_ENM_FP10_FLOAT_MANT(_)
#define PKT_FLD_FP10_FLOAT_EXP(_) _(FP10_FLOAT,EXP,0,5,9,5,0x1f,NOENM)
#define LIST_PKT_ENM_FP10_FLOAT_EXP(_)
// 6e4 FP10 used in DWR

// Packet FP10_6E4_FLOAT
#define LIST_PKT_FLD_FP10_6E4_FLOAT(_) \
_(FP10_6E4_FLOAT,FLOAT) \
_(FP10_6E4_FLOAT,MANT) \
_(FP10_6E4_FLOAT,EXP)
#define PKT_FP10_6E4_FLOAT(_) _(FP10_6E4_FLOAT,10,FLD)
#define PKT_FLD_FP10_6E4_FLOAT_FLOAT(_) _(FP10_6E4_FLOAT,FLOAT,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_FP10_6E4_FLOAT_FLOAT(_)
#define PKT_FLD_FP10_6E4_FLOAT_MANT(_) _(FP10_6E4_FLOAT,MANT,0,6,5,0,0x3f,NOENM)
#define LIST_PKT_ENM_FP10_6E4_FLOAT_MANT(_)
#define PKT_FLD_FP10_6E4_FLOAT_EXP(_) _(FP10_6E4_FLOAT,EXP,0,4,9,6,0xf,NOENM)
#define LIST_PKT_ENM_FP10_6E4_FLOAT_EXP(_)
//----------------------
// define for FX10 used in the
// 3d pipe. TD stands for 3d
//-----------------------

// Packet TD_FIX
#define LIST_PKT_FLD_TD_FIX(_) \
_(TD_FIX,FIX) \
_(TD_FIX,FRAC) \
_(TD_FIX,INT) \
_(TD_FIX,SIGN)
#define PKT_TD_FIX(_) _(TD_FIX,10,FLD)
#define PKT_FLD_TD_FIX_FIX(_) _(TD_FIX,FIX,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_TD_FIX_FIX(_)
#define PKT_FLD_TD_FIX_FRAC(_) _(TD_FIX,FRAC,0,8,7,0,0xff,NOENM)
#define LIST_PKT_ENM_TD_FIX_FRAC(_)
#define PKT_FLD_TD_FIX_INT(_) _(TD_FIX,INT,0,1,8,8,0x1,NOENM)
#define LIST_PKT_ENM_TD_FIX_INT(_)
#define PKT_FLD_TD_FIX_SIGN(_) _(TD_FIX,SIGN,0,1,9,9,0x1,NOENM)
#define LIST_PKT_ENM_TD_FIX_SIGN(_)
//----------------------------
//FX10 constants
//----------------------------
#define TD_FIX_ZERO     0
#define TD_FIX_ZERO_SIGN        0
#define TD_FIX_ZERO_INT 0
#define TD_FIX_ZERO_FRAC        0
#define TD_FIX_ONE      256
#define TD_FIX_ONE_SIGN 0
#define TD_FIX_ONE_INT  1
#define TD_FIX_ONE_FRAC 0
#define TD_FIX_MINUS_ONE        768
#define TD_FIX_MINUS_ONE_SIGN   1
#define TD_FIX_MINUS_ONE_INT    1
#define TD_FIX_MINUS_ONE_FRAC   0
//----------------------------
//FP20 constants
//----------------------------
#define TD_FLOAT_ZERO   0
#define TD_FLOAT_ZERO_SIGN      0
#define TD_FLOAT_ZERO_MANT      0
#define TD_FLOAT_ZERO_EXP       0
#define TD_FLOAT_ONE    253952
#define TD_FLOAT_ONE_SIGN       0
#define TD_FLOAT_ONE_MANT       0
#define TD_FLOAT_ONE_EXP        31
#define TD_FLOAT_MINUS_ONE      778240
#define TD_FLOAT_MINUS_ONE_SIGN 1
#define TD_FLOAT_MINUS_ONE_MANT 0
#define TD_FLOAT_MINUS_ONE_EXP  31
#define TD_FLOAT_MINUS_MAX      1048575
#define TD_FLOAT_MINUS_MAX_SIGN 1
#define TD_FLOAT_MINUS_MAX_MANT 8191
#define TD_FLOAT_MINUS_MAX_EXP  63
#define TD_FLOAT_PLUS_MAX       524287
#define TD_FLOAT_PLUS_MAX_SIGN  0
#define TD_FLOAT_PLUS_MAX_MANT  8191
#define TD_FLOAT_PLUS_MAX_EXP   63
//----------------------------
//IEEE float constants
//----------------------------
#define IEEE_FLOAT_PLUS_ZERO    0
#define IEEE_FLOAT_PLUS_ZERO_SIGN       0
#define IEEE_FLOAT_PLUS_ZERO_MANT       0
#define IEEE_FLOAT_PLUS_ZERO_EXP        0
#define IEEE_FLOAT_MINUS_ZERO   -2147483648
#define IEEE_FLOAT_MINUS_ZERO_SIGN      1
#define IEEE_FLOAT_MINUS_ZERO_MANT      0
#define IEEE_FLOAT_MINUS_ZERO_EXP       0
#define IEEE_FLOAT_PLUS_INF     2139095040
#define IEEE_FLOAT_PLUS_INF_SIGN        0
#define IEEE_FLOAT_PLUS_INF_MANT        0
#define IEEE_FLOAT_PLUS_INF_EXP 255
#define IEEE_FLOAT_MINUS_INF    -8388608
#define IEEE_FLOAT_MINUS_INF_SIGN       1
#define IEEE_FLOAT_MINUS_INF_MANT       0
#define IEEE_FLOAT_MINUS_INF_EXP        255
#define IEEE_FLOAT_ONE  1065353216
#define IEEE_FLOAT_ONE_SIGN     0
#define IEEE_FLOAT_ONE_MANT     0
#define IEEE_FLOAT_ONE_EXP      127
#define IEEE_FLOAT_MINUS_ONE    -1082130432
#define IEEE_FLOAT_MINUS_ONE_SIGN       1
#define IEEE_FLOAT_MINUS_ONE_MANT       0
#define IEEE_FLOAT_MINUS_ONE_EXP        127
//----------------------------
//FP22 constants
//----------------------------
#define FP22_FLOAT_ZERO 0
#define FP22_FLOAT_ZERO_SIGN    0
#define FP22_FLOAT_ZERO_MANT    0
#define FP22_FLOAT_ZERO_EXP     0
#define FP22_FLOAT_ONE  1015808
#define FP22_FLOAT_ONE_SIGN     0
#define FP22_FLOAT_ONE_MANT     0
#define FP22_FLOAT_ONE_EXP      31
#define FP22_FLOAT_MINUS_ONE    3112960
#define FP22_FLOAT_MINUS_ONE_SIGN       1
#define FP22_FLOAT_MINUS_ONE_MANT       0
#define FP22_FLOAT_MINUS_ONE_EXP        31
#define FP22_FLOAT_MINUS_MAX    4194303
#define FP22_FLOAT_MINUS_MAX_SIGN       1
#define FP22_FLOAT_MINUS_MAX_MANT       16383
#define FP22_FLOAT_MINUS_MAX_EXP        63
#define FP22_FLOAT_PLUS_MAX     2097151
#define FP22_FLOAT_PLUS_MAX_SIGN        0
#define FP22_FLOAT_PLUS_MAX_MANT        16383
#define FP22_FLOAT_PLUS_MAX_EXP 63
//
// SC25 clip/setup
//

// Packet CLIP2SETUP_COV
#define LIST_PKT_FLD_CLIP2SETUP_COV(_) \
_(CLIP2SETUP_COV,TAG) \
_(CLIP2SETUP_COV,DATA)
#define PKT_CLIP2SETUP_COV(_) _(CLIP2SETUP_COV,112,FLD)
#define PKT_FLD_CLIP2SETUP_COV_TAG(_) _(CLIP2SETUP_COV,TAG,0,3,2,0,0x7,ENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_TAG(_) \
_(CLIP2SETUP_COV,TAG,REG,0) \
_(CLIP2SETUP_COV,TAG,PRIM,1) \
_(CLIP2SETUP_COV,TAG,XY,2) \
_(CLIP2SETUP_COV,TAG,RHW,3)
#define PKT_FLD_CLIP2SETUP_COV_DATA(_) _(CLIP2SETUP_COV,DATA,0,109,111,3,0x1fff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_DATA(_)

// Packet CLIP2SETUP_COV_REG
#define LIST_PKT_FLD_CLIP2SETUP_COV_REG(_) \
_(CLIP2SETUP_COV_REG,TAG) \
_(CLIP2SETUP_COV_REG,READ) \
_(CLIP2SETUP_COV_REG,ADDR) \
_(CLIP2SETUP_COV_REG,DATA) \
_(CLIP2SETUP_COV_REG,CHANNEL)
#define PKT_CLIP2SETUP_COV_REG(_) _(CLIP2SETUP_COV_REG,56,FLD)
#define PKT_FLD_CLIP2SETUP_COV_REG_TAG(_) _(CLIP2SETUP_COV_REG,TAG,0,3,2,0,0x7,ENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_REG_TAG(_) \
_(CLIP2SETUP_COV_REG,TAG,REG,0) \
_(CLIP2SETUP_COV_REG,TAG,PRIM,1) \
_(CLIP2SETUP_COV_REG,TAG,XY,2) \
_(CLIP2SETUP_COV_REG,TAG,RHW,3)
#define PKT_FLD_CLIP2SETUP_COV_REG_READ(_) _(CLIP2SETUP_COV_REG,READ,0,1,4,4,0x1,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_REG_READ(_)
#define PKT_FLD_CLIP2SETUP_COV_REG_ADDR(_) _(CLIP2SETUP_COV_REG,ADDR,0,12,19,8,0xfff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_REG_ADDR(_)
#define PKT_FLD_CLIP2SETUP_COV_REG_DATA(_) _(CLIP2SETUP_COV_REG,DATA,0,32,51,20,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_REG_DATA(_)
#define PKT_FLD_CLIP2SETUP_COV_REG_CHANNEL(_) _(CLIP2SETUP_COV_REG,CHANNEL,0,4,55,52,0xf,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_REG_CHANNEL(_)

// Packet CLIP2SETUP_COV_PRIM
#define LIST_PKT_FLD_CLIP2SETUP_COV_PRIM(_) \
_(CLIP2SETUP_COV_PRIM,TAG) \
_(CLIP2SETUP_COV_PRIM,PRIM_TYPE) \
_(CLIP2SETUP_COV_PRIM,TID) \
_(CLIP2SETUP_COV_PRIM,AREA) \
_(CLIP2SETUP_COV_PRIM,X3) \
_(CLIP2SETUP_COV_PRIM,Y3)
#define PKT_CLIP2SETUP_COV_PRIM(_) _(CLIP2SETUP_COV_PRIM,106,FLD)
#define PKT_FLD_CLIP2SETUP_COV_PRIM_TAG(_) _(CLIP2SETUP_COV_PRIM,TAG,0,3,2,0,0x7,ENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_PRIM_TAG(_) \
_(CLIP2SETUP_COV_PRIM,TAG,REG,0) \
_(CLIP2SETUP_COV_PRIM,TAG,PRIM,1) \
_(CLIP2SETUP_COV_PRIM,TAG,XY,2) \
_(CLIP2SETUP_COV_PRIM,TAG,RHW,3)
#define PKT_FLD_CLIP2SETUP_COV_PRIM_PRIM_TYPE(_) _(CLIP2SETUP_COV_PRIM,PRIM_TYPE,0,2,4,3,0x3,ENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_PRIM_PRIM_TYPE(_) \
_(CLIP2SETUP_COV_PRIM,PRIM_TYPE,POINT,1) \
_(CLIP2SETUP_COV_PRIM,PRIM_TYPE,LINE,2) \
_(CLIP2SETUP_COV_PRIM,PRIM_TYPE,TRI,3)
// triangle id
#define PKT_FLD_CLIP2SETUP_COV_PRIM_TID(_) _(CLIP2SETUP_COV_PRIM,TID,0,6,10,5,0x3f,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_PRIM_TID(_)
// S27.8
#define PKT_FLD_CLIP2SETUP_COV_PRIM_AREA(_) _(CLIP2SETUP_COV_PRIM,AREA,0,36,69,34,0xf,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_PRIM_AREA(_)
// S13.4
#define PKT_FLD_CLIP2SETUP_COV_PRIM_X3(_) _(CLIP2SETUP_COV_PRIM,X3,0,18,87,70,0x3ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_PRIM_X3(_)
// S13.4
#define PKT_FLD_CLIP2SETUP_COV_PRIM_Y3(_) _(CLIP2SETUP_COV_PRIM,Y3,0,18,105,88,0x3ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_PRIM_Y3(_)

// Packet CLIP2SETUP_COV_XY
#define LIST_PKT_FLD_CLIP2SETUP_COV_XY(_) \
_(CLIP2SETUP_COV_XY,TAG) \
_(CLIP2SETUP_COV_XY,FACE) \
_(CLIP2SETUP_COV_XY,X0) \
_(CLIP2SETUP_COV_XY,Y0) \
_(CLIP2SETUP_COV_XY,X1) \
_(CLIP2SETUP_COV_XY,Y1) \
_(CLIP2SETUP_COV_XY,X2) \
_(CLIP2SETUP_COV_XY,Y2)
#define PKT_CLIP2SETUP_COV_XY(_) _(CLIP2SETUP_COV_XY,112,FLD)
#define PKT_FLD_CLIP2SETUP_COV_XY_TAG(_) _(CLIP2SETUP_COV_XY,TAG,0,3,2,0,0x7,ENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_XY_TAG(_) \
_(CLIP2SETUP_COV_XY,TAG,REG,0) \
_(CLIP2SETUP_COV_XY,TAG,PRIM,1) \
_(CLIP2SETUP_COV_XY,TAG,XY,2) \
_(CLIP2SETUP_COV_XY,TAG,RHW,3)
#define PKT_FLD_CLIP2SETUP_COV_XY_FACE(_) _(CLIP2SETUP_COV_XY,FACE,0,1,3,3,0x1,ENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_XY_FACE(_) \
_(CLIP2SETUP_COV_XY,FACE,FRONT,0) \
_(CLIP2SETUP_COV_XY,FACE,BACK,1)
// S13.4
#define PKT_FLD_CLIP2SETUP_COV_XY_X0(_) _(CLIP2SETUP_COV_XY,X0,0,18,21,4,0x3ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_XY_X0(_)
// S13.4
#define PKT_FLD_CLIP2SETUP_COV_XY_Y0(_) _(CLIP2SETUP_COV_XY,Y0,0,18,39,22,0x3ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_XY_Y0(_)
// S13.4
#define PKT_FLD_CLIP2SETUP_COV_XY_X1(_) _(CLIP2SETUP_COV_XY,X1,0,18,57,40,0x3ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_XY_X1(_)
// S13.4
#define PKT_FLD_CLIP2SETUP_COV_XY_Y1(_) _(CLIP2SETUP_COV_XY,Y1,0,18,75,58,0x3ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_XY_Y1(_)
// S13.4
#define PKT_FLD_CLIP2SETUP_COV_XY_X2(_) _(CLIP2SETUP_COV_XY,X2,0,18,93,76,0x3ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_XY_X2(_)
// S13.4
#define PKT_FLD_CLIP2SETUP_COV_XY_Y2(_) _(CLIP2SETUP_COV_XY,Y2,0,18,111,94,0x3ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_XY_Y2(_)

// Packet CLIP2SETUP_COV_RHW
#define LIST_PKT_FLD_CLIP2SETUP_COV_RHW(_) \
_(CLIP2SETUP_COV_RHW,TAG) \
_(CLIP2SETUP_COV_RHW,RHW0) \
_(CLIP2SETUP_COV_RHW,RHW1) \
_(CLIP2SETUP_COV_RHW,RHW2)
#define PKT_CLIP2SETUP_COV_RHW(_) _(CLIP2SETUP_COV_RHW,100,FLD)
#define PKT_FLD_CLIP2SETUP_COV_RHW_TAG(_) _(CLIP2SETUP_COV_RHW,TAG,0,3,2,0,0x7,ENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_RHW_TAG(_) \
_(CLIP2SETUP_COV_RHW,TAG,REG,0) \
_(CLIP2SETUP_COV_RHW,TAG,PRIM,1) \
_(CLIP2SETUP_COV_RHW,TAG,XY,2) \
_(CLIP2SETUP_COV_RHW,TAG,RHW,3)
#define PKT_FLD_CLIP2SETUP_COV_RHW_RHW0(_) _(CLIP2SETUP_COV_RHW,RHW0,0,32,35,4,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_RHW_RHW0(_)
#define PKT_FLD_CLIP2SETUP_COV_RHW_RHW1(_) _(CLIP2SETUP_COV_RHW,RHW1,0,32,67,36,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_RHW_RHW1(_)
#define PKT_FLD_CLIP2SETUP_COV_RHW_RHW2(_) _(CLIP2SETUP_COV_RHW,RHW2,0,32,99,68,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_COV_RHW_RHW2(_)

// Packet CLIP2SETUP_Z
#define LIST_PKT_FLD_CLIP2SETUP_Z(_) \
_(CLIP2SETUP_Z,Z0) \
_(CLIP2SETUP_Z,DZDX) \
_(CLIP2SETUP_Z,DZDY) \
_(CLIP2SETUP_Z,EXP) \
_(CLIP2SETUP_Z,TID)
#define PKT_CLIP2SETUP_Z(_) _(CLIP2SETUP_Z,73,FLD)
#define PKT_FLD_CLIP2SETUP_Z_Z0(_) _(CLIP2SETUP_Z,Z0,0,24,23,0,0xffffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_Z_Z0(_)
#define PKT_FLD_CLIP2SETUP_Z_DZDX(_) _(CLIP2SETUP_Z,DZDX,0,19,42,24,0x7ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_Z_DZDX(_)
#define PKT_FLD_CLIP2SETUP_Z_DZDY(_) _(CLIP2SETUP_Z,DZDY,0,19,61,43,0x7ffff,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_Z_DZDY(_)
// exponent, commmon to both DZDX and DZDY
#define PKT_FLD_CLIP2SETUP_Z_EXP(_) _(CLIP2SETUP_Z,EXP,0,5,66,62,0x1f,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_Z_EXP(_)
// triangle id
#define PKT_FLD_CLIP2SETUP_Z_TID(_) _(CLIP2SETUP_Z,TID,0,6,72,67,0x3f,NOENM)
#define LIST_PKT_ENM_CLIP2SETUP_Z_TID(_)

// Packet CLIP2ATRAST_TRAM
#define LIST_PKT_FLD_CLIP2ATRAST_TRAM(_) \
_(CLIP2ATRAST_TRAM,C0) \
_(CLIP2ATRAST_TRAM,C0_LO) \
_(CLIP2ATRAST_TRAM,C0_HI) \
_(CLIP2ATRAST_TRAM,C1) \
_(CLIP2ATRAST_TRAM,C1_LO) \
_(CLIP2ATRAST_TRAM,C1_HI) \
_(CLIP2ATRAST_TRAM,C2) \
_(CLIP2ATRAST_TRAM,C2_LO) \
_(CLIP2ATRAST_TRAM,C2_HI) \
_(CLIP2ATRAST_TRAM,C3) \
_(CLIP2ATRAST_TRAM,C3_LO) \
_(CLIP2ATRAST_TRAM,C3_HI) \
_(CLIP2ATRAST_TRAM,TRAM_ROW) \
_(CLIP2ATRAST_TRAM,WE)
#define PKT_CLIP2ATRAST_TRAM(_) _(CLIP2ATRAST_TRAM,270,FLD)
#define PKT_FLD_CLIP2ATRAST_TRAM_C0(_) _(CLIP2ATRAST_TRAM,C0,0,64,63,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C0(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C0_LO(_) _(CLIP2ATRAST_TRAM,C0_LO,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C0_LO(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C0_HI(_) _(CLIP2ATRAST_TRAM,C0_HI,0,32,63,32,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C0_HI(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C1(_) _(CLIP2ATRAST_TRAM,C1,0,64,127,64,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C1(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C1_LO(_) _(CLIP2ATRAST_TRAM,C1_LO,0,32,95,64,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C1_LO(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C1_HI(_) _(CLIP2ATRAST_TRAM,C1_HI,0,32,127,96,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C1_HI(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C2(_) _(CLIP2ATRAST_TRAM,C2,0,64,191,128,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C2(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C2_LO(_) _(CLIP2ATRAST_TRAM,C2_LO,0,32,159,128,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C2_LO(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C2_HI(_) _(CLIP2ATRAST_TRAM,C2_HI,0,32,191,160,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C2_HI(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C3(_) _(CLIP2ATRAST_TRAM,C3,0,64,255,192,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C3(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C3_LO(_) _(CLIP2ATRAST_TRAM,C3_LO,0,32,223,192,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C3_LO(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_C3_HI(_) _(CLIP2ATRAST_TRAM,C3_HI,0,32,255,224,0xffffffff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_C3_HI(_)
#define PKT_FLD_CLIP2ATRAST_TRAM_TRAM_ROW(_) _(CLIP2ATRAST_TRAM,TRAM_ROW,0,6,261,256,0x3f,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_TRAM_ROW(_)
// half-column write enables
#define PKT_FLD_CLIP2ATRAST_TRAM_WE(_) _(CLIP2ATRAST_TRAM,WE,0,8,269,262,0xff,NOENM)
#define LIST_PKT_ENM_CLIP2ATRAST_TRAM_WE(_)
//
// TRAM_BF_HP and LP describe one high- or low-precision block-float column (C0/...) of CLIP2SETUP_ATTR
//

// Packet TRAM_BF_HP
#define LIST_PKT_FLD_TRAM_BF_HP(_) \
_(TRAM_BF_HP,DP0_MANT) \
_(TRAM_BF_HP,DP1_MANT) \
_(TRAM_BF_HP,P2_MANT) \
_(TRAM_BF_HP,EXP)
#define PKT_TRAM_BF_HP(_) _(TRAM_BF_HP,63,FLD)
// S1.17
#define PKT_FLD_TRAM_BF_HP_DP0_MANT(_) _(TRAM_BF_HP,DP0_MANT,0,19,18,0,0x7ffff,NOENM)
#define LIST_PKT_ENM_TRAM_BF_HP_DP0_MANT(_)
// S1.17
#define PKT_FLD_TRAM_BF_HP_DP1_MANT(_) _(TRAM_BF_HP,DP1_MANT,0,19,37,19,0x7ffff,NOENM)
#define LIST_PKT_ENM_TRAM_BF_HP_DP1_MANT(_)
// S1.17
#define PKT_FLD_TRAM_BF_HP_P2_MANT(_) _(TRAM_BF_HP,P2_MANT,0,19,56,38,0x7ffff,NOENM)
#define LIST_PKT_ENM_TRAM_BF_HP_P2_MANT(_)
// 6
#define PKT_FLD_TRAM_BF_HP_EXP(_) _(TRAM_BF_HP,EXP,0,6,62,57,0x3f,NOENM)
#define LIST_PKT_ENM_TRAM_BF_HP_EXP(_)

// Packet TRAM_BF_LP
#define LIST_PKT_FLD_TRAM_BF_LP(_) \
_(TRAM_BF_LP,DP0_MANT) \
_(TRAM_BF_LP,DP1_MANT) \
_(TRAM_BF_LP,P2_MANT) \
_(TRAM_BF_LP,EXP)
#define PKT_TRAM_BF_LP(_) _(TRAM_BF_LP,32,FLD)
// S1.8
#define PKT_FLD_TRAM_BF_LP_DP0_MANT(_) _(TRAM_BF_LP,DP0_MANT,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_TRAM_BF_LP_DP0_MANT(_)
// S1.8
#define PKT_FLD_TRAM_BF_LP_DP1_MANT(_) _(TRAM_BF_LP,DP1_MANT,0,10,19,10,0x3ff,NOENM)
#define LIST_PKT_ENM_TRAM_BF_LP_DP1_MANT(_)
// S1.8
#define PKT_FLD_TRAM_BF_LP_P2_MANT(_) _(TRAM_BF_LP,P2_MANT,0,10,29,20,0x3ff,NOENM)
#define LIST_PKT_ENM_TRAM_BF_LP_P2_MANT(_)
// 2
#define PKT_FLD_TRAM_BF_LP_EXP(_) _(TRAM_BF_LP,EXP,0,2,31,30,0x3,NOENM)
#define LIST_PKT_ENM_TRAM_BF_LP_EXP(_)
// this is for setup->atrast z-plane parameters

// Packet TRAM_BF_ZP64
#define LIST_PKT_FLD_TRAM_BF_ZP64(_) \
_(TRAM_BF_ZP64,DZDX_MANT) \
_(TRAM_BF_ZP64,DZDY_MANT) \
_(TRAM_BF_ZP64,Z0) \
_(TRAM_BF_ZP64,EXP)
#define PKT_TRAM_BF_ZP64(_) _(TRAM_BF_ZP64,64,FLD)
// S1.17
#define PKT_FLD_TRAM_BF_ZP64_DZDX_MANT(_) _(TRAM_BF_ZP64,DZDX_MANT,0,19,18,0,0x7ffff,NOENM)
#define LIST_PKT_ENM_TRAM_BF_ZP64_DZDX_MANT(_)
// S1.17
#define PKT_FLD_TRAM_BF_ZP64_DZDY_MANT(_) _(TRAM_BF_ZP64,DZDY_MANT,0,19,37,19,0x7ffff,NOENM)
#define LIST_PKT_ENM_TRAM_BF_ZP64_DZDY_MANT(_)
// .20.1
#define PKT_FLD_TRAM_BF_ZP64_Z0(_) _(TRAM_BF_ZP64,Z0,0,21,58,38,0x1fffff,NOENM)
#define LIST_PKT_ENM_TRAM_BF_ZP64_Z0(_)
// 5 - common to DZDX and DZDY
#define PKT_FLD_TRAM_BF_ZP64_EXP(_) _(TRAM_BF_ZP64,EXP,0,5,63,59,0x1f,NOENM)
#define LIST_PKT_ENM_TRAM_BF_ZP64_EXP(_)

// Packet SETUP2QRAST_QR
#define LIST_PKT_FLD_SETUP2QRAST_QR(_) \
_(SETUP2QRAST_QR,Q) \
_(SETUP2QRAST_QR,Q_MANT) \
_(SETUP2QRAST_QR,Q_SIGN) \
_(SETUP2QRAST_QR,R) \
_(SETUP2QRAST_QR,R_MANT) \
_(SETUP2QRAST_QR,R_SIGN)
#define PKT_SETUP2QRAST_QR(_) _(SETUP2QRAST_QR,40,FLD)
#define PKT_FLD_SETUP2QRAST_QR_Q(_) _(SETUP2QRAST_QR,Q,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_QR_Q(_)
#define PKT_FLD_SETUP2QRAST_QR_Q_MANT(_) _(SETUP2QRAST_QR,Q_MANT,0,17,16,0,0x1ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_QR_Q_MANT(_)
#define PKT_FLD_SETUP2QRAST_QR_Q_SIGN(_) _(SETUP2QRAST_QR,Q_SIGN,0,1,17,17,0x1,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_QR_Q_SIGN(_)
#define PKT_FLD_SETUP2QRAST_QR_R(_) _(SETUP2QRAST_QR,R,0,22,39,18,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_QR_R(_)
#define PKT_FLD_SETUP2QRAST_QR_R_MANT(_) _(SETUP2QRAST_QR,R_MANT,0,22,39,18,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_QR_R_MANT(_)
#define PKT_FLD_SETUP2QRAST_QR_R_SIGN(_) _(SETUP2QRAST_QR,R_SIGN,0,1,39,39,0x1,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_QR_R_SIGN(_)
// Setup to Qrast packets defined below
//

// Packet SETUP2QRAST
#define LIST_PKT_FLD_SETUP2QRAST(_) \
_(SETUP2QRAST,DATA) \
_(SETUP2QRAST,TAG)
#define PKT_SETUP2QRAST(_) _(SETUP2QRAST,110,FLD)
#define PKT_FLD_SETUP2QRAST_DATA(_) _(SETUP2QRAST,DATA,0,106,105,0,0x3ff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DATA(_)
#define PKT_FLD_SETUP2QRAST_TAG(_) _(SETUP2QRAST,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_TAG(_) \
_(SETUP2QRAST,TAG,REG,0) \
_(SETUP2QRAST,TAG,Z,1) \
_(SETUP2QRAST,TAG,C,2) \
_(SETUP2QRAST,TAG,DCDX,3) \
_(SETUP2QRAST,TAG,C_DCDX0,4) \
_(SETUP2QRAST,TAG,C_DCDX1,5) \
_(SETUP2QRAST,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST,TAG,XY,8)
// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_REG
#define LIST_PKT_FLD_SETUP2QRAST_REG(_) \
_(SETUP2QRAST_REG,DATA) \
_(SETUP2QRAST_REG,ADDR) \
_(SETUP2QRAST_REG,BLK_NUM) \
_(SETUP2QRAST_REG,BLK_ADDR) \
_(SETUP2QRAST_REG,READ) \
_(SETUP2QRAST_REG,CHANNEL) \
_(SETUP2QRAST_REG,PD) \
_(SETUP2QRAST_REG,TAG)
#define PKT_SETUP2QRAST_REG(_) _(SETUP2QRAST_REG,110,FLD)
#define PKT_FLD_SETUP2QRAST_REG_DATA(_) _(SETUP2QRAST_REG,DATA,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_REG_DATA(_)
#define PKT_FLD_SETUP2QRAST_REG_ADDR(_) _(SETUP2QRAST_REG,ADDR,0,12,43,32,0xfff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_REG_ADDR(_)
#define PKT_FLD_SETUP2QRAST_REG_BLK_NUM(_) _(SETUP2QRAST_REG,BLK_NUM,0,4,43,40,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_REG_BLK_NUM(_) \
_(SETUP2QRAST_REG,BLK_NUM,CTL,0) \
_(SETUP2QRAST_REG,BLK_NUM,IDX,1) \
_(SETUP2QRAST_REG,BLK_NUM,VPE,2) \
_(SETUP2QRAST_REG,BLK_NUM,SU,3) \
_(SETUP2QRAST_REG,BLK_NUM,QR,4) \
_(SETUP2QRAST_REG,BLK_NUM,PSEQ,5) \
_(SETUP2QRAST_REG,BLK_NUM,AT,6) \
_(SETUP2QRAST_REG,BLK_NUM,TEX,7) \
_(SETUP2QRAST_REG,BLK_NUM,ALU,8) \
_(SETUP2QRAST_REG,BLK_NUM,DW,9) \
_(SETUP2QRAST_REG,BLK_NUM,FDC,10) \
_(SETUP2QRAST_REG,BLK_NUM,GLB1,14) \
_(SETUP2QRAST_REG,BLK_NUM,GLB2,15)
#define PKT_FLD_SETUP2QRAST_REG_BLK_ADDR(_) _(SETUP2QRAST_REG,BLK_ADDR,0,8,39,32,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_REG_BLK_ADDR(_)
#define PKT_FLD_SETUP2QRAST_REG_READ(_) _(SETUP2QRAST_REG,READ,0,1,44,44,0x1,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_REG_READ(_)
#define PKT_FLD_SETUP2QRAST_REG_CHANNEL(_) _(SETUP2QRAST_REG,CHANNEL,0,4,48,45,0xf,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_REG_CHANNEL(_)
#define PKT_FLD_SETUP2QRAST_REG_PD(_) _(SETUP2QRAST_REG,PD,0,49,48,0,0x1ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_REG_PD(_)
#define PKT_FLD_SETUP2QRAST_REG_TAG(_) _(SETUP2QRAST_REG,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_REG_TAG(_) \
_(SETUP2QRAST_REG,TAG,REG,0) \
_(SETUP2QRAST_REG,TAG,Z,1) \
_(SETUP2QRAST_REG,TAG,C,2) \
_(SETUP2QRAST_REG,TAG,DCDX,3) \
_(SETUP2QRAST_REG,TAG,C_DCDX0,4) \
_(SETUP2QRAST_REG,TAG,C_DCDX1,5) \
_(SETUP2QRAST_REG,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST_REG,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST_REG,TAG,XY,8)
// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_Z
#define LIST_PKT_FLD_SETUP2QRAST_Z(_) \
_(SETUP2QRAST_Z,Z0) \
_(SETUP2QRAST_Z,DZDX) \
_(SETUP2QRAST_Z,DZDY) \
_(SETUP2QRAST_Z,EXP) \
_(SETUP2QRAST_Z,TID) \
_(SETUP2QRAST_Z,PD) \
_(SETUP2QRAST_Z,TAG)
#define PKT_SETUP2QRAST_Z(_) _(SETUP2QRAST_Z,110,FLD)
#define PKT_FLD_SETUP2QRAST_Z_Z0(_) _(SETUP2QRAST_Z,Z0,0,24,23,0,0xffffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_Z_Z0(_)
#define PKT_FLD_SETUP2QRAST_Z_DZDX(_) _(SETUP2QRAST_Z,DZDX,0,19,42,24,0x7ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_Z_DZDX(_)
#define PKT_FLD_SETUP2QRAST_Z_DZDY(_) _(SETUP2QRAST_Z,DZDY,0,19,61,43,0x7ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_Z_DZDY(_)
// exponent, commmon to both DZDX and DZDY
#define PKT_FLD_SETUP2QRAST_Z_EXP(_) _(SETUP2QRAST_Z,EXP,0,5,66,62,0x1f,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_Z_EXP(_)
// triangle id
#define PKT_FLD_SETUP2QRAST_Z_TID(_) _(SETUP2QRAST_Z,TID,0,6,72,67,0x3f,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_Z_TID(_)
#define PKT_FLD_SETUP2QRAST_Z_PD(_) _(SETUP2QRAST_Z,PD,0,73,72,0,0x1ff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_Z_PD(_)
#define PKT_FLD_SETUP2QRAST_Z_TAG(_) _(SETUP2QRAST_Z,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_Z_TAG(_) \
_(SETUP2QRAST_Z,TAG,REG,0) \
_(SETUP2QRAST_Z,TAG,Z,1) \
_(SETUP2QRAST_Z,TAG,C,2) \
_(SETUP2QRAST_Z,TAG,DCDX,3) \
_(SETUP2QRAST_Z,TAG,C_DCDX0,4) \
_(SETUP2QRAST_Z,TAG,C_DCDX1,5) \
_(SETUP2QRAST_Z,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST_Z,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST_Z,TAG,XY,8)
// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_C
#define LIST_PKT_FLD_SETUP2QRAST_C(_) \
_(SETUP2QRAST_C,A) \
_(SETUP2QRAST_C,B) \
_(SETUP2QRAST_C,UPPER_IN_EDGE) \
_(SETUP2QRAST_C,UPPER_OUT_EDGE) \
_(SETUP2QRAST_C,LOWER_IN_EDGE) \
_(SETUP2QRAST_C,LOWER_OUT_EDGE) \
_(SETUP2QRAST_C,FACE) \
_(SETUP2QRAST_C,PD) \
_(SETUP2QRAST_C,TAG)
#define PKT_SETUP2QRAST_C(_) _(SETUP2QRAST_C,110,FLD)
#define PKT_FLD_SETUP2QRAST_C_A(_) _(SETUP2QRAST_C,A,0,42,41,0,0x3ff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_A(_)
#define PKT_FLD_SETUP2QRAST_C_B(_) _(SETUP2QRAST_C,B,0,42,83,42,0x3ff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_B(_)
#define PKT_FLD_SETUP2QRAST_C_UPPER_IN_EDGE(_) _(SETUP2QRAST_C,UPPER_IN_EDGE,0,2,85,84,0x3,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_UPPER_IN_EDGE(_)
#define PKT_FLD_SETUP2QRAST_C_UPPER_OUT_EDGE(_) _(SETUP2QRAST_C,UPPER_OUT_EDGE,0,2,87,86,0x3,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_UPPER_OUT_EDGE(_)
#define PKT_FLD_SETUP2QRAST_C_LOWER_IN_EDGE(_) _(SETUP2QRAST_C,LOWER_IN_EDGE,0,2,89,88,0x3,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_LOWER_IN_EDGE(_)
#define PKT_FLD_SETUP2QRAST_C_LOWER_OUT_EDGE(_) _(SETUP2QRAST_C,LOWER_OUT_EDGE,0,2,91,90,0x3,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_LOWER_OUT_EDGE(_)
#define PKT_FLD_SETUP2QRAST_C_FACE(_) _(SETUP2QRAST_C,FACE,0,1,92,92,0x1,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_FACE(_) \
_(SETUP2QRAST_C,FACE,FRONT,0) \
_(SETUP2QRAST_C,FACE,BACK,1)
#define PKT_FLD_SETUP2QRAST_C_PD(_) _(SETUP2QRAST_C,PD,0,93,92,0,0x1fffffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_PD(_)
#define PKT_FLD_SETUP2QRAST_C_TAG(_) _(SETUP2QRAST_C,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_TAG(_) \
_(SETUP2QRAST_C,TAG,REG,0) \
_(SETUP2QRAST_C,TAG,Z,1) \
_(SETUP2QRAST_C,TAG,C,2) \
_(SETUP2QRAST_C,TAG,DCDX,3) \
_(SETUP2QRAST_C,TAG,C_DCDX0,4) \
_(SETUP2QRAST_C,TAG,C_DCDX1,5) \
_(SETUP2QRAST_C,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST_C,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST_C,TAG,XY,8)
// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_DCDX
#define LIST_PKT_FLD_SETUP2QRAST_DCDX(_) \
_(SETUP2QRAST_DCDX,DADX) \
_(SETUP2QRAST_DCDX,DBDX) \
_(SETUP2QRAST_DCDX,DGDX) \
_(SETUP2QRAST_DCDX,DGPDX) \
_(SETUP2QRAST_DCDX,PD) \
_(SETUP2QRAST_DCDX,TAG)
#define PKT_SETUP2QRAST_DCDX(_) _(SETUP2QRAST_DCDX,110,FLD)
#define PKT_FLD_SETUP2QRAST_DCDX_DADX(_) _(SETUP2QRAST_DCDX,DADX,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDX_DADX(_)
#define PKT_FLD_SETUP2QRAST_DCDX_DBDX(_) _(SETUP2QRAST_DCDX,DBDX,0,18,35,18,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDX_DBDX(_)
#define PKT_FLD_SETUP2QRAST_DCDX_DGDX(_) _(SETUP2QRAST_DCDX,DGDX,0,18,53,36,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDX_DGDX(_)
#define PKT_FLD_SETUP2QRAST_DCDX_DGPDX(_) _(SETUP2QRAST_DCDX,DGPDX,0,18,71,54,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDX_DGPDX(_)
#define PKT_FLD_SETUP2QRAST_DCDX_PD(_) _(SETUP2QRAST_DCDX,PD,0,72,71,0,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDX_PD(_)
#define PKT_FLD_SETUP2QRAST_DCDX_TAG(_) _(SETUP2QRAST_DCDX,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDX_TAG(_) \
_(SETUP2QRAST_DCDX,TAG,REG,0) \
_(SETUP2QRAST_DCDX,TAG,Z,1) \
_(SETUP2QRAST_DCDX,TAG,C,2) \
_(SETUP2QRAST_DCDX,TAG,DCDX,3) \
_(SETUP2QRAST_DCDX,TAG,C_DCDX0,4) \
_(SETUP2QRAST_DCDX,TAG,C_DCDX1,5) \
_(SETUP2QRAST_DCDX,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST_DCDX,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST_DCDX,TAG,XY,8)
// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also
// Note that the R field needs an extra 4 bits because the dcdx we are dividing by
// is padded by 4 bits (so that it is aligned to C).

// Packet SETUP2QRAST_C_DCDX0
#define LIST_PKT_FLD_SETUP2QRAST_C_DCDX0(_) \
_(SETUP2QRAST_C_DCDX0,A_DADX) \
_(SETUP2QRAST_C_DCDX0,A_DADX_Q) \
_(SETUP2QRAST_C_DCDX0,A_DADX_R) \
_(SETUP2QRAST_C_DCDX0,B_DBDX) \
_(SETUP2QRAST_C_DCDX0,B_DBDX_Q) \
_(SETUP2QRAST_C_DCDX0,B_DBDX_R) \
_(SETUP2QRAST_C_DCDX0,PD) \
_(SETUP2QRAST_C_DCDX0,TAG)
#define PKT_SETUP2QRAST_C_DCDX0(_) _(SETUP2QRAST_C_DCDX0,110,FLD)
#define PKT_FLD_SETUP2QRAST_C_DCDX0_A_DADX(_) _(SETUP2QRAST_C_DCDX0,A_DADX,0,40,39,0,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX0_A_DADX(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX0_A_DADX_Q(_) _(SETUP2QRAST_C_DCDX0,A_DADX_Q,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX0_A_DADX_Q(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX0_A_DADX_R(_) _(SETUP2QRAST_C_DCDX0,A_DADX_R,0,22,39,18,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX0_A_DADX_R(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX0_B_DBDX(_) _(SETUP2QRAST_C_DCDX0,B_DBDX,0,40,79,40,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX0_B_DBDX(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX0_B_DBDX_Q(_) _(SETUP2QRAST_C_DCDX0,B_DBDX_Q,0,18,57,40,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX0_B_DBDX_Q(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX0_B_DBDX_R(_) _(SETUP2QRAST_C_DCDX0,B_DBDX_R,0,22,79,58,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX0_B_DBDX_R(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX0_PD(_) _(SETUP2QRAST_C_DCDX0,PD,0,80,79,0,0xffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX0_PD(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX0_TAG(_) _(SETUP2QRAST_C_DCDX0,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX0_TAG(_) \
_(SETUP2QRAST_C_DCDX0,TAG,REG,0) \
_(SETUP2QRAST_C_DCDX0,TAG,Z,1) \
_(SETUP2QRAST_C_DCDX0,TAG,C,2) \
_(SETUP2QRAST_C_DCDX0,TAG,DCDX,3) \
_(SETUP2QRAST_C_DCDX0,TAG,C_DCDX0,4) \
_(SETUP2QRAST_C_DCDX0,TAG,C_DCDX1,5) \
_(SETUP2QRAST_C_DCDX0,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST_C_DCDX0,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST_C_DCDX0,TAG,XY,8)
// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also
// Note that the R field needs an extra 4 bits because the dcdx we are dividing by
// is padded by 4 bits (so that it is aligned to C).

// Packet SETUP2QRAST_C_DCDX1
#define LIST_PKT_FLD_SETUP2QRAST_C_DCDX1(_) \
_(SETUP2QRAST_C_DCDX1,G_DGDX) \
_(SETUP2QRAST_C_DCDX1,G_DGDX_Q) \
_(SETUP2QRAST_C_DCDX1,G_DGDX_R) \
_(SETUP2QRAST_C_DCDX1,G_P_DGPDX) \
_(SETUP2QRAST_C_DCDX1,G_P_DGPDX_Q) \
_(SETUP2QRAST_C_DCDX1,G_P_DGPDX_R) \
_(SETUP2QRAST_C_DCDX1,PD) \
_(SETUP2QRAST_C_DCDX1,TAG)
#define PKT_SETUP2QRAST_C_DCDX1(_) _(SETUP2QRAST_C_DCDX1,110,FLD)
#define PKT_FLD_SETUP2QRAST_C_DCDX1_G_DGDX(_) _(SETUP2QRAST_C_DCDX1,G_DGDX,0,40,39,0,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX1_G_DGDX(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX1_G_DGDX_Q(_) _(SETUP2QRAST_C_DCDX1,G_DGDX_Q,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX1_G_DGDX_Q(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX1_G_DGDX_R(_) _(SETUP2QRAST_C_DCDX1,G_DGDX_R,0,22,39,18,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX1_G_DGDX_R(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX1_G_P_DGPDX(_) _(SETUP2QRAST_C_DCDX1,G_P_DGPDX,0,40,79,40,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX1_G_P_DGPDX(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX1_G_P_DGPDX_Q(_) _(SETUP2QRAST_C_DCDX1,G_P_DGPDX_Q,0,18,57,40,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX1_G_P_DGPDX_Q(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX1_G_P_DGPDX_R(_) _(SETUP2QRAST_C_DCDX1,G_P_DGPDX_R,0,22,79,58,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX1_G_P_DGPDX_R(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX1_PD(_) _(SETUP2QRAST_C_DCDX1,PD,0,80,79,0,0xffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX1_PD(_)
#define PKT_FLD_SETUP2QRAST_C_DCDX1_TAG(_) _(SETUP2QRAST_C_DCDX1,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_C_DCDX1_TAG(_) \
_(SETUP2QRAST_C_DCDX1,TAG,REG,0) \
_(SETUP2QRAST_C_DCDX1,TAG,Z,1) \
_(SETUP2QRAST_C_DCDX1,TAG,C,2) \
_(SETUP2QRAST_C_DCDX1,TAG,DCDX,3) \
_(SETUP2QRAST_C_DCDX1,TAG,C_DCDX0,4) \
_(SETUP2QRAST_C_DCDX1,TAG,C_DCDX1,5) \
_(SETUP2QRAST_C_DCDX1,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST_C_DCDX1,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST_C_DCDX1,TAG,XY,8)
// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_DCDY_DCDX0
#define LIST_PKT_FLD_SETUP2QRAST_DCDY_DCDX0(_) \
_(SETUP2QRAST_DCDY_DCDX0,DADY_DADX) \
_(SETUP2QRAST_DCDY_DCDX0,DADY_DADX_Q) \
_(SETUP2QRAST_DCDY_DCDX0,DADY_DADX_R) \
_(SETUP2QRAST_DCDY_DCDX0,DBDY_DBDX) \
_(SETUP2QRAST_DCDY_DCDX0,DBDY_DBDX_Q) \
_(SETUP2QRAST_DCDY_DCDX0,DBDY_DBDX_R) \
_(SETUP2QRAST_DCDY_DCDX0,PD) \
_(SETUP2QRAST_DCDY_DCDX0,TAG)
#define PKT_SETUP2QRAST_DCDY_DCDX0(_) _(SETUP2QRAST_DCDY_DCDX0,110,FLD)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX0_DADY_DADX(_) _(SETUP2QRAST_DCDY_DCDX0,DADY_DADX,0,40,39,0,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX0_DADY_DADX(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX0_DADY_DADX_Q(_) _(SETUP2QRAST_DCDY_DCDX0,DADY_DADX_Q,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX0_DADY_DADX_Q(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX0_DADY_DADX_R(_) _(SETUP2QRAST_DCDY_DCDX0,DADY_DADX_R,0,22,39,18,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX0_DADY_DADX_R(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX0_DBDY_DBDX(_) _(SETUP2QRAST_DCDY_DCDX0,DBDY_DBDX,0,40,79,40,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX0_DBDY_DBDX(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX0_DBDY_DBDX_Q(_) _(SETUP2QRAST_DCDY_DCDX0,DBDY_DBDX_Q,0,18,57,40,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX0_DBDY_DBDX_Q(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX0_DBDY_DBDX_R(_) _(SETUP2QRAST_DCDY_DCDX0,DBDY_DBDX_R,0,22,79,58,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX0_DBDY_DBDX_R(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX0_PD(_) _(SETUP2QRAST_DCDY_DCDX0,PD,0,80,79,0,0xffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX0_PD(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX0_TAG(_) _(SETUP2QRAST_DCDY_DCDX0,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX0_TAG(_) \
_(SETUP2QRAST_DCDY_DCDX0,TAG,REG,0) \
_(SETUP2QRAST_DCDY_DCDX0,TAG,Z,1) \
_(SETUP2QRAST_DCDY_DCDX0,TAG,C,2) \
_(SETUP2QRAST_DCDY_DCDX0,TAG,DCDX,3) \
_(SETUP2QRAST_DCDY_DCDX0,TAG,C_DCDX0,4) \
_(SETUP2QRAST_DCDY_DCDX0,TAG,C_DCDX1,5) \
_(SETUP2QRAST_DCDY_DCDX0,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST_DCDY_DCDX0,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST_DCDY_DCDX0,TAG,XY,8)
// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_DCDY_DCDX1
#define LIST_PKT_FLD_SETUP2QRAST_DCDY_DCDX1(_) \
_(SETUP2QRAST_DCDY_DCDX1,DGDY_DGDX) \
_(SETUP2QRAST_DCDY_DCDX1,DGDY_DGDX_Q) \
_(SETUP2QRAST_DCDY_DCDX1,DGDY_DGDX_R) \
_(SETUP2QRAST_DCDY_DCDX1,DGPDY_DGPDX) \
_(SETUP2QRAST_DCDY_DCDX1,DGPDY_DGPDX_Q) \
_(SETUP2QRAST_DCDY_DCDX1,DGPDY_DGPDX_R) \
_(SETUP2QRAST_DCDY_DCDX1,PD) \
_(SETUP2QRAST_DCDY_DCDX1,TAG)
#define PKT_SETUP2QRAST_DCDY_DCDX1(_) _(SETUP2QRAST_DCDY_DCDX1,110,FLD)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX1_DGDY_DGDX(_) _(SETUP2QRAST_DCDY_DCDX1,DGDY_DGDX,0,40,39,0,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX1_DGDY_DGDX(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX1_DGDY_DGDX_Q(_) _(SETUP2QRAST_DCDY_DCDX1,DGDY_DGDX_Q,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX1_DGDY_DGDX_Q(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX1_DGDY_DGDX_R(_) _(SETUP2QRAST_DCDY_DCDX1,DGDY_DGDX_R,0,22,39,18,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX1_DGDY_DGDX_R(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX1_DGPDY_DGPDX(_) _(SETUP2QRAST_DCDY_DCDX1,DGPDY_DGPDX,0,40,79,40,0xff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX1_DGPDY_DGPDX(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX1_DGPDY_DGPDX_Q(_) _(SETUP2QRAST_DCDY_DCDX1,DGPDY_DGPDX_Q,0,18,57,40,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX1_DGPDY_DGPDX_Q(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX1_DGPDY_DGPDX_R(_) _(SETUP2QRAST_DCDY_DCDX1,DGPDY_DGPDX_R,0,22,79,58,0x3fffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX1_DGPDY_DGPDX_R(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX1_PD(_) _(SETUP2QRAST_DCDY_DCDX1,PD,0,80,79,0,0xffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX1_PD(_)
#define PKT_FLD_SETUP2QRAST_DCDY_DCDX1_TAG(_) _(SETUP2QRAST_DCDY_DCDX1,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_DCDY_DCDX1_TAG(_) \
_(SETUP2QRAST_DCDY_DCDX1,TAG,REG,0) \
_(SETUP2QRAST_DCDY_DCDX1,TAG,Z,1) \
_(SETUP2QRAST_DCDY_DCDX1,TAG,C,2) \
_(SETUP2QRAST_DCDY_DCDX1,TAG,DCDX,3) \
_(SETUP2QRAST_DCDY_DCDX1,TAG,C_DCDX0,4) \
_(SETUP2QRAST_DCDY_DCDX1,TAG,C_DCDX1,5) \
_(SETUP2QRAST_DCDY_DCDX1,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST_DCDY_DCDX1,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST_DCDY_DCDX1,TAG,XY,8)
// CAUTION!!!!!!!!!
// While changing the packet sizes below, do not forget to change the PD field also

// Packet SETUP2QRAST_XY
#define LIST_PKT_FLD_SETUP2QRAST_XY(_) \
_(SETUP2QRAST_XY,XMIN) \
_(SETUP2QRAST_XY,XMAX) \
_(SETUP2QRAST_XY,YMIN) \
_(SETUP2QRAST_XY,YMAX) \
_(SETUP2QRAST_XY,YMID_IN) \
_(SETUP2QRAST_XY,YMID_OUT) \
_(SETUP2QRAST_XY,PD) \
_(SETUP2QRAST_XY,TAG)
#define PKT_SETUP2QRAST_XY(_) _(SETUP2QRAST_XY,110,FLD)
#define PKT_FLD_SETUP2QRAST_XY_XMIN(_) _(SETUP2QRAST_XY,XMIN,0,17,16,0,0x1ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_XY_XMIN(_)
#define PKT_FLD_SETUP2QRAST_XY_XMAX(_) _(SETUP2QRAST_XY,XMAX,0,18,34,17,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_XY_XMAX(_)
#define PKT_FLD_SETUP2QRAST_XY_YMIN(_) _(SETUP2QRAST_XY,YMIN,0,17,51,35,0x1ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_XY_YMIN(_)
#define PKT_FLD_SETUP2QRAST_XY_YMAX(_) _(SETUP2QRAST_XY,YMAX,0,18,69,52,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_XY_YMAX(_)
#define PKT_FLD_SETUP2QRAST_XY_YMID_IN(_) _(SETUP2QRAST_XY,YMID_IN,0,18,87,70,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_XY_YMID_IN(_)
#define PKT_FLD_SETUP2QRAST_XY_YMID_OUT(_) _(SETUP2QRAST_XY,YMID_OUT,0,18,105,88,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_XY_YMID_OUT(_)
#define PKT_FLD_SETUP2QRAST_XY_PD(_) _(SETUP2QRAST_XY,PD,0,106,105,0,0x3ff,NOENM)
#define LIST_PKT_ENM_SETUP2QRAST_XY_PD(_)
#define PKT_FLD_SETUP2QRAST_XY_TAG(_) _(SETUP2QRAST_XY,TAG,0,4,109,106,0xf,ENM)
#define LIST_PKT_ENM_SETUP2QRAST_XY_TAG(_) \
_(SETUP2QRAST_XY,TAG,REG,0) \
_(SETUP2QRAST_XY,TAG,Z,1) \
_(SETUP2QRAST_XY,TAG,C,2) \
_(SETUP2QRAST_XY,TAG,DCDX,3) \
_(SETUP2QRAST_XY,TAG,C_DCDX0,4) \
_(SETUP2QRAST_XY,TAG,C_DCDX1,5) \
_(SETUP2QRAST_XY,TAG,DCDY_DCDX0,6) \
_(SETUP2QRAST_XY,TAG,DCDY_DCDX1,7) \
_(SETUP2QRAST_XY,TAG,XY,8)
//
// setup to atrast slopes bus
//

// Packet SETUP2ATRAST_SLOPES
#define LIST_PKT_FLD_SETUP2ATRAST_SLOPES(_) \
_(SETUP2ATRAST_SLOPES,DATA) \
_(SETUP2ATRAST_SLOPES,C0) \
_(SETUP2ATRAST_SLOPES,DCDX) \
_(SETUP2ATRAST_SLOPES,DCDY) \
_(SETUP2ATRAST_SLOPES,EXP) \
_(SETUP2ATRAST_SLOPES,TID) \
_(SETUP2ATRAST_SLOPES,TAG)
#define PKT_SETUP2ATRAST_SLOPES(_) _(SETUP2ATRAST_SLOPES,81,FLD)
// includes C0, DCDX, DCDY
#define PKT_FLD_SETUP2ATRAST_SLOPES_DATA(_) _(SETUP2ATRAST_SLOPES,DATA,0,73,72,0,0x1ff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_DATA(_)
// S14.16 e6
#define PKT_FLD_SETUP2ATRAST_SLOPES_C0(_) _(SETUP2ATRAST_SLOPES,C0,0,31,30,0,0x7fffffff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_C0(_)
// S1.16 e6
#define PKT_FLD_SETUP2ATRAST_SLOPES_DCDX(_) _(SETUP2ATRAST_SLOPES,DCDX,0,18,48,31,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_DCDX(_)
// S1.16 e6
#define PKT_FLD_SETUP2ATRAST_SLOPES_DCDY(_) _(SETUP2ATRAST_SLOPES,DCDY,0,18,66,49,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_DCDY(_)
// common exponent among c0/dcdx/dcdy
#define PKT_FLD_SETUP2ATRAST_SLOPES_EXP(_) _(SETUP2ATRAST_SLOPES,EXP,0,6,72,67,0x3f,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_EXP(_)
#define PKT_FLD_SETUP2ATRAST_SLOPES_TID(_) _(SETUP2ATRAST_SLOPES,TID,0,6,78,73,0x3f,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_TID(_)
#define PKT_FLD_SETUP2ATRAST_SLOPES_TAG(_) _(SETUP2ATRAST_SLOPES,TAG,0,2,80,79,0x3,ENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_TAG(_) \
_(SETUP2ATRAST_SLOPES,TAG,ALPHA,0) \
_(SETUP2ATRAST_SLOPES,TAG,BETA,1) \
_(SETUP2ATRAST_SLOPES,TAG,GAMMA,2)
// S14.16

// Packet SETUP2ATRAST_SLOPES_C0
#define LIST_PKT_FLD_SETUP2ATRAST_SLOPES_C0(_) \
_(SETUP2ATRAST_SLOPES_C0,C0) \
_(SETUP2ATRAST_SLOPES_C0,SIGN) \
_(SETUP2ATRAST_SLOPES_C0,INT) \
_(SETUP2ATRAST_SLOPES_C0,FRAC)
#define PKT_SETUP2ATRAST_SLOPES_C0(_) _(SETUP2ATRAST_SLOPES_C0,31,FLD)
#define PKT_FLD_SETUP2ATRAST_SLOPES_C0_C0(_) _(SETUP2ATRAST_SLOPES_C0,C0,0,31,30,0,0x7fffffff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_C0_C0(_)
#define PKT_FLD_SETUP2ATRAST_SLOPES_C0_SIGN(_) _(SETUP2ATRAST_SLOPES_C0,SIGN,0,1,30,30,0x1,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_C0_SIGN(_)
#define PKT_FLD_SETUP2ATRAST_SLOPES_C0_INT(_) _(SETUP2ATRAST_SLOPES_C0,INT,0,14,29,16,0x3fff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_C0_INT(_)
#define PKT_FLD_SETUP2ATRAST_SLOPES_C0_FRAC(_) _(SETUP2ATRAST_SLOPES_C0,FRAC,0,16,15,0,0xffff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_C0_FRAC(_)

// Packet SETUP2ATRAST_SLOPES_DCDXDY
#define LIST_PKT_FLD_SETUP2ATRAST_SLOPES_DCDXDY(_) \
_(SETUP2ATRAST_SLOPES_DCDXDY,DCDX) \
_(SETUP2ATRAST_SLOPES_DCDXDY,DCDY) \
_(SETUP2ATRAST_SLOPES_DCDXDY,SIGN) \
_(SETUP2ATRAST_SLOPES_DCDXDY,INT) \
_(SETUP2ATRAST_SLOPES_DCDXDY,FRAC)
#define PKT_SETUP2ATRAST_SLOPES_DCDXDY(_) _(SETUP2ATRAST_SLOPES_DCDXDY,18,FLD)
#define PKT_FLD_SETUP2ATRAST_SLOPES_DCDXDY_DCDX(_) _(SETUP2ATRAST_SLOPES_DCDXDY,DCDX,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_DCDXDY_DCDX(_)
#define PKT_FLD_SETUP2ATRAST_SLOPES_DCDXDY_DCDY(_) _(SETUP2ATRAST_SLOPES_DCDXDY,DCDY,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_DCDXDY_DCDY(_)
#define PKT_FLD_SETUP2ATRAST_SLOPES_DCDXDY_SIGN(_) _(SETUP2ATRAST_SLOPES_DCDXDY,SIGN,0,1,17,17,0x1,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_DCDXDY_SIGN(_)
#define PKT_FLD_SETUP2ATRAST_SLOPES_DCDXDY_INT(_) _(SETUP2ATRAST_SLOPES_DCDXDY,INT,0,1,16,16,0x1,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_DCDXDY_INT(_)
#define PKT_FLD_SETUP2ATRAST_SLOPES_DCDXDY_FRAC(_) _(SETUP2ATRAST_SLOPES_DCDXDY,FRAC,0,16,15,0,0xffff,NOENM)
#define LIST_PKT_ENM_SETUP2ATRAST_SLOPES_DCDXDY_FRAC(_)
// QRAST to CLIP packet

// Packet QRAST2CLIP
#define LIST_PKT_FLD_QRAST2CLIP(_) \
_(QRAST2CLIP,TID)
#define PKT_QRAST2CLIP(_) _(QRAST2CLIP,6,FLD)
#define PKT_FLD_QRAST2CLIP_TID(_) _(QRAST2CLIP,TID,0,6,5,0,0x3f,NOENM)
#define LIST_PKT_ENM_QRAST2CLIP_TID(_)
// PSEQ to QRAST packet

// Packet PSEQ2QRAST
#define LIST_PKT_FLD_PSEQ2QRAST(_) \
_(PSEQ2QRAST,TRI_ID)
#define PKT_PSEQ2QRAST(_) _(PSEQ2QRAST,6,FLD)
// which tri is done
#define PKT_FLD_PSEQ2QRAST_TRI_ID(_) _(PSEQ2QRAST,TRI_ID,0,6,5,0,0x3f,NOENM)
#define LIST_PKT_ENM_PSEQ2QRAST_TRI_ID(_)
// read/raise/refcnt return values from GRGK

// Packet GK2SETUP_RDAT
#define LIST_PKT_FLD_GK2SETUP_RDAT(_) \
_(GK2SETUP_RDAT,DATA) \
_(GK2SETUP_RDAT,CHANNEL) \
_(GK2SETUP_RDAT,TYPE)
#define PKT_GK2SETUP_RDAT(_) _(GK2SETUP_RDAT,38,FLD)
#define PKT_FLD_GK2SETUP_RDAT_DATA(_) _(GK2SETUP_RDAT,DATA,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_GK2SETUP_RDAT_DATA(_)
#define PKT_FLD_GK2SETUP_RDAT_CHANNEL(_) _(GK2SETUP_RDAT,CHANNEL,0,4,35,32,0xf,NOENM)
#define LIST_PKT_ENM_GK2SETUP_RDAT_CHANNEL(_)
#define PKT_FLD_GK2SETUP_RDAT_TYPE(_) _(GK2SETUP_RDAT,TYPE,0,2,37,36,0x3,ENM)
#define LIST_PKT_ENM_GK2SETUP_RDAT_TYPE(_) \
_(GK2SETUP_RDAT,TYPE,REGISTER,0) \
_(GK2SETUP_RDAT,TYPE,RAISE,1) \
_(GK2SETUP_RDAT,TYPE,REFCNT,2) \
_(GK2SETUP_RDAT,TYPE,CTXSW_ACK,3)
// Packet to define Alpha Perspective and Beta Perspective
// for the high-recision IPAs
// This packet is used by qrast and atrast in the IPAs

// Packet BARY_C_PER_HI
#define LIST_PKT_FLD_BARY_C_PER_HI(_) \
_(BARY_C_PER_HI,FRAC) \
_(BARY_C_PER_HI,INT) \
_(BARY_C_PER_HI,SIGN)
#define PKT_BARY_C_PER_HI(_) _(BARY_C_PER_HI,16,FLD)
#define PKT_FLD_BARY_C_PER_HI_FRAC(_) _(BARY_C_PER_HI,FRAC,0,14,13,0,0x3fff,NOENM)
#define LIST_PKT_ENM_BARY_C_PER_HI_FRAC(_)
#define PKT_FLD_BARY_C_PER_HI_INT(_) _(BARY_C_PER_HI,INT,0,1,14,14,0x1,NOENM)
#define LIST_PKT_ENM_BARY_C_PER_HI_INT(_)
#define PKT_FLD_BARY_C_PER_HI_SIGN(_) _(BARY_C_PER_HI,SIGN,0,1,15,15,0x1,NOENM)
#define LIST_PKT_ENM_BARY_C_PER_HI_SIGN(_)
// Packet to define Alpha Perspective and Beta Perspective
// for the lo-recision IPAs

// Packet BARY_C_PER_LO
#define LIST_PKT_FLD_BARY_C_PER_LO(_) \
_(BARY_C_PER_LO,FRAC) \
_(BARY_C_PER_LO,INT) \
_(BARY_C_PER_LO,SIGN)
#define PKT_BARY_C_PER_LO(_) _(BARY_C_PER_LO,12,FLD)
#define PKT_FLD_BARY_C_PER_LO_FRAC(_) _(BARY_C_PER_LO,FRAC,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_BARY_C_PER_LO_FRAC(_)
#define PKT_FLD_BARY_C_PER_LO_INT(_) _(BARY_C_PER_LO,INT,0,1,10,10,0x1,NOENM)
#define LIST_PKT_ENM_BARY_C_PER_LO_INT(_)
#define PKT_FLD_BARY_C_PER_LO_SIGN(_) _(BARY_C_PER_LO,SIGN,0,1,11,11,0x1,NOENM)
#define LIST_PKT_ENM_BARY_C_PER_LO_SIGN(_)
// OBSOLETE, use PIXPKT instead
#define RASTER_SB_WIDTH 7

// Packet RS_SB
#define LIST_PKT_FLD_RS_SB(_) \
_(RS_SB,TAG) \
_(RS_SB,KILL_PIX) \
_(RS_SB,ODD) \
_(RS_SB,SEQ)
#define PKT_RS_SB(_) _(RS_SB,7,FLD)
#define PKT_FLD_RS_SB_TAG(_) _(RS_SB,TAG,0,1,6,6,0x1,NOENM)
#define LIST_PKT_ENM_RS_SB_TAG(_)
#define PKT_FLD_RS_SB_KILL_PIX(_) _(RS_SB,KILL_PIX,0,1,5,5,0x1,NOENM)
#define LIST_PKT_ENM_RS_SB_KILL_PIX(_)
#define PKT_FLD_RS_SB_ODD(_) _(RS_SB,ODD,0,1,4,4,0x1,NOENM)
#define LIST_PKT_ENM_RS_SB_ODD(_)
#define PKT_FLD_RS_SB_SEQ(_) _(RS_SB,SEQ,0,4,3,0,0xf,NOENM)
#define LIST_PKT_ENM_RS_SB_SEQ(_)
// 3d unit to 3d unit register writes.  Not software visible.
#define RASTER_PACKET_WIDTH     80
#define RASTER_PACKET_ARG_WIDTH 20
// there are four of these 20b fields in a RASTER.
// it can carry a packed 5555 argb, a 16b Z, a pair of 10b interps, or
// an S or T coordinate.  in the last case, the bottom 4b contain the
// high or low 4b of the LOD value.  After the TEX_address stage, the S&T
// are replaced with an assortment of values to avoid having to put them
// in a sideband FIFO.

// Packet RAST_R
#define LIST_PKT_FLD_RAST_R(_) \
_(RAST_R,R) \
_(RAST_R,BLUE) \
_(RAST_R,GREEN) \
_(RAST_R,RED) \
_(RAST_R,ALPHA) \
_(RAST_R,L10) \
_(RAST_R,H10) \
_(RAST_R,Z) \
_(RAST_R,ALPHA_LOW) \
_(RAST_R,GREEN_LOW) \
_(RAST_R,TEX_LOD) \
_(RAST_R,TEX) \
_(RAST_R,TEX_LODF) \
_(RAST_R,TEX_QUADLIN) \
_(RAST_R,TEX_FORMAT) \
_(RAST_R,TEX_T_FRAC) \
_(RAST_R,TEX_S_FRAC) \
_(RAST_R,TEX_SAME_T) \
_(RAST_R,TEX_SAME_S) \
_(RAST_R,TEX_BILIN) \
_(RAST_R,TEX_ADR_BNK0_BIT3) \
_(RAST_R,TEX_ADR_BNK1_BIT3) \
_(RAST_R,TEX_ADR_BNK2_BIT3) \
_(RAST_R,TEX_ADR_BNK3_BIT3) \
_(RAST_R,TEX_IN_LINE_MSK) \
_(RAST_R,TEX_UNUSED)
#define PKT_RAST_R(_) _(RAST_R,40,FLD)
// whole register
#define PKT_FLD_RAST_R_R(_) _(RAST_R,R,0,20,19,0,0xfffff,NOENM)
#define LIST_PKT_ENM_RAST_R_R(_)
// blue component from B5G5R5A5
#define PKT_FLD_RAST_R_BLUE(_) _(RAST_R,BLUE,0,5,4,0,0x1f,NOENM)
#define LIST_PKT_ENM_RAST_R_BLUE(_)
// green component from B5G5R5A5
#define PKT_FLD_RAST_R_GREEN(_) _(RAST_R,GREEN,0,5,9,5,0x1f,NOENM)
#define LIST_PKT_ENM_RAST_R_GREEN(_)
// red component from B5G5R5A5
#define PKT_FLD_RAST_R_RED(_) _(RAST_R,RED,0,5,14,10,0x1f,NOENM)
#define LIST_PKT_ENM_RAST_R_RED(_)
// alpha component from B5G5R5A5
#define PKT_FLD_RAST_R_ALPHA(_) _(RAST_R,ALPHA,0,5,19,15,0x1f,NOENM)
#define LIST_PKT_ENM_RAST_R_ALPHA(_)
// low RAST_H-format parameter
#define PKT_FLD_RAST_R_L10(_) _(RAST_R,L10,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_RAST_R_L10(_)
// high RAST_H-format parameter
#define PKT_FLD_RAST_R_H10(_) _(RAST_R,H10,0,10,19,10,0x3ff,NOENM)
#define LIST_PKT_ENM_RAST_R_H10(_)
// iterated Z value
#define PKT_FLD_RAST_R_Z(_) _(RAST_R,Z,0,16,19,4,0xffff,NOENM)
#define LIST_PKT_ENM_RAST_R_Z(_)
// low 3 bits of alpha from B4G6R5A8
#define PKT_FLD_RAST_R_ALPHA_LOW(_) _(RAST_R,ALPHA_LOW,0,3,3,1,0x7,NOENM)
#define LIST_PKT_ENM_RAST_R_ALPHA_LOW(_)
// low 1 bit of green from B5G6R5A8
#define PKT_FLD_RAST_R_GREEN_LOW(_) _(RAST_R,GREEN_LOW,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_RAST_R_GREEN_LOW(_)
// lod (packed with texcoords as frac (s) and int (t))
#define PKT_FLD_RAST_R_TEX_LOD(_) _(RAST_R,TEX_LOD,0,4,3,0,0xf,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_LOD(_)
// generic texcoord
#define PKT_FLD_RAST_R_TEX(_) _(RAST_R,TEX,0,16,19,4,0xffff,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX(_)
// fractional LOD  <<--- here and below are overlays for S,T --->>
#define PKT_FLD_RAST_R_TEX_LODF(_) _(RAST_R,TEX_LODF,0,4,3,0,0xf,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_LODF(_)
// pipelined SURFDESC QUADLIN
#define PKT_FLD_RAST_R_TEX_QUADLIN(_) _(RAST_R,TEX_QUADLIN,0,1,4,4,0x1,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_QUADLIN(_)
// pipelined SURFDESC SURF_FORMAT
#define PKT_FLD_RAST_R_TEX_FORMAT(_) _(RAST_R,TEX_FORMAT,0,5,9,5,0x1f,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_FORMAT(_)
// # of fraction bits of T to use in bilerp
#define PKT_FLD_RAST_R_TEX_T_FRAC(_) _(RAST_R,TEX_T_FRAC,0,7,16,10,0x7f,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_T_FRAC(_)
// # of fraction bits of S to use in bilerp
#define PKT_FLD_RAST_R_TEX_S_FRAC(_) _(RAST_R,TEX_S_FRAC,0,7,23,17,0x7f,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_S_FRAC(_)
// 1 means bilerp texel has collapsed the T dimension
#define PKT_FLD_RAST_R_TEX_SAME_T(_) _(RAST_R,TEX_SAME_T,0,1,24,24,0x1,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_SAME_T(_)
// 1 means bilerp texel has collapsed the S dimension
#define PKT_FLD_RAST_R_TEX_SAME_S(_) _(RAST_R,TEX_SAME_S,0,1,25,25,0x1,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_SAME_S(_)
// 1=bilerp, 0=point sample
#define PKT_FLD_RAST_R_TEX_BILIN(_) _(RAST_R,TEX_BILIN,0,1,26,26,0x1,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_BILIN(_)
// Bit 3 of bank 0's memory address
#define PKT_FLD_RAST_R_TEX_ADR_BNK0_BIT3(_) _(RAST_R,TEX_ADR_BNK0_BIT3,0,1,27,27,0x1,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_ADR_BNK0_BIT3(_)
// Bit 3 of bank 1's memory address
#define PKT_FLD_RAST_R_TEX_ADR_BNK1_BIT3(_) _(RAST_R,TEX_ADR_BNK1_BIT3,0,1,28,28,0x1,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_ADR_BNK1_BIT3(_)
// Bit 3 of bank 2's memory address
#define PKT_FLD_RAST_R_TEX_ADR_BNK2_BIT3(_) _(RAST_R,TEX_ADR_BNK2_BIT3,0,1,29,29,0x1,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_ADR_BNK2_BIT3(_)
// Bit 3 of bank 3's memory address
#define PKT_FLD_RAST_R_TEX_ADR_BNK3_BIT3(_) _(RAST_R,TEX_ADR_BNK3_BIT3,0,1,30,30,0x1,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_ADR_BNK3_BIT3(_)
// bit mask for the in line address
#define PKT_FLD_RAST_R_TEX_IN_LINE_MSK(_) _(RAST_R,TEX_IN_LINE_MSK,0,7,37,31,0x7f,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_IN_LINE_MSK(_)
// reserved
#define PKT_FLD_RAST_R_TEX_UNUSED(_) _(RAST_R,TEX_UNUSED,0,2,39,38,0x3,NOENM)
#define LIST_PKT_ENM_RAST_R_TEX_UNUSED(_)
// define for s1.8

// Packet RAST_H
#define LIST_PKT_FLD_RAST_H(_) \
_(RAST_H,FX10) \
_(RAST_H,FRACTION) \
_(RAST_H,INT) \
_(RAST_H,SIGN)
#define PKT_RAST_H(_) _(RAST_H,10,FLD)
#define PKT_FLD_RAST_H_FX10(_) _(RAST_H,FX10,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_RAST_H_FX10(_)
#define PKT_FLD_RAST_H_FRACTION(_) _(RAST_H,FRACTION,0,8,7,0,0xff,NOENM)
#define LIST_PKT_ENM_RAST_H_FRACTION(_)
#define PKT_FLD_RAST_H_INT(_) _(RAST_H,INT,0,1,8,8,0x1,NOENM)
#define LIST_PKT_ENM_RAST_H_INT(_)
#define PKT_FLD_RAST_H_SIGN(_) _(RAST_H,SIGN,0,1,9,9,0x1,NOENM)
#define LIST_PKT_ENM_RAST_H_SIGN(_)
// a pixel packet goes down the pipeline, containing nothing, a register
// access, or a row of pixel information.  The bulk of it is the 80b wide
// RASTER field, which itself is really four 20b fields stuck together.
// There are also some sideband fields describing what the packet contains.
// SEQ is essentially an instruction pointer -- each unit uses this to figure
// out what operations to perform on the row.  It is meaningless on register
// accesses but should be set to 0.  Although there is some historical confusion
// over it, TAG is meaningless if KILL is set; if KILL is set, TAG is ignored
// and the information is a dead pixel.  Only the DW cares about the difference.
//
// In the interest of power conservation, only the necessary fields should
// be propagated on clock edges, based on packet contents.
//
// The valid combinations of sideband information is as follows:
//
//   valid, kill, tag, odd
//     0     x     x    x   -- ignore this cycle, don't propagate anything bug valid
//     1     0     0   0/1  -- live even or odd pixel; propagate everything
//     1     1     x   0/1  -- dead even or odd pixel; propagate all flags
//     1     0     1    x   -- live reg read or write; propagate everything

// Packet PIXPKT
#define LIST_PKT_FLD_PIXPKT(_) \
_(PIXPKT,SEQ) \
_(PIXPKT,KILL) \
_(PIXPKT,TAG) \
_(PIXPKT,X) \
_(PIXPKT,RASTER) \
_(PIXPKT,R0) \
_(PIXPKT,R1) \
_(PIXPKT,R2) \
_(PIXPKT,R3)
#define PKT_PIXPKT(_) _(PIXPKT,87,FLD)
// sequence # -- which instruction to apply to row
#define PKT_FLD_PIXPKT_SEQ(_) _(PIXPKT,SEQ,0,4,86,83,0xf,NOENM)
#define LIST_PKT_ENM_PIXPKT_SEQ(_)
// 1=dead pixel, 0=live pixel or register access
#define PKT_FLD_PIXPKT_KILL(_) _(PIXPKT,KILL,0,1,82,82,0x1,NOENM)
#define LIST_PKT_ENM_PIXPKT_KILL(_)
// meaningless if KILL, else 1=register, 0=pixel
#define PKT_FLD_PIXPKT_TAG(_) _(PIXPKT,TAG,0,1,81,81,0x1,ENM)
#define LIST_PKT_ENM_PIXPKT_TAG(_) \
_(PIXPKT,TAG,PIX,0) \
_(PIXPKT,TAG,REG,1)
// indicates even (0) or odd (1) pixel of a pair
#define PKT_FLD_PIXPKT_X(_) _(PIXPKT,X,0,1,80,80,0x1,NOENM)
#define LIST_PKT_ENM_PIXPKT_X(_)
// if pixel (tag=0) four packed 20b fields, else register access
#define PKT_FLD_PIXPKT_RASTER(_) _(PIXPKT,RASTER,0,80,79,0,0xffff,NOENM)
#define LIST_PKT_ENM_PIXPKT_RASTER(_)
#define PKT_FLD_PIXPKT_R0(_) _(PIXPKT,R0,0,20,19,0,0xfffff,NOENM)
#define LIST_PKT_ENM_PIXPKT_R0(_)
#define PKT_FLD_PIXPKT_R1(_) _(PIXPKT,R1,0,20,39,20,0xfffff,NOENM)
#define LIST_PKT_ENM_PIXPKT_R1(_)
#define PKT_FLD_PIXPKT_R2(_) _(PIXPKT,R2,0,20,59,40,0xfffff,NOENM)
#define LIST_PKT_ENM_PIXPKT_R2(_)
#define PKT_FLD_PIXPKT_R3(_) _(PIXPKT,R3,0,20,79,60,0xfffff,NOENM)
#define LIST_PKT_ENM_PIXPKT_R3(_)

// Packet GK_PIXPKT
#define LIST_PKT_FLD_GK_PIXPKT(_) \
_(GK_PIXPKT,SBSTALLED) \
_(GK_PIXPKT,SEQ) \
_(GK_PIXPKT,KILL) \
_(GK_PIXPKT,TAG) \
_(GK_PIXPKT,X) \
_(GK_PIXPKT,RASTER) \
_(GK_PIXPKT,R0) \
_(GK_PIXPKT,R1) \
_(GK_PIXPKT,R2) \
_(GK_PIXPKT,R3)
#define PKT_GK_PIXPKT(_) _(GK_PIXPKT,88,FLD)
// indicates that the pixel packet has been stalled by the scoreboard
#define PKT_FLD_GK_PIXPKT_SBSTALLED(_) _(GK_PIXPKT,SBSTALLED,0,1,87,87,0x1,NOENM)
#define LIST_PKT_ENM_GK_PIXPKT_SBSTALLED(_)
// sequence # -- which instruction to apply to row
#define PKT_FLD_GK_PIXPKT_SEQ(_) _(GK_PIXPKT,SEQ,0,4,86,83,0xf,NOENM)
#define LIST_PKT_ENM_GK_PIXPKT_SEQ(_)
// 1=dead pixel, 0=live pixel or register access
#define PKT_FLD_GK_PIXPKT_KILL(_) _(GK_PIXPKT,KILL,0,1,82,82,0x1,NOENM)
#define LIST_PKT_ENM_GK_PIXPKT_KILL(_)
// meaningless if KILL, else 1=register, 0=pixel
#define PKT_FLD_GK_PIXPKT_TAG(_) _(GK_PIXPKT,TAG,0,1,81,81,0x1,ENM)
#define LIST_PKT_ENM_GK_PIXPKT_TAG(_) \
_(GK_PIXPKT,TAG,PIX,0) \
_(GK_PIXPKT,TAG,REG,1)
// indicates even (0) or odd (1) pixel of a pair
#define PKT_FLD_GK_PIXPKT_X(_) _(GK_PIXPKT,X,0,1,80,80,0x1,NOENM)
#define LIST_PKT_ENM_GK_PIXPKT_X(_)
// if pixel (tag=0) four packed 20b fields, else register access
#define PKT_FLD_GK_PIXPKT_RASTER(_) _(GK_PIXPKT,RASTER,0,80,79,0,0xffff,NOENM)
#define LIST_PKT_ENM_GK_PIXPKT_RASTER(_)
#define PKT_FLD_GK_PIXPKT_R0(_) _(GK_PIXPKT,R0,0,20,19,0,0xfffff,NOENM)
#define LIST_PKT_ENM_GK_PIXPKT_R0(_)
#define PKT_FLD_GK_PIXPKT_R1(_) _(GK_PIXPKT,R1,0,20,39,20,0xfffff,NOENM)
#define LIST_PKT_ENM_GK_PIXPKT_R1(_)
#define PKT_FLD_GK_PIXPKT_R2(_) _(GK_PIXPKT,R2,0,20,59,40,0xfffff,NOENM)
#define LIST_PKT_ENM_GK_PIXPKT_R2(_)
#define PKT_FLD_GK_PIXPKT_R3(_) _(GK_PIXPKT,R3,0,20,79,60,0xfffff,NOENM)
#define LIST_PKT_ENM_GK_PIXPKT_R3(_)

// Packet REG_WRITE
#define LIST_PKT_FLD_REG_WRITE(_) \
_(REG_WRITE,DATA) \
_(REG_WRITE,ADDR) \
_(REG_WRITE,BLK_ADDR) \
_(REG_WRITE,BLK_NUM) \
_(REG_WRITE,GLB) \
_(REG_WRITE,READ) \
_(REG_WRITE,CHANNEL) \
_(REG_WRITE,READ_DONE) \
_(REG_WRITE,READ_CHAN)
#define PKT_REG_WRITE(_) _(REG_WRITE,54,FLD)
#define PKT_FLD_REG_WRITE_DATA(_) _(REG_WRITE,DATA,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_REG_WRITE_DATA(_)
#define PKT_FLD_REG_WRITE_ADDR(_) _(REG_WRITE,ADDR,0,12,43,32,0xfff,NOENM)
#define LIST_PKT_ENM_REG_WRITE_ADDR(_)
#define PKT_FLD_REG_WRITE_BLK_ADDR(_) _(REG_WRITE,BLK_ADDR,0,8,39,32,0xff,NOENM)
#define LIST_PKT_ENM_REG_WRITE_BLK_ADDR(_)
#define PKT_FLD_REG_WRITE_BLK_NUM(_) _(REG_WRITE,BLK_NUM,0,4,43,40,0xf,ENM)
#define LIST_PKT_ENM_REG_WRITE_BLK_NUM(_) \
_(REG_WRITE,BLK_NUM,VTX,0) \
_(REG_WRITE,BLK_NUM,SETUP,1) \
_(REG_WRITE,BLK_NUM,RS,2) \
_(REG_WRITE,BLK_NUM,GK,3) \
_(REG_WRITE,BLK_NUM,DF,4) \
_(REG_WRITE,BLK_NUM,ALU,5) \
_(REG_WRITE,BLK_NUM,ALU0,6) \
_(REG_WRITE,BLK_NUM,ALU1,7) \
_(REG_WRITE,BLK_NUM,ALU2,8) \
_(REG_WRITE,BLK_NUM,ALU3,9) \
_(REG_WRITE,BLK_NUM,DW,10) \
_(REG_WRITE,BLK_NUM,FDC,11) \
_(REG_WRITE,BLK_NUM,GLB1,14) \
_(REG_WRITE,BLK_NUM,GLB2,15)
#define PKT_FLD_REG_WRITE_GLB(_) _(REG_WRITE,GLB,0,1,47,47,0x1,NOENM)
#define LIST_PKT_ENM_REG_WRITE_GLB(_)
#define PKT_FLD_REG_WRITE_READ(_) _(REG_WRITE,READ,0,1,48,48,0x1,NOENM)
#define LIST_PKT_ENM_REG_WRITE_READ(_)
// channel for register transaction (needed for RAISE/REFCNT writes as well as reads!)
#define PKT_FLD_REG_WRITE_CHANNEL(_) _(REG_WRITE,CHANNEL,0,4,53,50,0xf,NOENM)
#define LIST_PKT_ENM_REG_WRITE_CHANNEL(_)
// obsolete (reads always recirc exactly once)
#define PKT_FLD_REG_WRITE_READ_DONE(_) _(REG_WRITE,READ_DONE,0,1,49,49,0x1,NOENM)
#define LIST_PKT_ENM_REG_WRITE_READ_DONE(_)
// obsolete, use CHANNEL
#define PKT_FLD_REG_WRITE_READ_CHAN(_) _(REG_WRITE,READ_CHAN,0,4,53,50,0xf,NOENM)
#define LIST_PKT_ENM_REG_WRITE_READ_CHAN(_)

// Packet SCOREBOARD_FLUSH
#define LIST_PKT_FLD_SCOREBOARD_FLUSH(_) \
_(SCOREBOARD_FLUSH,MASK) \
_(SCOREBOARD_FLUSH,HASH) \
_(SCOREBOARD_FLUSH,VALID)
#define PKT_SCOREBOARD_FLUSH(_) _(SCOREBOARD_FLUSH,14,FLD)
// 4 Bit mask of valid pixel pairs
#define PKT_FLD_SCOREBOARD_FLUSH_MASK(_) _(SCOREBOARD_FLUSH,MASK,0,4,13,10,0xf,NOENM)
#define LIST_PKT_ENM_SCOREBOARD_FLUSH_MASK(_)
// 9 bit hash address entry {x[6:3],y[4:0]}
#define PKT_FLD_SCOREBOARD_FLUSH_HASH(_) _(SCOREBOARD_FLUSH,HASH,0,9,9,1,0x1ff,NOENM)
#define LIST_PKT_ENM_SCOREBOARD_FLUSH_HASH(_)
// data is valid
#define PKT_FLD_SCOREBOARD_FLUSH_VALID(_) _(SCOREBOARD_FLUSH,VALID,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_SCOREBOARD_FLUSH_VALID(_)
// -------------------------------------------------------------------
//    GRGK stuff
// -------------------------------------------------------------------
#define AR3D_GK_MAX_LOOP_CNT    8100
#define AR3D_GK_BLK_SB_WIDTH    64
#define AR3D_GK_BLK_SB_WD_INDEX 6
#define AR3D_GK_BLK_SB_DEPTH    32
#define AR3D_GK_BLK_SB_DP_INDEX 5
// -------------------------------------------------------------------
//    TEX stuff
// -------------------------------------------------------------------
//pixpkt latency hiding fifo
#define NV_TEX_PKTFIFO_DEPTH    150
//random stuff bank miss and such
#define NV_TEX_STUFFFIFO_DEPTH  150
#define NV_TEX_RESULTFIFO_DEPTH 150
#define NV_TEX_LODSKIPFIFO_DEPTH        32
// tex inputfifo
//define NV_TEX_INPUTFIFO_DEPTH 8;
// Packet internal to DF block.
// This is the data bundle that lives in the zfifo.
//packet ZFIFO
//   79:0     0   raster          // pixel packet
//   111:80   0   inst            // zifo_inst instruction
//   112      0   pixdone         // pixel done status
//   113      0   tag             // tag/pixel flag
//   114      0   kill            // dead pixel flag
//  118:115  0   seq             // instruction sequence number
//  119      0   flush           // flush ucache status
//;
// Packet internal to DF block.
// This is the data bundle that lives in the cfifo.
//packet CFIFO
//   79:0     0   raster          // pixel packet
//   111:80   0   inst            // zifo_inst instruction
//   112      0   pixdone         // pixel done status
//   113      0   tag             // tag/pixel flag
//   114      0   kill            // dead pixel flag
//   118:115  0   seq             // instruction sequence number
//   123:119  0   pixfmt          // pixel format
//;
// Packet internal to DF block.
// This is the data bundle that lives in the texfifo.

// Packet TEXSTUFFFIFO
#define LIST_PKT_FLD_TEXSTUFFFIFO(_) \
_(TEXSTUFFFIFO,Bnk2_mem_addr_s0_orig) \
_(TEXSTUFFFIFO,Bnk0_mem_addr_s0_orig) \
_(TEXSTUFFFIFO,align_Bnk02) \
_(TEXSTUFFFIFO,align_Bnk13) \
_(TEXSTUFFFIFO,s0) \
_(TEXSTUFFFIFO,s1) \
_(TEXSTUFFFIFO,t0) \
_(TEXSTUFFFIFO,t1) \
_(TEXSTUFFFIFO,awtw_last) \
_(TEXSTUFFFIFO,awtw) \
_(TEXSTUFFFIFO,awtw_weight) \
_(TEXSTUFFFIFO,layout) \
_(TEXSTUFFFIFO,surf_format) \
_(TEXSTUFFFIFO,t_frac) \
_(TEXSTUFFFIFO,s_frac) \
_(TEXSTUFFFIFO,bilinear) \
_(TEXSTUFFFIFO,in_line_add_msk) \
_(TEXSTUFFFIFO,ul_bnk) \
_(TEXSTUFFFIFO,Bnk3_miss_req) \
_(TEXSTUFFFIFO,Bnk2_miss_req) \
_(TEXSTUFFFIFO,Bnk1_miss_req) \
_(TEXSTUFFFIFO,Bnk0_miss_req) \
_(TEXSTUFFFIFO,Bnk0Bnk2_sm2big_mem_addr) \
_(TEXSTUFFFIFO,Bnk1Bnk3_sm2big_mem_addr) \
_(TEXSTUFFFIFO,Bnk2_mem_addr_s0) \
_(TEXSTUFFFIFO,Bnk0_mem_addr_s0) \
_(TEXSTUFFFIFO,Bnk0_entry) \
_(TEXSTUFFFIFO,Bnk0_hit) \
_(TEXSTUFFFIFO,Bnk1_entry) \
_(TEXSTUFFFIFO,Bnk1_hit) \
_(TEXSTUFFFIFO,Bnk2_entry) \
_(TEXSTUFFFIFO,Bnk2_hit) \
_(TEXSTUFFFIFO,Bnk3_entry) \
_(TEXSTUFFFIFO,Bnk3_hit) \
_(TEXSTUFFFIFO,merge_bnk02) \
_(TEXSTUFFFIFO,merge_bnk13) \
_(TEXSTUFFFIFO,instr) \
_(TEXSTUFFFIFO,in_line_address)
#define PKT_TEXSTUFFFIFO(_) _(TEXSTUFFFIFO,118,FLD)
//  Bit 3 of memory address for bank 3
#define PKT_FLD_TEXSTUFFFIFO_Bnk2_mem_addr_s0_orig(_) _(TEXSTUFFFIFO,Bnk2_mem_addr_s0_orig,0,1,117,117,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk2_mem_addr_s0_orig(_)
//  Bit 3 of memory address for bank 2
#define PKT_FLD_TEXSTUFFFIFO_Bnk0_mem_addr_s0_orig(_) _(TEXSTUFFFIFO,Bnk0_mem_addr_s0_orig,0,1,116,116,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk0_mem_addr_s0_orig(_)
//bit 4 of memory addr,selects upper, lower 128 bit chunk
#define PKT_FLD_TEXSTUFFFIFO_align_Bnk02(_) _(TEXSTUFFFIFO,align_Bnk02,0,1,115,115,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_align_Bnk02(_)
//bit 4 of memory addr,selects upper, lower 128 bit chunk
#define PKT_FLD_TEXSTUFFFIFO_align_Bnk13(_) _(TEXSTUFFFIFO,align_Bnk13,0,1,114,114,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_align_Bnk13(_)
//s0
#define PKT_FLD_TEXSTUFFFIFO_s0(_) _(TEXSTUFFFIFO,s0,0,7,113,107,0x7f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_s0(_)
//s1
#define PKT_FLD_TEXSTUFFFIFO_s1(_) _(TEXSTUFFFIFO,s1,0,7,106,100,0x7f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_s1(_)
//t0
#define PKT_FLD_TEXSTUFFFIFO_t0(_) _(TEXSTUFFFIFO,t0,0,3,99,97,0x7,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_t0(_)
//t1
#define PKT_FLD_TEXSTUFFFIFO_t1(_) _(TEXSTUFFFIFO,t1,0,3,96,94,0x7,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_t1(_)
//says this is the last weight for aw or tri-linear.
#define PKT_FLD_TEXSTUFFFIFO_awtw_last(_) _(TEXSTUFFFIFO,awtw_last,0,1,93,93,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_awtw_last(_)
//says if the aniso weight and tri weight is valid.(says if doing trilinear or aniso
#define PKT_FLD_TEXSTUFFFIFO_awtw(_) _(TEXSTUFFFIFO,awtw,0,1,92,92,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_awtw(_)
//aniso weigth and trilinear weight combo
#define PKT_FLD_TEXSTUFFFIFO_awtw_weight(_) _(TEXSTUFFFIFO,awtw_weight,0,7,91,85,0x7f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_awtw_weight(_)
//linear vs swizzled
#define PKT_FLD_TEXSTUFFFIFO_layout(_) _(TEXSTUFFFIFO,layout,0,2,84,83,0x3,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_layout(_)
//surface format being read
#define PKT_FLD_TEXSTUFFFIFO_surf_format(_) _(TEXSTUFFFIFO,surf_format,0,6,82,77,0x3f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_surf_format(_)
//fractionla part of t
#define PKT_FLD_TEXSTUFFFIFO_t_frac(_) _(TEXSTUFFFIFO,t_frac,0,6,76,71,0x3f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_t_frac(_)
//fractionla part of s
#define PKT_FLD_TEXSTUFFFIFO_s_frac(_) _(TEXSTUFFFIFO,s_frac,0,6,70,65,0x3f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_s_frac(_)
//whether doing bilinear
#define PKT_FLD_TEXSTUFFFIFO_bilinear(_) _(TEXSTUFFFIFO,bilinear,0,1,64,64,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_bilinear(_)
//in line address mask
#define PKT_FLD_TEXSTUFFFIFO_in_line_add_msk(_) _(TEXSTUFFFIFO,in_line_add_msk,0,7,63,57,0x7f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_in_line_add_msk(_)
// upper left texel of four falls in this bank
#define PKT_FLD_TEXSTUFFFIFO_ul_bnk(_) _(TEXSTUFFFIFO,ul_bnk,0,2,56,55,0x3,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_ul_bnk(_)
// tex missed on bank 3
#define PKT_FLD_TEXSTUFFFIFO_Bnk3_miss_req(_) _(TEXSTUFFFIFO,Bnk3_miss_req,0,1,54,54,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk3_miss_req(_)
// tex missed on bank 2
#define PKT_FLD_TEXSTUFFFIFO_Bnk2_miss_req(_) _(TEXSTUFFFIFO,Bnk2_miss_req,0,1,53,53,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk2_miss_req(_)
// tex missed on bank 1
#define PKT_FLD_TEXSTUFFFIFO_Bnk1_miss_req(_) _(TEXSTUFFFIFO,Bnk1_miss_req,0,1,52,52,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk1_miss_req(_)
// tex missed on bank 0
#define PKT_FLD_TEXSTUFFFIFO_Bnk0_miss_req(_) _(TEXSTUFFFIFO,Bnk0_miss_req,0,1,51,51,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk0_miss_req(_)
//  Bit 3 of memory address for bank 3
#define PKT_FLD_TEXSTUFFFIFO_Bnk0Bnk2_sm2big_mem_addr(_) _(TEXSTUFFFIFO,Bnk0Bnk2_sm2big_mem_addr,0,1,50,50,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk0Bnk2_sm2big_mem_addr(_)
//  Bit 3 of memory address for bank 3
#define PKT_FLD_TEXSTUFFFIFO_Bnk1Bnk3_sm2big_mem_addr(_) _(TEXSTUFFFIFO,Bnk1Bnk3_sm2big_mem_addr,0,1,49,49,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk1Bnk3_sm2big_mem_addr(_)
//  Bit 3 of memory address for bank 1
#define PKT_FLD_TEXSTUFFFIFO_Bnk2_mem_addr_s0(_) _(TEXSTUFFFIFO,Bnk2_mem_addr_s0,0,1,48,48,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk2_mem_addr_s0(_)
//  Bit 3 of memory address for bank 0
#define PKT_FLD_TEXSTUFFFIFO_Bnk0_mem_addr_s0(_) _(TEXSTUFFFIFO,Bnk0_mem_addr_s0,0,1,47,47,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk0_mem_addr_s0(_)
// which of bank 0's 32 lines to use
#define PKT_FLD_TEXSTUFFFIFO_Bnk0_entry(_) _(TEXSTUFFFIFO,Bnk0_entry,0,5,46,42,0x1f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk0_entry(_)
// bank 0 hit
#define PKT_FLD_TEXSTUFFFIFO_Bnk0_hit(_) _(TEXSTUFFFIFO,Bnk0_hit,0,1,41,41,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk0_hit(_)
// which of bank 1's 32 lines to use
#define PKT_FLD_TEXSTUFFFIFO_Bnk1_entry(_) _(TEXSTUFFFIFO,Bnk1_entry,0,5,40,36,0x1f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk1_entry(_)
// bank 1 hit
#define PKT_FLD_TEXSTUFFFIFO_Bnk1_hit(_) _(TEXSTUFFFIFO,Bnk1_hit,0,1,35,35,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk1_hit(_)
// which of bank 2's 32 lines to use
#define PKT_FLD_TEXSTUFFFIFO_Bnk2_entry(_) _(TEXSTUFFFIFO,Bnk2_entry,0,5,34,30,0x1f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk2_entry(_)
// bank 2 hit
#define PKT_FLD_TEXSTUFFFIFO_Bnk2_hit(_) _(TEXSTUFFFIFO,Bnk2_hit,0,1,29,29,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk2_hit(_)
// which of bank 3's 32 lines to use
#define PKT_FLD_TEXSTUFFFIFO_Bnk3_entry(_) _(TEXSTUFFFIFO,Bnk3_entry,0,5,28,24,0x1f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk3_entry(_)
// bank 3 hit
#define PKT_FLD_TEXSTUFFFIFO_Bnk3_hit(_) _(TEXSTUFFFIFO,Bnk3_hit,0,1,23,23,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_Bnk3_hit(_)
// bank miss 0&2 served by same DMC cycle
#define PKT_FLD_TEXSTUFFFIFO_merge_bnk02(_) _(TEXSTUFFFIFO,merge_bnk02,0,1,22,22,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_merge_bnk02(_)
// bank miss 1&3 served by same DMC cycle
#define PKT_FLD_TEXSTUFFFIFO_merge_bnk13(_) _(TEXSTUFFFIFO,merge_bnk13,0,1,21,21,0x1,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_merge_bnk13(_)
// pixel instruction
#define PKT_FLD_TEXSTUFFFIFO_instr(_) _(TEXSTUFFFIFO,instr,0,14,20,7,0x3fff,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_instr(_)
// bottom few bits of integer S and T.
#define PKT_FLD_TEXSTUFFFIFO_in_line_address(_) _(TEXSTUFFFIFO,in_line_address,0,7,6,0,0x7f,NOENM)
#define LIST_PKT_ENM_TEXSTUFFFIFO_in_line_address(_)

// Packet TEXRESULTFIFO
#define LIST_PKT_FLD_TEXRESULTFIFO(_) \
_(TEXRESULTFIFO,current_float) \
_(TEXRESULTFIFO,float_format) \
_(TEXRESULTFIFO,sloc) \
_(TEXRESULTFIFO,tloc) \
_(TEXRESULTFIFO,data)
#define PKT_TEXRESULTFIFO(_) _(TEXRESULTFIFO,43,FLD)
//says data was a float
#define PKT_FLD_TEXRESULTFIFO_current_float(_) _(TEXRESULTFIFO,current_float,0,1,42,42,0x1,NOENM)
#define LIST_PKT_ENM_TEXRESULTFIFO_current_float(_)
//float format
#define PKT_FLD_TEXRESULTFIFO_float_format(_) _(TEXRESULTFIFO,float_format,0,6,41,36,0x3f,NOENM)
#define LIST_PKT_ENM_TEXRESULTFIFO_float_format(_)
//used to decide dest of pix
#define PKT_FLD_TEXRESULTFIFO_sloc(_) _(TEXRESULTFIFO,sloc,0,2,35,34,0x3,NOENM)
#define LIST_PKT_ENM_TEXRESULTFIFO_sloc(_)
//used to decide dest of pix
#define PKT_FLD_TEXRESULTFIFO_tloc(_) _(TEXRESULTFIFO,tloc,0,2,33,32,0x3,NOENM)
#define LIST_PKT_ENM_TEXRESULTFIFO_tloc(_)
//pixel or reg data
#define PKT_FLD_TEXRESULTFIFO_data(_) _(TEXRESULTFIFO,data,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_TEXRESULTFIFO_data(_)
// this communicates the semi-unpacked texel data between the texture cache
// and NV_GRDF_TEX_FORMAT_cnv.  the packet has to hold 4b-32b texels as
// well as DXT1 and possible DXT3/DXT5 data.

// Packet TEX_RAWTEX
#define LIST_PKT_FLD_TEX_RAWTEX(_) \
_(TEX_RAWTEX,RAW4) \
_(TEX_RAWTEX,RAW8) \
_(TEX_RAWTEX,RAW16) \
_(TEX_RAWTEX,RAW32) \
_(TEX_RAWTEX,COLOR0) \
_(TEX_RAWTEX,COLOR1) \
_(TEX_RAWTEX,RGB_IDX) \
_(TEX_RAWTEX,DXT1) \
_(TEX_RAWTEX,A_DXT3) \
_(TEX_RAWTEX,DXT3) \
_(TEX_RAWTEX,A_IDX) \
_(TEX_RAWTEX,A1LESS) \
_(TEX_RAWTEX,ALOWER) \
_(TEX_RAWTEX,ADELTA) \
_(TEX_RAWTEX,DXT5) \
_(TEX_RAWTEX,ETC_S1_R1_INDIV) \
_(TEX_RAWTEX,ETC_S1_G1_INDIV) \
_(TEX_RAWTEX,ETC_S1_B1_INDIV) \
_(TEX_RAWTEX,ETC_S2_R2_INDIV) \
_(TEX_RAWTEX,ETC_S2_G2_INDIV) \
_(TEX_RAWTEX,ETC_S2_B2_INDIV) \
_(TEX_RAWTEX,ETC_S1_R1_DIFF) \
_(TEX_RAWTEX,ETC_S1_G1_DIFF) \
_(TEX_RAWTEX,ETC_S1_B1_DIFF) \
_(TEX_RAWTEX,ETC_S2_DR2_DIFF) \
_(TEX_RAWTEX,ETC_S2_DG2_DIFF) \
_(TEX_RAWTEX,ETC_S2_DB2_DIFF) \
_(TEX_RAWTEX,ETC_FLIPBIT) \
_(TEX_RAWTEX,ETC_DIFF) \
_(TEX_RAWTEX,ETC_CW1) \
_(TEX_RAWTEX,ETC_CW2) \
_(TEX_RAWTEX,ETC_CW_M0) \
_(TEX_RAWTEX,ETC_CW_M1) \
_(TEX_RAWTEX,ETC_CW_M2) \
_(TEX_RAWTEX,ETC_CW_M3) \
_(TEX_RAWTEX,ETC) \
_(TEX_RAWTEX,ETC_COLOR) \
_(TEX_RAWTEX,ETC_PIXIDX_MSB) \
_(TEX_RAWTEX,ETC_PIXIDX_LSB) \
_(TEX_RAWTEX,ETC_SUBBLOCK) \
_(TEX_RAWTEX,ETC3_A) \
_(TEX_RAWTEX,ETC3) \
_(TEX_RAWTEX,ETC5_A_IDX) \
_(TEX_RAWTEX,ETC5_A1LESS) \
_(TEX_RAWTEX,ETC5_ALOWER) \
_(TEX_RAWTEX,ETC5_ADELTA) \
_(TEX_RAWTEX,ETC5) \
_(TEX_RAWTEX,A_IDX_1) \
_(TEX_RAWTEX,A1LESS_1) \
_(TEX_RAWTEX,ALOWER_1) \
_(TEX_RAWTEX,ADELTA_1)
#define PKT_TEX_RAWTEX(_) _(TEX_RAWTEX,60,FLD)
// just  4b texel
#define PKT_FLD_TEX_RAWTEX_RAW4(_) _(TEX_RAWTEX,RAW4,0,4,3,0,0xf,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_RAW4(_)
// just  8b texel
#define PKT_FLD_TEX_RAWTEX_RAW8(_) _(TEX_RAWTEX,RAW8,0,8,7,0,0xff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_RAW8(_)
// just 16b texel
#define PKT_FLD_TEX_RAWTEX_RAW16(_) _(TEX_RAWTEX,RAW16,0,16,15,0,0xffff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_RAW16(_)
// just 32b texel
#define PKT_FLD_TEX_RAWTEX_RAW32(_) _(TEX_RAWTEX,RAW32,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_RAW32(_)
// DXT low color
#define PKT_FLD_TEX_RAWTEX_COLOR0(_) _(TEX_RAWTEX,COLOR0,0,16,15,0,0xffff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_COLOR0(_)
// DXT high color
#define PKT_FLD_TEX_RAWTEX_COLOR1(_) _(TEX_RAWTEX,COLOR1,0,16,31,16,0xffff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_COLOR1(_)
// DXT RGB interpolation index
#define PKT_FLD_TEX_RAWTEX_RGB_IDX(_) _(TEX_RAWTEX,RGB_IDX,0,2,33,32,0x3,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_RGB_IDX(_)
// all bits needed for DXT1
#define PKT_FLD_TEX_RAWTEX_DXT1(_) _(TEX_RAWTEX,DXT1,0,34,33,0,0x3,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_DXT1(_)
// DXT3 4b alpha
#define PKT_FLD_TEX_RAWTEX_A_DXT3(_) _(TEX_RAWTEX,A_DXT3,0,4,37,34,0xf,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_A_DXT3(_)
// all bits needed for DXT3
#define PKT_FLD_TEX_RAWTEX_DXT3(_) _(TEX_RAWTEX,DXT3,0,38,37,0,0x3f,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_DXT3(_)
// DXT5 alpha interpolation index
#define PKT_FLD_TEX_RAWTEX_A_IDX(_) _(TEX_RAWTEX,A_IDX,0,3,36,34,0x7,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_A_IDX(_)
// DXT5 alpha1 < alpha0
#define PKT_FLD_TEX_RAWTEX_A1LESS(_) _(TEX_RAWTEX,A1LESS,0,1,37,37,0x1,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_A1LESS(_)
// DXT5 lesser of alpha0 and alpha1
#define PKT_FLD_TEX_RAWTEX_ALOWER(_) _(TEX_RAWTEX,ALOWER,0,8,45,38,0xff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ALOWER(_)
// DXT5 abs(alpha0-alpha1)
#define PKT_FLD_TEX_RAWTEX_ADELTA(_) _(TEX_RAWTEX,ADELTA,0,8,53,46,0xff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ADELTA(_)
// all bits needed for DXT5
#define PKT_FLD_TEX_RAWTEX_DXT5(_) _(TEX_RAWTEX,DXT5,0,54,53,0,0x3fffff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_DXT5(_)
//r1 for individual mode
#define PKT_FLD_TEX_RAWTEX_ETC_S1_R1_INDIV(_) _(TEX_RAWTEX,ETC_S1_R1_INDIV,0,4,31,28,0xf,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S1_R1_INDIV(_)
//g1 for individual mode
#define PKT_FLD_TEX_RAWTEX_ETC_S1_G1_INDIV(_) _(TEX_RAWTEX,ETC_S1_G1_INDIV,0,4,23,20,0xf,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S1_G1_INDIV(_)
//b1 for individual mode
#define PKT_FLD_TEX_RAWTEX_ETC_S1_B1_INDIV(_) _(TEX_RAWTEX,ETC_S1_B1_INDIV,0,4,15,12,0xf,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S1_B1_INDIV(_)
//r2 for subblock 2 individual mode
#define PKT_FLD_TEX_RAWTEX_ETC_S2_R2_INDIV(_) _(TEX_RAWTEX,ETC_S2_R2_INDIV,0,4,27,24,0xf,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S2_R2_INDIV(_)
//g2 for subblock 2 individual mode
#define PKT_FLD_TEX_RAWTEX_ETC_S2_G2_INDIV(_) _(TEX_RAWTEX,ETC_S2_G2_INDIV,0,4,19,16,0xf,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S2_G2_INDIV(_)
//b2 for subblock 2 individual mode
#define PKT_FLD_TEX_RAWTEX_ETC_S2_B2_INDIV(_) _(TEX_RAWTEX,ETC_S2_B2_INDIV,0,4,11,8,0xf,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S2_B2_INDIV(_)
//r1 for sub1 in diff mode
#define PKT_FLD_TEX_RAWTEX_ETC_S1_R1_DIFF(_) _(TEX_RAWTEX,ETC_S1_R1_DIFF,0,5,31,27,0x1f,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S1_R1_DIFF(_)
//g1 for sub1 in diff mode
#define PKT_FLD_TEX_RAWTEX_ETC_S1_G1_DIFF(_) _(TEX_RAWTEX,ETC_S1_G1_DIFF,0,5,23,19,0x1f,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S1_G1_DIFF(_)
//b1 for sub1 in diff mode
#define PKT_FLD_TEX_RAWTEX_ETC_S1_B1_DIFF(_) _(TEX_RAWTEX,ETC_S1_B1_DIFF,0,5,15,11,0x1f,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S1_B1_DIFF(_)
//dr2 for diff mode
#define PKT_FLD_TEX_RAWTEX_ETC_S2_DR2_DIFF(_) _(TEX_RAWTEX,ETC_S2_DR2_DIFF,0,3,26,24,0x7,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S2_DR2_DIFF(_)
//dg2 for diff mode
#define PKT_FLD_TEX_RAWTEX_ETC_S2_DG2_DIFF(_) _(TEX_RAWTEX,ETC_S2_DG2_DIFF,0,3,18,16,0x7,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S2_DG2_DIFF(_)
//db2 for diff mode
#define PKT_FLD_TEX_RAWTEX_ETC_S2_DB2_DIFF(_) _(TEX_RAWTEX,ETC_S2_DB2_DIFF,0,3,10,8,0x7,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_S2_DB2_DIFF(_)
//etc flip bit 0=2x4 1=4x2
#define PKT_FLD_TEX_RAWTEX_ETC_FLIPBIT(_) _(TEX_RAWTEX,ETC_FLIPBIT,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_FLIPBIT(_)
//etc diff bit 0 individual mode
#define PKT_FLD_TEX_RAWTEX_ETC_DIFF(_) _(TEX_RAWTEX,ETC_DIFF,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_DIFF(_)
//etc table 1 code word
#define PKT_FLD_TEX_RAWTEX_ETC_CW1(_) _(TEX_RAWTEX,ETC_CW1,0,3,7,5,0x7,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_CW1(_)
//etc tablle 2 code word
#define PKT_FLD_TEX_RAWTEX_ETC_CW2(_) _(TEX_RAWTEX,ETC_CW2,0,3,4,2,0x7,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_CW2(_)
//code word modifier 0
#define PKT_FLD_TEX_RAWTEX_ETC_CW_M0(_) _(TEX_RAWTEX,ETC_CW_M0,0,9,8,0,0x1ff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_CW_M0(_)
//code word modifier 1
#define PKT_FLD_TEX_RAWTEX_ETC_CW_M1(_) _(TEX_RAWTEX,ETC_CW_M1,0,9,17,9,0x1ff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_CW_M1(_)
//code word modifier 2
#define PKT_FLD_TEX_RAWTEX_ETC_CW_M2(_) _(TEX_RAWTEX,ETC_CW_M2,0,9,26,18,0x1ff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_CW_M2(_)
//code word modifier 3
#define PKT_FLD_TEX_RAWTEX_ETC_CW_M3(_) _(TEX_RAWTEX,ETC_CW_M3,0,9,35,27,0x1ff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_CW_M3(_)
//all bits needed for etc1
#define PKT_FLD_TEX_RAWTEX_ETC(_) _(TEX_RAWTEX,ETC,0,35,34,0,0x7,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC(_)
//where color data is
#define PKT_FLD_TEX_RAWTEX_ETC_COLOR(_) _(TEX_RAWTEX,ETC_COLOR,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_COLOR(_)
//pixel index msb
#define PKT_FLD_TEX_RAWTEX_ETC_PIXIDX_MSB(_) _(TEX_RAWTEX,ETC_PIXIDX_MSB,0,1,34,34,0x1,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_PIXIDX_MSB(_)
//pixel index lsb
#define PKT_FLD_TEX_RAWTEX_ETC_PIXIDX_LSB(_) _(TEX_RAWTEX,ETC_PIXIDX_LSB,0,1,33,33,0x1,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_PIXIDX_LSB(_)
//0 = 1 1 = 2
#define PKT_FLD_TEX_RAWTEX_ETC_SUBBLOCK(_) _(TEX_RAWTEX,ETC_SUBBLOCK,0,1,35,35,0x1,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC_SUBBLOCK(_)
//alpha for etc3
#define PKT_FLD_TEX_RAWTEX_ETC3_A(_) _(TEX_RAWTEX,ETC3_A,0,4,39,36,0xf,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC3_A(_)
//etc3 bits
#define PKT_FLD_TEX_RAWTEX_ETC3(_) _(TEX_RAWTEX,ETC3,0,40,39,0,0xff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC3(_)
// DXT5 alpha interpolation index
#define PKT_FLD_TEX_RAWTEX_ETC5_A_IDX(_) _(TEX_RAWTEX,ETC5_A_IDX,0,3,42,40,0x7,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC5_A_IDX(_)
// DXT5 alpha1 < alpha0
#define PKT_FLD_TEX_RAWTEX_ETC5_A1LESS(_) _(TEX_RAWTEX,ETC5_A1LESS,0,1,43,43,0x1,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC5_A1LESS(_)
// DXT5 lesser of alpha0 and alpha1
#define PKT_FLD_TEX_RAWTEX_ETC5_ALOWER(_) _(TEX_RAWTEX,ETC5_ALOWER,0,8,51,44,0xff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC5_ALOWER(_)
// DXT5 abs(alpha0-alpha1)
#define PKT_FLD_TEX_RAWTEX_ETC5_ADELTA(_) _(TEX_RAWTEX,ETC5_ADELTA,0,8,59,52,0xff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC5_ADELTA(_)
//etc5 bits
#define PKT_FLD_TEX_RAWTEX_ETC5(_) _(TEX_RAWTEX,ETC5,0,60,59,0,0xfffffff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ETC5(_)
// latc2 2nd alpha interpolation index
#define PKT_FLD_TEX_RAWTEX_A_IDX_1(_) _(TEX_RAWTEX,A_IDX_1,0,3,2,0,0x7,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_A_IDX_1(_)
// latc2 2nd alpha alpha1 < alpha0
#define PKT_FLD_TEX_RAWTEX_A1LESS_1(_) _(TEX_RAWTEX,A1LESS_1,0,1,3,3,0x1,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_A1LESS_1(_)
// latc 2nd alpha lesser of alpha0 and alpha1
#define PKT_FLD_TEX_RAWTEX_ALOWER_1(_) _(TEX_RAWTEX,ALOWER_1,0,8,11,4,0xff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ALOWER_1(_)
// latc2 2nd alpha abs(alpha0-alpha1)
#define PKT_FLD_TEX_RAWTEX_ADELTA_1(_) _(TEX_RAWTEX,ADELTA_1,0,8,19,12,0xff,NOENM)
#define LIST_PKT_ENM_TEX_RAWTEX_ADELTA_1(_)
// dependent variables -- don't change the stuff below
// number of bits required to hold pix address within T$ line.
// for 256b lines, tile ranges from 64x1 to 8x8
#define AR3D_TEX_INLINE_ADDR_SIZE       7
// enough for up to 256b cachelines
#define AR3D_TEX_INLINE_S_ADDR_SIZE     4
// S[3:0]
#define AR3D_TEX_INLINE_T_ADDR_SIZE     3
// S[6:4] or T[2:0]
// ========== GRDF FIFO DEFINITIONS ==========
// The GRDF latency hiding FIFOs are sized by these parameters below.
// Each is explained a bit before it is defined.  Keep in mind that the
// depth of the Z/C/TEX FIFOs is in terms of PIXPKT rows, which is not
// necessarily the same as a pixel.  Also, the memory system may be
// clocked at a different rate than nvclk, so the latencies of the
// two sides of the async interface need to be accounted for.  also,
// each request is for 128b of data, so if the memory controller is
// more narrow than that, each request occupies multiple mclk cycles.
// This defines the depth of the FIFO between the Z request and and the
// Z compare stages.  It has two purposes: the first purpose is to hold
// pixel information until the requested old Z value comes back from the
// DMC.  The second purpose is to provide some elasticity to the pipeline
// in case the downstream pipe stalls, allowing the Z stage to keep getting
// work done.
//
// In the worst case, there is one request made to the DMC for each pixel,
// and pixels may be processed on per clock.  More typically, there is one
// request each 6-8 pixels, and each pixel take two to four clocks.  In the
// worst case, the FIFO must be at least as deep as the DF_DMC_FIFO_DEPTH
// parameter; this sets the lower bound on the size.  For better
// performance, this FIFO should be bigger than that.
// it doesn't need to be this big, but it is the smallest ramgen can make
//define NV_DF_ZFIFO_DEPTH 64;
// This defines the depth of the FIFO between the C request and and the
// C update stages.  Its purpose is analagous to that of DF_ZFIFO_DEPTH,
// and the same reasoning applies.  However, its depth is independent
// of DF_ZFIFO_DEPTH, other than both are constrained to be at least as
// large as DF_DMC_FIFO_DEPTH.
// it doesn't need to be this big, but it is the smallest ramgen can make
//define NV_DF_CFIFO_DEPTH 64;
// This defines the depth of the FIFO between the TEX request stage and
// the TEX cache stage.  Because the TEX stage is given highest priority
// in the DMCIF, it doesn't need to be as deep as the Z and C FIFOs.
// Also, a pixel can result in one to eight DMC requests, so there is less
// need to have a multiple of the DMC_FIFO depth.
// it doesn't need to be this big, but it is the smallest ramgen can make
//define NV_TEX_TFIFO_DEPTH 64;
// tex inputfifo
//define TEX_INPUTFIFO_DEPTH 2;
//define TEX_INPUTFIFO_WIDTH 96;
// -------------------------------------------------------------------
//    GRALU stuff
// -------------------------------------------------------------------
// The programmer sees two 20b TEMP registers and four 20b CONST registers.
// The CONST registers can be referenced by all pixels, but the TEMP
// registers should only be referenced between the rows of one pixel for
// a given pass.  That is, imagine that the TEMP registers are invalidated
// before the first row of a given pass.
//
// In HW, there is a two-way interleave of pixels in the pipeline in order
// to hide the two-clock ALU computation latency so that the results of
// row N's computation can be written to the TEMP and used by row (N+1)'s
// computation.
// There are 4 constant registers in 2 banks for a pixel to use.  Only one
// bank of constants can be used at one time, and are selected by the BANK
// field of the alu INST0 register.   Constants are implemented using a
// single register for each and are not context switched like TEMP
// registers.  A single constant register is readable from either context,
// but can only be written using a register write.
//
// Constants are useful for holding constant values, but since they
// are not writable using the result of the ALU, they cannot forward
// values from one row of the instruction to the next.  A TEMP
// register should be used instead.
// -------------------------------------------------------------------
//    DWR stuff
// -------------------------------------------------------------------
#define DW_CACHE_LINE_SIZE      128
// used by cmod/dwr
// display use BGRA and dw now conforms.
// If there is code that uses RGBA, it should be corrected

// Packet DW_PAYLD
#define LIST_PKT_FLD_DW_PAYLD(_) \
_(DW_PAYLD,BLUE_0) \
_(DW_PAYLD,GREEN_0) \
_(DW_PAYLD,RED_0) \
_(DW_PAYLD,ALPHA_0) \
_(DW_PAYLD,RED_1) \
_(DW_PAYLD,GREEN_1) \
_(DW_PAYLD,BLUE_1) \
_(DW_PAYLD,ALPHA_1)
#define PKT_DW_PAYLD(_) _(DW_PAYLD,80,FLD)
#define PKT_FLD_DW_PAYLD_BLUE_0(_) _(DW_PAYLD,BLUE_0,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_DW_PAYLD_BLUE_0(_)
#define PKT_FLD_DW_PAYLD_GREEN_0(_) _(DW_PAYLD,GREEN_0,0,10,19,10,0x3ff,NOENM)
#define LIST_PKT_ENM_DW_PAYLD_GREEN_0(_)
#define PKT_FLD_DW_PAYLD_RED_0(_) _(DW_PAYLD,RED_0,0,10,29,20,0x3ff,NOENM)
#define LIST_PKT_ENM_DW_PAYLD_RED_0(_)
#define PKT_FLD_DW_PAYLD_ALPHA_0(_) _(DW_PAYLD,ALPHA_0,0,10,39,30,0x3ff,NOENM)
#define LIST_PKT_ENM_DW_PAYLD_ALPHA_0(_)
#define PKT_FLD_DW_PAYLD_RED_1(_) _(DW_PAYLD,RED_1,0,10,69,60,0x3ff,NOENM)
#define LIST_PKT_ENM_DW_PAYLD_RED_1(_)
#define PKT_FLD_DW_PAYLD_GREEN_1(_) _(DW_PAYLD,GREEN_1,0,10,59,50,0x3ff,NOENM)
#define LIST_PKT_ENM_DW_PAYLD_GREEN_1(_)
#define PKT_FLD_DW_PAYLD_BLUE_1(_) _(DW_PAYLD,BLUE_1,0,10,49,40,0x3ff,NOENM)
#define LIST_PKT_ENM_DW_PAYLD_BLUE_1(_)
#define PKT_FLD_DW_PAYLD_ALPHA_1(_) _(DW_PAYLD,ALPHA_1,0,10,79,70,0x3ff,NOENM)
#define LIST_PKT_ENM_DW_PAYLD_ALPHA_1(_)

// Packet DW_COLOR_FMT10
#define LIST_PKT_FLD_DW_COLOR_FMT10(_) \
_(DW_COLOR_FMT10,SIGN) \
_(DW_COLOR_FMT10,INT) \
_(DW_COLOR_FMT10,FRACTION) \
_(DW_COLOR_FMT10,COLOR)
#define PKT_DW_COLOR_FMT10(_) _(DW_COLOR_FMT10,10,FLD)
#define PKT_FLD_DW_COLOR_FMT10_SIGN(_) _(DW_COLOR_FMT10,SIGN,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_DW_COLOR_FMT10_SIGN(_)
#define PKT_FLD_DW_COLOR_FMT10_INT(_) _(DW_COLOR_FMT10,INT,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_DW_COLOR_FMT10_INT(_)
#define PKT_FLD_DW_COLOR_FMT10_FRACTION(_) _(DW_COLOR_FMT10,FRACTION,0,8,9,2,0xff,NOENM)
#define LIST_PKT_ENM_DW_COLOR_FMT10_FRACTION(_)
#define PKT_FLD_DW_COLOR_FMT10_COLOR(_) _(DW_COLOR_FMT10,COLOR,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_DW_COLOR_FMT10_COLOR(_)

// Packet DW_MEM_PKT
#define LIST_PKT_FLD_DW_MEM_PKT(_) \
_(DW_MEM_PKT,MEM_PAYLD_0) \
_(DW_MEM_PKT,MEM_PAYLD_1) \
_(DW_MEM_PKT,MEM_PAYLD_2) \
_(DW_MEM_PKT,MEM_PAYLD_3) \
_(DW_MEM_PKT,ADDR) \
_(DW_MEM_PKT,BE) \
_(DW_MEM_PKT,PKT_TYPE)
#define PKT_DW_MEM_PKT(_) _(DW_MEM_PKT,179,FLD)
#define PKT_FLD_DW_MEM_PKT_MEM_PAYLD_0(_) _(DW_MEM_PKT,MEM_PAYLD_0,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_DW_MEM_PKT_MEM_PAYLD_0(_)
#define PKT_FLD_DW_MEM_PKT_MEM_PAYLD_1(_) _(DW_MEM_PKT,MEM_PAYLD_1,0,32,63,32,0xffffffff,NOENM)
#define LIST_PKT_ENM_DW_MEM_PKT_MEM_PAYLD_1(_)
#define PKT_FLD_DW_MEM_PKT_MEM_PAYLD_2(_) _(DW_MEM_PKT,MEM_PAYLD_2,0,32,95,64,0xffffffff,NOENM)
#define LIST_PKT_ENM_DW_MEM_PKT_MEM_PAYLD_2(_)
#define PKT_FLD_DW_MEM_PKT_MEM_PAYLD_3(_) _(DW_MEM_PKT,MEM_PAYLD_3,0,32,127,96,0xffffffff,NOENM)
#define LIST_PKT_ENM_DW_MEM_PKT_MEM_PAYLD_3(_)
#define PKT_FLD_DW_MEM_PKT_ADDR(_) _(DW_MEM_PKT,ADDR,0,32,159,128,0xffffffff,NOENM)
#define LIST_PKT_ENM_DW_MEM_PKT_ADDR(_)
#define PKT_FLD_DW_MEM_PKT_BE(_) _(DW_MEM_PKT,BE,0,16,175,160,0xffff,NOENM)
#define LIST_PKT_ENM_DW_MEM_PKT_BE(_)
#define PKT_FLD_DW_MEM_PKT_PKT_TYPE(_) _(DW_MEM_PKT,PKT_TYPE,0,3,178,176,0x7,ENM)
#define LIST_PKT_ENM_DW_MEM_PKT_PKT_TYPE(_) \
_(DW_MEM_PKT,PKT_TYPE,CVAL,0) \
_(DW_MEM_PKT,PKT_TYPE,ZVAL,1)
// PS for pixel seen.  Include written, killed, skipped.

// Packet DW_SB_PKT
#define LIST_PKT_FLD_DW_SB_PKT(_) \
_(DW_SB_PKT,TYPE) \
_(DW_SB_PKT,MASK) \
_(DW_SB_PKT,HASH) \
_(DW_SB_PKT,VALID)
#define PKT_DW_SB_PKT(_) _(DW_SB_PKT,17,FLD)
#define PKT_FLD_DW_SB_PKT_TYPE(_) _(DW_SB_PKT,TYPE,0,3,16,14,0x7,ENM)
#define LIST_PKT_ENM_DW_SB_PKT_TYPE(_) \
_(DW_SB_PKT,TYPE,CVAL,0) \
_(DW_SB_PKT,TYPE,ZVAL,1) \
_(DW_SB_PKT,TYPE,BOTH,2) \
_(DW_SB_PKT,TYPE,PS,3) \
_(DW_SB_PKT,TYPE,RAISE,4)
// 4 Bit mask of valid pixel pairs
#define PKT_FLD_DW_SB_PKT_MASK(_) _(DW_SB_PKT,MASK,0,4,13,10,0xf,NOENM)
#define LIST_PKT_ENM_DW_SB_PKT_MASK(_)
// 7 bit hash address entry
#define PKT_FLD_DW_SB_PKT_HASH(_) _(DW_SB_PKT,HASH,0,9,9,1,0x1ff,NOENM)
#define LIST_PKT_ENM_DW_SB_PKT_HASH(_)
// data is valid
#define PKT_FLD_DW_SB_PKT_VALID(_) _(DW_SB_PKT,VALID,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_PKT_VALID(_)

// Packet DW_SB_PS_CACHE
#define LIST_PKT_FLD_DW_SB_PS_CACHE(_) \
_(DW_SB_PS_CACHE,PIX0) \
_(DW_SB_PS_CACHE,PIX1) \
_(DW_SB_PS_CACHE,PIX2) \
_(DW_SB_PS_CACHE,PIX3) \
_(DW_SB_PS_CACHE,PIX4) \
_(DW_SB_PS_CACHE,PIX5) \
_(DW_SB_PS_CACHE,PIX6) \
_(DW_SB_PS_CACHE,PIX7)
#define PKT_DW_SB_PS_CACHE(_) _(DW_SB_PS_CACHE,8,FLD)
#define PKT_FLD_DW_SB_PS_CACHE_PIX0(_) _(DW_SB_PS_CACHE,PIX0,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_PS_CACHE_PIX0(_)
#define PKT_FLD_DW_SB_PS_CACHE_PIX1(_) _(DW_SB_PS_CACHE,PIX1,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_PS_CACHE_PIX1(_)
#define PKT_FLD_DW_SB_PS_CACHE_PIX2(_) _(DW_SB_PS_CACHE,PIX2,0,1,2,2,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_PS_CACHE_PIX2(_)
#define PKT_FLD_DW_SB_PS_CACHE_PIX3(_) _(DW_SB_PS_CACHE,PIX3,0,1,3,3,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_PS_CACHE_PIX3(_)
#define PKT_FLD_DW_SB_PS_CACHE_PIX4(_) _(DW_SB_PS_CACHE,PIX4,0,1,4,4,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_PS_CACHE_PIX4(_)
#define PKT_FLD_DW_SB_PS_CACHE_PIX5(_) _(DW_SB_PS_CACHE,PIX5,0,1,5,5,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_PS_CACHE_PIX5(_)
#define PKT_FLD_DW_SB_PS_CACHE_PIX6(_) _(DW_SB_PS_CACHE,PIX6,0,1,6,6,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_PS_CACHE_PIX6(_)
#define PKT_FLD_DW_SB_PS_CACHE_PIX7(_) _(DW_SB_PS_CACHE,PIX7,0,1,7,7,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_PS_CACHE_PIX7(_)
// this is highly related to the SCOREBOARD_FLUSH packet type.  it used to
// be that DWR internally used the same type, but when it was generalized
// very late in the sc15 design cycle to handle 8b to 32b pixels and not
// just 16b pixels, the pixel pair mask had to be grown.  there wasn't time
// to change the rest of the design, so internally DWR has a fifo with
// the wide pixel masks that a small state machine breaks down into chunks
// that GRGK already knows how to deal with.
//

// Packet DW_SBFIFO
#define LIST_PKT_FLD_DW_SBFIFO(_) \
_(DW_SBFIFO,WRITE_C) \
_(DW_SBFIFO,WRITE_Z) \
_(DW_SBFIFO,MASK) \
_(DW_SBFIFO,HASH_Y) \
_(DW_SBFIFO,HASH_X)
#define PKT_DW_SBFIFO(_) _(DW_SBFIFO,18,FLD)
// color surface was written
#define PKT_FLD_DW_SBFIFO_WRITE_C(_) _(DW_SBFIFO,WRITE_C,0,1,17,17,0x1,NOENM)
#define LIST_PKT_ENM_DW_SBFIFO_WRITE_C(_)
// depth surface was written
#define PKT_FLD_DW_SBFIFO_WRITE_Z(_) _(DW_SBFIFO,WRITE_Z,0,1,16,16,0x1,NOENM)
#define LIST_PKT_ENM_DW_SBFIFO_WRITE_Z(_)
// 8 bit mask of valid pixel pairs
#define PKT_FLD_DW_SBFIFO_MASK(_) _(DW_SBFIFO,MASK,0,8,15,8,0xff,NOENM)
#define LIST_PKT_ENM_DW_SBFIFO_MASK(_)
// y[4:0] part of it
#define PKT_FLD_DW_SBFIFO_HASH_Y(_) _(DW_SBFIFO,HASH_Y,0,5,7,3,0x1f,NOENM)
#define LIST_PKT_ENM_DW_SBFIFO_HASH_Y(_)
// x[6:4] part of it; x[3] is recovered from mask
#define PKT_FLD_DW_SBFIFO_HASH_X(_) _(DW_SBFIFO,HASH_X,0,3,2,0,0x7,NOENM)
#define LIST_PKT_ENM_DW_SBFIFO_HASH_X(_)
// PR for pair

// Packet DW_SB_MASK
#define LIST_PKT_FLD_DW_SB_MASK(_) \
_(DW_SB_MASK,PR0) \
_(DW_SB_MASK,PR1) \
_(DW_SB_MASK,PR2) \
_(DW_SB_MASK,PR3)
#define PKT_DW_SB_MASK(_) _(DW_SB_MASK,4,FLD)
#define PKT_FLD_DW_SB_MASK_PR0(_) _(DW_SB_MASK,PR0,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_MASK_PR0(_)
#define PKT_FLD_DW_SB_MASK_PR1(_) _(DW_SB_MASK,PR1,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_MASK_PR1(_)
#define PKT_FLD_DW_SB_MASK_PR2(_) _(DW_SB_MASK,PR2,0,1,2,2,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_MASK_PR2(_)
#define PKT_FLD_DW_SB_MASK_PR3(_) _(DW_SB_MASK,PR3,0,1,3,3,0x1,NOENM)
#define LIST_PKT_ENM_DW_SB_MASK_PR3(_)

// Packet FAKE_VID_PIXEL
#define LIST_PKT_FLD_FAKE_VID_PIXEL(_) \
_(FAKE_VID_PIXEL,CMD) \
_(FAKE_VID_PIXEL,X) \
_(FAKE_VID_PIXEL,Y) \
_(FAKE_VID_PIXEL,RED) \
_(FAKE_VID_PIXEL,GREEN) \
_(FAKE_VID_PIXEL,BLUE)
#define PKT_FAKE_VID_PIXEL(_) _(FAKE_VID_PIXEL,54,FLD)
#define PKT_FLD_FAKE_VID_PIXEL_CMD(_) _(FAKE_VID_PIXEL,CMD,0,2,1,0,0x3,ENM)
#define LIST_PKT_ENM_FAKE_VID_PIXEL_CMD(_) \
_(FAKE_VID_PIXEL,CMD,PIX,0) \
_(FAKE_VID_PIXEL,CMD,LASTH_PIX,1) \
_(FAKE_VID_PIXEL,CMD,LASTV_PIX,2)
#define PKT_FLD_FAKE_VID_PIXEL_X(_) _(FAKE_VID_PIXEL,X,0,14,15,2,0x3fff,NOENM)
#define LIST_PKT_ENM_FAKE_VID_PIXEL_X(_)
#define PKT_FLD_FAKE_VID_PIXEL_Y(_) _(FAKE_VID_PIXEL,Y,0,14,29,16,0x3fff,NOENM)
#define LIST_PKT_ENM_FAKE_VID_PIXEL_Y(_)
#define PKT_FLD_FAKE_VID_PIXEL_RED(_) _(FAKE_VID_PIXEL,RED,0,8,37,30,0xff,NOENM)
#define LIST_PKT_ENM_FAKE_VID_PIXEL_RED(_)
#define PKT_FLD_FAKE_VID_PIXEL_GREEN(_) _(FAKE_VID_PIXEL,GREEN,0,8,45,38,0xff,NOENM)
#define LIST_PKT_ENM_FAKE_VID_PIXEL_GREEN(_)
#define PKT_FLD_FAKE_VID_PIXEL_BLUE(_) _(FAKE_VID_PIXEL,BLUE,0,8,53,46,0xff,NOENM)
#define LIST_PKT_ENM_FAKE_VID_PIXEL_BLUE(_)
//
// Internal packet definitions for geometry interfaces
//
// Much of this is tied to the nv46 definitions
//
// HACK HACK HACK - the log2() defines don't want to pass through...
//#define IBB    NV_GR3D_VPE_IBUF_BITS
//#define OBB    NV_GR3D_VPE_OBUF_BITS
//#define IBRB   NV_GR3D_VPE_IBUF_RAM_BITS
//#define OBRB   NV_GR3D_VPE_OBUF_RAM_BITS
//#define VRB    NV_GR3D_VPE_RAMBITS
// OK, we'll do this the hard way...
#define IBUF_BITS       3
#define OBUF_BITS       4
#define IBUF_RAM_BITS   6
#define OBUF_RAM_BITS   6
// idx2clip interface - host traffic inbound to rest of pipe

// Packet IDX2CLIP
#define LIST_PKT_FLD_IDX2CLIP(_) \
_(IDX2CLIP,DATA) \
_(IDX2CLIP,ADDR) \
_(IDX2CLIP,READ) \
_(IDX2CLIP,CHANNEL)
#define PKT_IDX2CLIP(_) _(IDX2CLIP,49,FLD)
// register write data or read result data
#define PKT_FLD_IDX2CLIP_DATA(_) _(IDX2CLIP,DATA,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_IDX2CLIP_DATA(_)
// register address
#define PKT_FLD_IDX2CLIP_ADDR(_) _(IDX2CLIP,ADDR,0,12,43,32,0xfff,NOENM)
#define LIST_PKT_ENM_IDX2CLIP_ADDR(_)
// transaction type, read=1, write=0
#define PKT_FLD_IDX2CLIP_READ(_) _(IDX2CLIP,READ,0,1,44,44,0x1,NOENM)
#define LIST_PKT_ENM_IDX2CLIP_READ(_)
// host channel ID (for RAISE/REFCNT/READ)
#define PKT_FLD_IDX2CLIP_CHANNEL(_) _(IDX2CLIP,CHANNEL,0,4,48,45,0xf,NOENM)
#define LIST_PKT_ENM_IDX2CLIP_CHANNEL(_)
// pseq2idx interface - host traffic outbound from rest of pipe

// Packet PSEQ2IDX
#define LIST_PKT_FLD_PSEQ2IDX(_) \
_(PSEQ2IDX,DATA) \
_(PSEQ2IDX,CHANNEL) \
_(PSEQ2IDX,TYPE)
#define PKT_PSEQ2IDX(_) _(PSEQ2IDX,38,FLD)
// read data
#define PKT_FLD_PSEQ2IDX_DATA(_) _(PSEQ2IDX,DATA,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_PSEQ2IDX_DATA(_)
// destination channel
#define PKT_FLD_PSEQ2IDX_CHANNEL(_) _(PSEQ2IDX,CHANNEL,0,4,35,32,0xf,NOENM)
#define LIST_PKT_ENM_PSEQ2IDX_CHANNEL(_)
// response type
#define PKT_FLD_PSEQ2IDX_TYPE(_) _(PSEQ2IDX,TYPE,0,2,37,36,0x3,ENM)
#define LIST_PKT_ENM_PSEQ2IDX_TYPE(_) \
_(PSEQ2IDX,TYPE,READ,0) \
_(PSEQ2IDX,TYPE,RAISE,1) \
_(PSEQ2IDX,TYPE,REFCNT,2)
// idx2vpe packet - attribute data and VPE state, plus some other stuff

// Packet IDX2VPE
#define LIST_PKT_FLD_IDX2VPE(_) \
_(IDX2VPE,DATA_0) \
_(IDX2VPE,DATA_1) \
_(IDX2VPE,DATA_2) \
_(IDX2VPE,DATA_3) \
_(IDX2VPE,ADDR) \
_(IDX2VPE,VALID) \
_(IDX2VPE,MASK) \
_(IDX2VPE,VABCTXADDR) \
_(IDX2VPE,COMMAND) \
_(IDX2VPE,LAUNCH) \
_(IDX2VPE,PRI_DEBUG) \
_(IDX2VPE,PRI_CTRL) \
_(IDX2VPE,OBUF_AVAIL) \
_(IDX2VPE,STEN)
#define PKT_IDX2VPE(_) _(IDX2VPE,190,FLD)
// x component, insn 127:96, or bundle ID
#define PKT_FLD_IDX2VPE_DATA_0(_) _(IDX2VPE,DATA_0,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_IDX2VPE_DATA_0(_)
// y component, insn  95:64, or bundle data
#define PKT_FLD_IDX2VPE_DATA_1(_) _(IDX2VPE,DATA_1,0,32,63,32,0xffffffff,NOENM)
#define LIST_PKT_ENM_IDX2VPE_DATA_1(_)
// z component, insn  63:32
#define PKT_FLD_IDX2VPE_DATA_2(_) _(IDX2VPE,DATA_2,0,32,95,64,0xffffffff,NOENM)
#define LIST_PKT_ENM_IDX2VPE_DATA_2(_)
// w component, insn  31:0
#define PKT_FLD_IDX2VPE_DATA_3(_) _(IDX2VPE,DATA_3,0,32,127,96,0xffffffff,NOENM)
#define LIST_PKT_ENM_IDX2VPE_DATA_3(_)
// IBUF RAM address
#define PKT_FLD_IDX2VPE_ADDR(_) _(IDX2VPE,ADDR,0,6,133,128,0x3f,NOENM)
#define LIST_PKT_ENM_IDX2VPE_ADDR(_)
// IBUF load valid
#define PKT_FLD_IDX2VPE_VALID(_) _(IDX2VPE,VALID,0,1,134,134,0x1,NOENM)
#define LIST_PKT_ENM_IDX2VPE_VALID(_)
// write enable mask, or ibuf slot(2:0)
#define PKT_FLD_IDX2VPE_MASK(_) _(IDX2VPE,MASK,0,4,138,135,0xf,NOENM)
#define LIST_PKT_ENM_IDX2VPE_MASK(_)
// const/insn/bundle addr, or obuf slot(2:0)
#define PKT_FLD_IDX2VPE_VABCTXADDR(_) _(IDX2VPE,VABCTXADDR,0,8,146,139,0xff,NOENM)
#define LIST_PKT_ENM_IDX2VPE_VABCTXADDR(_)
// transform cmd
#define PKT_FLD_IDX2VPE_COMMAND(_) _(IDX2VPE,COMMAND,0,5,151,147,0x1f,ENM)
#define LIST_PKT_ENM_IDX2VPE_COMMAND(_) \
_(IDX2VPE,COMMAND,NOP,0) \
_(IDX2VPE,COMMAND,VAB,1) \
_(IDX2VPE,COMMAND,XFPR,2) \
_(IDX2VPE,COMMAND,PASSTHR,5) \
_(IDX2VPE,COMMAND,CONST,11)
// command bus is valid (launch if VAB)
#define PKT_FLD_IDX2VPE_LAUNCH(_) _(IDX2VPE,LAUNCH,0,1,152,152,0x1,NOENM)
#define LIST_PKT_ENM_IDX2VPE_LAUNCH(_)
// debug register settings
#define PKT_FLD_IDX2VPE_PRI_DEBUG(_) _(IDX2VPE,PRI_DEBUG,0,8,160,153,0xff,NOENM)
#define LIST_PKT_ENM_IDX2VPE_PRI_DEBUG(_)
// thread controls
#define PKT_FLD_IDX2VPE_PRI_CTRL(_) _(IDX2VPE,PRI_CTRL,0,12,172,161,0xfff,NOENM)
#define LIST_PKT_ENM_IDX2VPE_PRI_CTRL(_)
// clear OBUF in-use flag
#define PKT_FLD_IDX2VPE_OBUF_AVAIL(_) _(IDX2VPE,OBUF_AVAIL,0,16,188,173,0xffff,NOENM)
#define LIST_PKT_ENM_IDX2VPE_OBUF_AVAIL(_)
// stat collection enable
#define PKT_FLD_IDX2VPE_STEN(_) _(IDX2VPE,STEN,0,1,189,189,0x1,NOENM)
#define LIST_PKT_ENM_IDX2VPE_STEN(_)
// VPE bundle addresses (passed in DATA_0)
#define VPE_GE_PROGRAM_CTRL_BUNDLE      204
#define VPE_ATTRIBINPUTMASK_BUNDLE      205
#define VPE_ATTRIBOUTPUTMASK_BUNDLE     206
#define VPE_GEOM_STALL_BUNDLE   224
#define VPE_GE_PROGRAM_TIMEOUT_BUNDLE   227
#define VPE_GE_CONST_LIMITS_BUNDLE      231
#define VPE_BRANCHBITS_BUNDLE   237
#define VPE_PIPE_NOP_BUNDLE     497
// VPE bundle layouts for non-trival bundles...

// Packet VPE_GE_PROGRAM_CTRL
#define LIST_PKT_FLD_VPE_GE_PROGRAM_CTRL(_) \
_(VPE_GE_PROGRAM_CTRL,PROGRAM_START) \
_(VPE_GE_PROGRAM_CTRL,SIGNED_ZERO_COMPARE) \
_(VPE_GE_PROGRAM_CTRL,MODE)
#define PKT_VPE_GE_PROGRAM_CTRL(_) _(VPE_GE_PROGRAM_CTRL,32,FLD)
#define PKT_FLD_VPE_GE_PROGRAM_CTRL_PROGRAM_START(_) _(VPE_GE_PROGRAM_CTRL,PROGRAM_START,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_VPE_GE_PROGRAM_CTRL_PROGRAM_START(_)
#define PKT_FLD_VPE_GE_PROGRAM_CTRL_SIGNED_ZERO_COMPARE(_) _(VPE_GE_PROGRAM_CTRL,SIGNED_ZERO_COMPARE,0,1,27,27,0x1,ENM)
#define LIST_PKT_ENM_VPE_GE_PROGRAM_CTRL_SIGNED_ZERO_COMPARE(_) \
_(VPE_GE_PROGRAM_CTRL,SIGNED_ZERO_COMPARE,UNEQUAL,0) \
_(VPE_GE_PROGRAM_CTRL,SIGNED_ZERO_COMPARE,EQUAL,1)
#define PKT_FLD_VPE_GE_PROGRAM_CTRL_MODE(_) _(VPE_GE_PROGRAM_CTRL,MODE,0,2,31,30,0x3,ENM)
#define LIST_PKT_ENM_VPE_GE_PROGRAM_CTRL_MODE(_) \
_(VPE_GE_PROGRAM_CTRL,MODE,FIXED,0) \
_(VPE_GE_PROGRAM_CTRL,MODE,PROGRAM,2) \
_(VPE_GE_PROGRAM_CTRL,MODE,PROGRAM_V2,3) \
_(VPE_GE_PROGRAM_CTRL,MODE,PROGRAM_V3,1)

// Packet VPE_GEOM_STALL
#define LIST_PKT_FLD_VPE_GEOM_STALL(_) \
_(VPE_GEOM_STALL,STALL) \
_(VPE_GEOM_STALL,FLUSH)
#define PKT_VPE_GEOM_STALL(_) _(VPE_GEOM_STALL,17,FLD)
#define PKT_FLD_VPE_GEOM_STALL_STALL(_) _(VPE_GEOM_STALL,STALL,0,8,7,0,0xff,NOENM)
#define LIST_PKT_ENM_VPE_GEOM_STALL_STALL(_)
#define PKT_FLD_VPE_GEOM_STALL_FLUSH(_) _(VPE_GEOM_STALL,FLUSH,0,1,16,16,0x1,NOENM)
#define LIST_PKT_ENM_VPE_GEOM_STALL_FLUSH(_)

// Packet VPE_GE_PROGRAM_TIMEOUT
#define LIST_PKT_FLD_VPE_GE_PROGRAM_TIMEOUT(_) \
_(VPE_GE_PROGRAM_TIMEOUT,COUNT) \
_(VPE_GE_PROGRAM_TIMEOUT,REGISTER_COUNT)
#define PKT_VPE_GE_PROGRAM_TIMEOUT(_) _(VPE_GE_PROGRAM_TIMEOUT,17,FLD)
#define PKT_FLD_VPE_GE_PROGRAM_TIMEOUT_COUNT(_) _(VPE_GE_PROGRAM_TIMEOUT,COUNT,0,16,15,0,0xffff,NOENM)
#define LIST_PKT_ENM_VPE_GE_PROGRAM_TIMEOUT_COUNT(_)
#define PKT_FLD_VPE_GE_PROGRAM_TIMEOUT_REGISTER_COUNT(_) _(VPE_GE_PROGRAM_TIMEOUT,REGISTER_COUNT,0,1,16,16,0x1,ENM)
#define LIST_PKT_ENM_VPE_GE_PROGRAM_TIMEOUT_REGISTER_COUNT(_) \
_(VPE_GE_PROGRAM_TIMEOUT,REGISTER_COUNT,RC32,0) \
_(VPE_GE_PROGRAM_TIMEOUT,REGISTER_COUNT,RC48,1)

// Packet VPE_GE_CONST_LIMITS
#define LIST_PKT_FLD_VPE_GE_CONST_LIMITS(_) \
_(VPE_GE_CONST_LIMITS,MIN) \
_(VPE_GE_CONST_LIMITS,MAX)
#define PKT_VPE_GE_CONST_LIMITS(_) _(VPE_GE_CONST_LIMITS,26,FLD)
#define PKT_FLD_VPE_GE_CONST_LIMITS_MIN(_) _(VPE_GE_CONST_LIMITS,MIN,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_VPE_GE_CONST_LIMITS_MIN(_)
#define PKT_FLD_VPE_GE_CONST_LIMITS_MAX(_) _(VPE_GE_CONST_LIMITS,MAX,0,10,25,16,0x3ff,NOENM)
#define LIST_PKT_ENM_VPE_GE_CONST_LIMITS_MAX(_)
// vpe2idx interface - reference counts and status

// Packet VPE2IDX
#define LIST_PKT_FLD_VPE2IDX(_) \
_(VPE2IDX,IDLE) \
_(VPE2IDX,RETIRE_MODE) \
_(VPE2IDX,RETIRE_VALID) \
_(VPE2IDX,RETIRE_IBUF)
#define PKT_VPE2IDX(_) _(VPE2IDX,7,FLD)
// All IBUFs free and fifo empty
#define PKT_FLD_VPE2IDX_IDLE(_) _(VPE2IDX,IDLE,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_VPE2IDX_IDLE(_)
// Decrement mode counter by 0/1/2
#define PKT_FLD_VPE2IDX_RETIRE_MODE(_) _(VPE2IDX,RETIRE_MODE,0,2,2,1,0x3,NOENM)
#define LIST_PKT_ENM_VPE2IDX_RETIRE_MODE(_)
// RETIRE_IBUF signal is valid
#define PKT_FLD_VPE2IDX_RETIRE_VALID(_) _(VPE2IDX,RETIRE_VALID,0,1,3,3,0x1,NOENM)
#define LIST_PKT_ENM_VPE2IDX_RETIRE_VALID(_)
// Retire this IBUF
#define PKT_FLD_VPE2IDX_RETIRE_IBUF(_) _(VPE2IDX,RETIRE_IBUF,0,3,6,4,0x7,NOENM)
#define LIST_PKT_ENM_VPE2IDX_RETIRE_IBUF(_)
// idx2vpe_readaddr interface - const/iram read requests

// Packet IDX2VPE_READADDR
#define LIST_PKT_FLD_IDX2VPE_READADDR(_) \
_(IDX2VPE_READADDR,ADDR) \
_(IDX2VPE_READADDR,WHICH)
#define PKT_IDX2VPE_READADDR(_) _(IDX2VPE_READADDR,9,FLD)
// address
#define PKT_FLD_IDX2VPE_READADDR_ADDR(_) _(IDX2VPE_READADDR,ADDR,0,8,7,0,0xff,NOENM)
#define LIST_PKT_ENM_IDX2VPE_READADDR_ADDR(_)
// which ram to read
#define PKT_FLD_IDX2VPE_READADDR_WHICH(_) _(IDX2VPE_READADDR,WHICH,0,1,8,8,0x1,ENM)
#define LIST_PKT_ENM_IDX2VPE_READADDR_WHICH(_) \
_(IDX2VPE_READADDR,WHICH,CONST,0) \
_(IDX2VPE_READADDR,WHICH,INSN,1)
// vpe2idx_readdata - const/iram read response

// Packet VPE2IDX_READDATA
#define LIST_PKT_FLD_VPE2IDX_READDATA(_) \
_(VPE2IDX_READDATA,DATA)
#define PKT_VPE2IDX_READDATA(_) _(VPE2IDX_READDATA,128,FLD)
// read result from const/insn ram
#define PKT_FLD_VPE2IDX_READDATA_DATA(_) _(VPE2IDX_READDATA,DATA,0,128,127,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_VPE2IDX_READDATA_DATA(_)
// clip2idx interface - reference counts

// Packet CLIP2IDX
#define LIST_PKT_FLD_CLIP2IDX(_) \
_(CLIP2IDX,CULL) \
_(CLIP2IDX,READ)
#define PKT_CLIP2IDX(_) _(CLIP2IDX,32,FLD)
// decrement counter for obufs due to cull
#define PKT_FLD_CLIP2IDX_CULL(_) _(CLIP2IDX,CULL,0,16,15,0,0xffff,NOENM)
#define LIST_PKT_ENM_CLIP2IDX_CULL(_)
// decrement counter for obufs due to pos. read
#define PKT_FLD_CLIP2IDX_READ(_) _(CLIP2IDX,READ,0,16,31,16,0xffff,NOENM)
#define LIST_PKT_ENM_CLIP2IDX_READ(_)
// vpe2clip interface - reference counts

// Packet VPE2CLIP
#define LIST_PKT_FLD_VPE2CLIP(_) \
_(VPE2CLIP,DONE) \
_(VPE2CLIP,OBUF_STRIDE)
#define PKT_VPE2CLIP(_) _(VPE2CLIP,9,FLD)
// thread completed for this obuf
#define PKT_FLD_VPE2CLIP_DONE(_) _(VPE2CLIP,DONE,0,4,3,0,0xf,NOENM)
#define LIST_PKT_ENM_VPE2CLIP_DONE(_)
// obuf size in attributes
#define PKT_FLD_VPE2CLIP_OBUF_STRIDE(_) _(VPE2CLIP,OBUF_STRIDE,0,5,8,4,0x1f,NOENM)
#define LIST_PKT_ENM_VPE2CLIP_OBUF_STRIDE(_)
// this is the unified position/attribute bus instead of seperate as in nv4x
// clip2vpe_attraddr interface

// Packet CLIP2VPE_ATTRADDR
#define LIST_PKT_FLD_CLIP2VPE_ATTRADDR(_) \
_(CLIP2VPE_ATTRADDR,READADDR) \
_(CLIP2VPE_ATTRADDR,OBUFADDR) \
_(CLIP2VPE_ATTRADDR,POS_VALID)
#define PKT_CLIP2VPE_ATTRADDR(_) _(CLIP2VPE_ATTRADDR,11,FLD)
// OBUF ram address to read (attr or pos)
#define PKT_FLD_CLIP2VPE_ATTRADDR_READADDR(_) _(CLIP2VPE_ATTRADDR,READADDR,0,6,5,0,0x3f,NOENM)
#define LIST_PKT_ENM_CLIP2VPE_ATTRADDR_READADDR(_)
// OBUF slot to read (if POS_VALID)
#define PKT_FLD_CLIP2VPE_ATTRADDR_OBUFADDR(_) _(CLIP2VPE_ATTRADDR,OBUFADDR,0,4,9,6,0xf,NOENM)
#define LIST_PKT_ENM_CLIP2VPE_ATTRADDR_OBUFADDR(_)
// If true, reading position (attribute 0)
#define PKT_FLD_CLIP2VPE_ATTRADDR_POS_VALID(_) _(CLIP2VPE_ATTRADDR,POS_VALID,0,1,10,10,0x1,NOENM)
#define LIST_PKT_ENM_CLIP2VPE_ATTRADDR_POS_VALID(_)
// vpe2clip_attrdata interface

// Packet VPE2CLIP_ATTRDATA
#define LIST_PKT_FLD_VPE2CLIP_ATTRDATA(_) \
_(VPE2CLIP_ATTRDATA,ATTR_0) \
_(VPE2CLIP_ATTRDATA,ATTR_1) \
_(VPE2CLIP_ATTRDATA,ATTR_2) \
_(VPE2CLIP_ATTRDATA,ATTR_3) \
_(VPE2CLIP_ATTRDATA,WRITTEN) \
_(VPE2CLIP_ATTRDATA,ATTRIBUTES) \
_(VPE2CLIP_ATTRDATA,POS_VALID)
#define PKT_VPE2CLIP_ATTRDATA(_) _(VPE2CLIP_ATTRDATA,149,FLD)
// attribute x component
#define PKT_FLD_VPE2CLIP_ATTRDATA_ATTR_0(_) _(VPE2CLIP_ATTRDATA,ATTR_0,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_VPE2CLIP_ATTRDATA_ATTR_0(_)
// attribute y component
#define PKT_FLD_VPE2CLIP_ATTRDATA_ATTR_1(_) _(VPE2CLIP_ATTRDATA,ATTR_1,0,32,63,32,0xffffffff,NOENM)
#define LIST_PKT_ENM_VPE2CLIP_ATTRDATA_ATTR_1(_)
// attribute z component
#define PKT_FLD_VPE2CLIP_ATTRDATA_ATTR_2(_) _(VPE2CLIP_ATTRDATA,ATTR_2,0,32,95,64,0xffffffff,NOENM)
#define LIST_PKT_ENM_VPE2CLIP_ATTRDATA_ATTR_2(_)
// attribute w component
#define PKT_FLD_VPE2CLIP_ATTRDATA_ATTR_3(_) _(VPE2CLIP_ATTRDATA,ATTR_3,0,32,127,96,0xffffffff,NOENM)
#define LIST_PKT_ENM_VPE2CLIP_ATTRDATA_ATTR_3(_)
// which components were written (only valid if attribute was written)
#define PKT_FLD_VPE2CLIP_ATTRDATA_WRITTEN(_) _(VPE2CLIP_ATTRDATA,WRITTEN,0,4,131,128,0xf,NOENM)
#define LIST_PKT_ENM_VPE2CLIP_ATTRDATA_WRITTEN(_)
// which attributes were written (only valid if pos_valid set)
#define PKT_FLD_VPE2CLIP_ATTRDATA_ATTRIBUTES(_) _(VPE2CLIP_ATTRDATA,ATTRIBUTES,0,16,147,132,0xffff,NOENM)
#define LIST_PKT_ENM_VPE2CLIP_ATTRDATA_ATTRIBUTES(_)
// this was a position read
#define PKT_FLD_VPE2CLIP_ATTRDATA_POS_VALID(_) _(VPE2CLIP_ATTRDATA,POS_VALID,0,1,148,148,0x1,NOENM)
#define LIST_PKT_ENM_VPE2CLIP_ATTRDATA_POS_VALID(_)
// -------------------------------------------------------------------
//    SC25 stuff
// -------------------------------------------------------------------
//below are the PAYLOADs for PIXSHDRPKT

// Packet PIXSHADERPKT
#define LIST_PKT_FLD_PIXSHADERPKT(_) \
_(PIXSHADERPKT,STATE) \
_(PIXSHADERPKT,DBG) \
_(PIXSHADERPKT,PAYLOAD)
#define PKT_PIXSHADERPKT(_) _(PIXSHADERPKT,100,FLD)
// previously the kill code, now a packet state
#define PKT_FLD_PIXSHADERPKT_STATE(_) _(PIXSHADERPKT,STATE,0,3,99,97,0x7,ENM)
#define LIST_PKT_ENM_PIXSHADERPKT_STATE(_) \
_(PIXSHADERPKT,STATE,REGISTER,0) \
_(PIXSHADERPKT,STATE,SPANSTART,1) \
_(PIXSHADERPKT,STATE,Z_PASS,2) \
_(PIXSHADERPKT,STATE,Z_FAIL,3) \
_(PIXSHADERPKT,STATE,S_FAIL,4) \
_(PIXSHADERPKT,STATE,KILL,5) \
_(PIXSHADERPKT,STATE,NON_CENTER,6)
// debug bit.  set based on conditions and
//      INSTRUMENT.STAT_EN used to filter debug/stats
#define PKT_FLD_PIXSHADERPKT_DBG(_) _(PIXSHADERPKT,DBG,0,1,96,96,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_DBG(_)
// contains fields for PIXSHADERPKT_PIX,
// PIXSHADERPKT_SPAN, or PIXSHADERPKT_REG.
#define PKT_FLD_PIXSHADERPKT_PAYLOAD(_) _(PIXSHADERPKT,PAYLOAD,0,96,95,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PAYLOAD(_)
//
//below are the different shader packet types
//
// PIXELS

// Packet PIXSHADERPKT_PIX
#define LIST_PKT_FLD_PIXSHADERPKT_PIX(_) \
_(PIXSHADERPKT_PIX,STATE) \
_(PIXSHADERPKT_PIX,DBG) \
_(PIXSHADERPKT_PIX,INTERLEAVE) \
_(PIXSHADERPKT_PIX,SEQ) \
_(PIXSHADERPKT_PIX,SB) \
_(PIXSHADERPKT_PIX,CX) \
_(PIXSHADERPKT_PIX,VCAA) \
_(PIXSHADERPKT_PIX,PREDICATE) \
_(PIXSHADERPKT_PIX,DELTA) \
_(PIXSHADERPKT_PIX,RASTER) \
_(PIXSHADERPKT_PIX,R0) \
_(PIXSHADERPKT_PIX,R0_HI) \
_(PIXSHADERPKT_PIX,R0_LO) \
_(PIXSHADERPKT_PIX,R1) \
_(PIXSHADERPKT_PIX,R1_HI) \
_(PIXSHADERPKT_PIX,R1_LO) \
_(PIXSHADERPKT_PIX,R2) \
_(PIXSHADERPKT_PIX,R2_HI) \
_(PIXSHADERPKT_PIX,R2_LO) \
_(PIXSHADERPKT_PIX,R3) \
_(PIXSHADERPKT_PIX,R3_HI) \
_(PIXSHADERPKT_PIX,R3_LO)
#define PKT_PIXSHADERPKT_PIX(_) _(PIXSHADERPKT_PIX,100,FLD)
// previously the kill code, now a packet state
#define PKT_FLD_PIXSHADERPKT_PIX_STATE(_) _(PIXSHADERPKT_PIX,STATE,0,3,99,97,0x7,ENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_STATE(_) \
_(PIXSHADERPKT_PIX,STATE,Z_PASS,2) \
_(PIXSHADERPKT_PIX,STATE,Z_FAIL,3) \
_(PIXSHADERPKT_PIX,STATE,S_FAIL,4) \
_(PIXSHADERPKT_PIX,STATE,KILL,5) \
_(PIXSHADERPKT_PIX,STATE,NON_CENTER,6)
// DBG bit (used for filtering debug and stats)
#define PKT_FLD_PIXSHADERPKT_PIX_DBG(_) _(PIXSHADERPKT_PIX,DBG,0,1,96,96,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_DBG(_)
// Which pixel of the quad does this packet
// ,-------.    belong to.
// | 0 | 1 |
// |---+---|
// | 2 | 3 |
// `-------'
#define PKT_FLD_PIXSHADERPKT_PIX_INTERLEAVE(_) _(PIXSHADERPKT_PIX,INTERLEAVE,0,2,95,94,0x3,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_INTERLEAVE(_)
// Sequence number -- used to index instruction
// tables or remap tables
#define PKT_FLD_PIXSHADERPKT_PIX_SEQ(_) _(PIXSHADERPKT_PIX,SEQ,0,6,93,88,0x3f,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_SEQ(_)
// set if this pixel is scoreboarded (and needs to
// clear the scoreboard when killed).
#define PKT_FLD_PIXSHADERPKT_PIX_SB(_) _(PIXSHADERPKT_PIX,SB,0,1,87,87,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_SB(_)
// bit which is used for conditional execute
#define PKT_FLD_PIXSHADERPKT_PIX_CX(_) _(PIXSHADERPKT_PIX,CX,0,1,86,86,0x1,ENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_CX(_) \
_(PIXSHADERPKT_PIX,CX,EXECUTE,0) \
_(PIXSHADERPKT_PIX,CX,NO_EXECUTE,1)
// VCAA bits for the first row of the pixel
#define PKT_FLD_PIXSHADERPKT_PIX_VCAA(_) _(PIXSHADERPKT_PIX,VCAA,0,4,85,82,0xf,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_VCAA(_)
// predicate bits for all but the first row
// of the pixel
#define PKT_FLD_PIXSHADERPKT_PIX_PREDICATE(_) _(PIXSHADERPKT_PIX,PREDICATE,0,4,85,82,0xf,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_PREDICATE(_)
// provides dx and dy for next quad
// dy[4:3] comes from interleave 0
// dy[2:1] comes from interleave 1
// dx[4:3] comes from interleave 2
// dx[2:1] comes from interleave 3
#define PKT_FLD_PIXSHADERPKT_PIX_DELTA(_) _(PIXSHADERPKT_PIX,DELTA,0,2,81,80,0x3,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_DELTA(_)
// register fields
#define PKT_FLD_PIXSHADERPKT_PIX_RASTER(_) _(PIXSHADERPKT_PIX,RASTER,0,80,79,0,0xffff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_RASTER(_)
//FP20
#define PKT_FLD_PIXSHADERPKT_PIX_R0(_) _(PIXSHADERPKT_PIX,R0,0,20,19,0,0xfffff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R0(_)
//FX10
#define PKT_FLD_PIXSHADERPKT_PIX_R0_HI(_) _(PIXSHADERPKT_PIX,R0_HI,0,10,19,10,0x3ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R0_HI(_)
//FX10
#define PKT_FLD_PIXSHADERPKT_PIX_R0_LO(_) _(PIXSHADERPKT_PIX,R0_LO,0,10,9,0,0x3ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R0_LO(_)
//FP20
#define PKT_FLD_PIXSHADERPKT_PIX_R1(_) _(PIXSHADERPKT_PIX,R1,0,20,39,20,0xfffff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R1(_)
//FX10
#define PKT_FLD_PIXSHADERPKT_PIX_R1_HI(_) _(PIXSHADERPKT_PIX,R1_HI,0,10,39,30,0x3ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R1_HI(_)
//FX10
#define PKT_FLD_PIXSHADERPKT_PIX_R1_LO(_) _(PIXSHADERPKT_PIX,R1_LO,0,10,29,20,0x3ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R1_LO(_)
//FP20
#define PKT_FLD_PIXSHADERPKT_PIX_R2(_) _(PIXSHADERPKT_PIX,R2,0,20,59,40,0xfffff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R2(_)
//FX10
#define PKT_FLD_PIXSHADERPKT_PIX_R2_HI(_) _(PIXSHADERPKT_PIX,R2_HI,0,10,59,50,0x3ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R2_HI(_)
//FX10
#define PKT_FLD_PIXSHADERPKT_PIX_R2_LO(_) _(PIXSHADERPKT_PIX,R2_LO,0,10,49,40,0x3ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R2_LO(_)
//FP20
#define PKT_FLD_PIXSHADERPKT_PIX_R3(_) _(PIXSHADERPKT_PIX,R3,0,20,79,60,0xfffff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R3(_)
//FX10
#define PKT_FLD_PIXSHADERPKT_PIX_R3_HI(_) _(PIXSHADERPKT_PIX,R3_HI,0,10,79,70,0x3ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R3_HI(_)
//FX10
#define PKT_FLD_PIXSHADERPKT_PIX_R3_LO(_) _(PIXSHADERPKT_PIX,R3_LO,0,10,69,60,0x3ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_PIX_R3_LO(_)
//
// SPANSTARTS

// Packet PIXSHADERPKT_SPAN
#define LIST_PKT_FLD_PIXSHADERPKT_SPAN(_) \
_(PIXSHADERPKT_SPAN,STATE) \
_(PIXSHADERPKT_SPAN,DBG) \
_(PIXSHADERPKT_SPAN,SEQ) \
_(PIXSHADERPKT_SPAN,QID) \
_(PIXSHADERPKT_SPAN,HEAD) \
_(PIXSHADERPKT_SPAN,SPILL) \
_(PIXSHADERPKT_SPAN,FACE) \
_(PIXSHADERPKT_SPAN,TRI_ID) \
_(PIXSHADERPKT_SPAN,SPAN_X) \
_(PIXSHADERPKT_SPAN,SPAN_Y)
#define PKT_PIXSHADERPKT_SPAN(_) _(PIXSHADERPKT_SPAN,100,FLD)
// previously the kill code, now a packet state
#define PKT_FLD_PIXSHADERPKT_SPAN_STATE(_) _(PIXSHADERPKT_SPAN,STATE,0,3,99,97,0x7,ENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_STATE(_) \
_(PIXSHADERPKT_SPAN,STATE,SPANSTART,1)
// DBG bit (used for filtering debug and stats)
#define PKT_FLD_PIXSHADERPKT_SPAN_DBG(_) _(PIXSHADERPKT_SPAN,DBG,0,1,96,96,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_DBG(_)
// sequence # what is the seq for the first row
// of pixels to follow
#define PKT_FLD_PIXSHADERPKT_SPAN_SEQ(_) _(PIXSHADERPKT_SPAN,SEQ,0,6,93,88,0x3f,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_SEQ(_)
// Quad Identifier for the next pixel quad.
// Unique for each quad in the
// pseq->dw loop and used by ST/LD_R20 and
// ST/LD_R80 addressing.
// should have a value between 0 and PSEQ_CTL.fMAX_QID.
#define PKT_FLD_PIXSHADERPKT_SPAN_QID(_) _(PIXSHADERPKT_SPAN,QID,0,8,43,36,0xff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_QID(_)
// bit to indicate the oldest spanstart in the pipe
#define PKT_FLD_PIXSHADERPKT_SPAN_HEAD(_) _(PIXSHADERPKT_SPAN,HEAD,0,1,34,34,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_HEAD(_)
// bit to indicate if dw should spill this and
// following pixels
#define PKT_FLD_PIXSHADERPKT_SPAN_SPILL(_) _(PIXSHADERPKT_SPAN,SPILL,0,1,33,33,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_SPILL(_)
// bit to indicate if triangle is front or back facing
#define PKT_FLD_PIXSHADERPKT_SPAN_FACE(_) _(PIXSHADERPKT_SPAN,FACE,0,1,32,32,0x1,ENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_FACE(_) \
_(PIXSHADERPKT_SPAN,FACE,FRONT,0) \
_(PIXSHADERPKT_SPAN,FACE,BACK,1)
// which tri
// used by atrast for tram lookup, and pseq
// for quad count update to qr
// span_x and span_y provide x,y for the
// next pixel quad.
#define PKT_FLD_PIXSHADERPKT_SPAN_TRI_ID(_) _(PIXSHADERPKT_SPAN,TRI_ID,0,6,29,24,0x3f,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_TRI_ID(_)
// x<11: 1> = SPAN_X, x< 0: 0> = 0
#define PKT_FLD_PIXSHADERPKT_SPAN_SPAN_X(_) _(PIXSHADERPKT_SPAN,SPAN_X,0,11,21,11,0x7ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_SPAN_X(_)
// y<11: 1> = SPAN_Y, y< 0: 0> = 0
#define PKT_FLD_PIXSHADERPKT_SPAN_SPAN_Y(_) _(PIXSHADERPKT_SPAN,SPAN_Y,0,11,10,0,0x7ff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_SPAN_SPAN_Y(_)
//
// REGISTERS

// Packet PIXSHADERPKT_REG
#define LIST_PKT_FLD_PIXSHADERPKT_REG(_) \
_(PIXSHADERPKT_REG,STATE) \
_(PIXSHADERPKT_REG,DBG) \
_(PIXSHADERPKT_REG,DATA1) \
_(PIXSHADERPKT_REG,CHANNEL) \
_(PIXSHADERPKT_REG,DATA1_WR_EN) \
_(PIXSHADERPKT_REG,READ) \
_(PIXSHADERPKT_REG,DW_ST) \
_(PIXSHADERPKT_REG,BLK_NUM) \
_(PIXSHADERPKT_REG,BLK_ADDR) \
_(PIXSHADERPKT_REG,ADDR) \
_(PIXSHADERPKT_REG,DATA)
#define PKT_PIXSHADERPKT_REG(_) _(PIXSHADERPKT_REG,100,FLD)
// Packet state
#define PKT_FLD_PIXSHADERPKT_REG_STATE(_) _(PIXSHADERPKT_REG,STATE,0,3,99,97,0x7,ENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_STATE(_) \
_(PIXSHADERPKT_REG,STATE,REGISTER,0)
// DBG bit (used for filtering debug and stats)
#define PKT_FLD_PIXSHADERPKT_REG_DBG(_) _(PIXSHADERPKT_REG,DBG,0,1,96,96,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_DBG(_)
// extra data written to ADDR if DATA1_WR_EN is set
#define PKT_FLD_PIXSHADERPKT_REG_DATA1(_) _(PIXSHADERPKT_REG,DATA1,0,32,87,56,0xffffffff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_DATA1(_)
// channel for register transaction (needed for
// RAISE/REFCNT writes as well as reads!)
#define PKT_FLD_PIXSHADERPKT_REG_CHANNEL(_) _(PIXSHADERPKT_REG,CHANNEL,0,4,51,48,0xf,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_CHANNEL(_)
// set if data1 has register data to write
#define PKT_FLD_PIXSHADERPKT_REG_DATA1_WR_EN(_) _(PIXSHADERPKT_REG,DATA1_WR_EN,0,1,47,47,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_DATA1_WR_EN(_)
// set for register reads
#define PKT_FLD_PIXSHADERPKT_REG_READ(_) _(PIXSHADERPKT_REG,READ,0,1,46,46,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_READ(_)
// set if dw stores register reads (P1 feature)
#define PKT_FLD_PIXSHADERPKT_REG_DW_ST(_) _(PIXSHADERPKT_REG,DW_ST,0,1,44,44,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_DW_ST(_)
// bits that point at the block
#define PKT_FLD_PIXSHADERPKT_REG_BLK_NUM(_) _(PIXSHADERPKT_REG,BLK_NUM,0,4,43,40,0xf,ENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_BLK_NUM(_) \
_(PIXSHADERPKT_REG,BLK_NUM,CTL,0) \
_(PIXSHADERPKT_REG,BLK_NUM,IDX,1) \
_(PIXSHADERPKT_REG,BLK_NUM,VPE,2) \
_(PIXSHADERPKT_REG,BLK_NUM,SU,3) \
_(PIXSHADERPKT_REG,BLK_NUM,QR,4) \
_(PIXSHADERPKT_REG,BLK_NUM,PSEQ,5) \
_(PIXSHADERPKT_REG,BLK_NUM,AT,6) \
_(PIXSHADERPKT_REG,BLK_NUM,TEX,7) \
_(PIXSHADERPKT_REG,BLK_NUM,ALU,8) \
_(PIXSHADERPKT_REG,BLK_NUM,DW,9) \
_(PIXSHADERPKT_REG,BLK_NUM,FDC,10) \
_(PIXSHADERPKT_REG,BLK_NUM,GLB1,14) \
_(PIXSHADERPKT_REG,BLK_NUM,GLB2,15)
// offset within the block
#define PKT_FLD_PIXSHADERPKT_REG_BLK_ADDR(_) _(PIXSHADERPKT_REG,BLK_ADDR,0,8,39,32,0xff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_BLK_ADDR(_)
// whole address
#define PKT_FLD_PIXSHADERPKT_REG_ADDR(_) _(PIXSHADERPKT_REG,ADDR,0,12,43,32,0xfff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_ADDR(_)
// read/write data
#define PKT_FLD_PIXSHADERPKT_REG_DATA(_) _(PIXSHADERPKT_REG,DATA,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_REG_DATA(_)
//------- NON W NORMALIZED BARY DEFINITIONS----------------//
// DCDX/DCDY width is 18 (NV_GR3D_XRES_LOG2) + 1 (SIGN) + 4 (SNAP) + 1 (OVERFLOW)
#define BARY_DC_WIDTH   18
#define BARY_C_WIDTH    37
//------- W NORMALIZED BARY DEFINITIONS----------------//
// 4 bits of magic needed to account for W factor in DC
//#define BARY_W_C_WIDTH_I (2*BARY_W_DC_WIDTH_I + 1)
#define BARY_W_DC_WIDTH 22
#define BARY_W_C_WIDTH  38
//---------------------------------------------------------//
// QRAST slopes RAM stuff
#define QRAST_SL_RAM_WIDTH      228
//------- CUBEMAP FACE DEFINITIONS -------//
// The cube flattens like this:
//   2
// 1 4 0 5
//   3
//
//define CUBEMAP_FACE_POSITIVE_X   0;
//define CUBEMAP_FACE_NEGATIVE_X   1;
//define CUBEMAP_FACE_POSITIVE_Y   2;
//define CUBEMAP_FACE_NEGATIVE_Y   3;
//define CUBEMAP_FACE_POSITIVE_Z   4;
//define CUBEMAP_FACE_NEGATIVE_Z   5;
// three bit field to encode the above values
//define CUBEMAP_FACE_SIZE  3;

// Packet CUBEMAP_FACE
#define LIST_PKT_FLD_CUBEMAP_FACE(_) \
_(CUBEMAP_FACE,FACE)
#define PKT_CUBEMAP_FACE(_) _(CUBEMAP_FACE,3,FLD)
//cubemap
#define PKT_FLD_CUBEMAP_FACE_FACE(_) _(CUBEMAP_FACE,FACE,0,3,2,0,0x7,ENM)
#define LIST_PKT_ENM_CUBEMAP_FACE_FACE(_) \
_(CUBEMAP_FACE,FACE,POSITIVE_X,0) \
_(CUBEMAP_FACE,FACE,NEGATIVE_X,1) \
_(CUBEMAP_FACE,FACE,POSITIVE_Y,2) \
_(CUBEMAP_FACE,FACE,NEGATIVE_Y,3) \
_(CUBEMAP_FACE,FACE,POSITIVE_Z,4) \
_(CUBEMAP_FACE,FACE,NEGATIVE_Z,5)
// -------------------------------------------------------------------
//    FDC stuff
// -------------------------------------------------------------------
// some general defines for FDC
// For qrast clients. qrast latency hiding FIFO is 64 deep.
#define NV_FDC_PSEQ_CLIENT_LATENCY      32
#define NV_FDC_CLIENT_LATENCY   150
// defines in ar3d_fdc.spec
// --------------------------------------------------------------------------
//
// Copyright (c) 2005, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
// 
// This file has all the internal packet definitions related to FDC unit in AR20
// This file is included by ar3d_internal.spec
// Internal FDC defines
//
//      Misc. MC bus sizes.
// 
//
//      defines for vmod/cmod
//
#define NV_FDC_MC_AW    32
#define NV_FDC_MC_WDLOG2        5
#define NV_FDC_MC_MW    256
#define NV_FDC_ADDR_WIDTH       29
#define NV_FDC_DATA_WIDTH       64
#define NV_FDC_BE_WIDTH 8
#define NV_FDC_OFFS_WIDTH       2
#define NV_FDC_TAG_WIDTH        27
//      SPLIT MC accesses between SRAM/DRAM or odd/even
#define NV_FDC_USE_SPLIT_MC_ODD_EVEN    0
//      DRAM/SRAM
//      ODD/EVEN
// 0 -> even=xt  /  odd=int
// 1 -> even=int /  odd=xt
//      chose which one we want in RTL or C-model based on 
//      NV_FDC_SPLIT_MC_ODD_EVEN (unless register to program)
#define NV_FDC_XMEM_SPLITBIT    26
#define NV_FDC_XMEM_SELECT      0
#define NV_FDC_ODD_EVEN_SPLITBIT        0
#define NV_FDC_ODD_EVEN_SELECT  0
//
// scoreboard packet for fdc
//   QUAD_X - 10 bits.
//   QUAD_Y - 10 bits.
//   MASK - 4 bit pixel mask. [2][2]
//
// Need those defines
//
//      L2 defines
//
#define NV_FDC_L2_SIZE  32768
#define NV_FDC_L2_LINE_SIZE     256
#define NV_FDC_L2_LINES 128
#define NV_FDC_L2_SETS  1
#define NV_FDC_L2_WAYS  128
#define NV_FDC_L2_MEM_COLUMNS   4
#define NV_FDC_L2_MEM_SEGMENTS  2
#define NV_FDC_L2_MEM_SEGMENTS_LOG2     1
#define NV_FDC_L2_MEM_BANKS     8
// bit-width of max reads count per read_clean L2 line before 
// dirty line is marked as clean
//define NV_FDC_READ_CLEAN_CNT_WIDTH     NV_FDC_OFFS_WIDTH
#define NV_FDC_READ_CLEAN_CNT_WIDTH     1
//      PRNG for random line replacement uses primitive polynomials with 
//      sequence length 2^n - 1.
//      Polynomial:
//      P(x) = C(n)*x^n + C(n-1)*x^(n-1) + C(n-2)*x^(n-2) + ... + C(1)*x^1 + C(0)*x^0
//      (C(n) and C(0) are 1)
//      written as C(n)C(n-1),,,C(1)
//      n = 16  10001000000001011 [16,12,3,1,0]
//
//      LFSR implementation:
//      need to convert simple polynomial into modular polynomial (=flip)
//      n = 16  11010000000010001 [16,15,13,4,0] = pol[16:0]
//
//      fb = lfsr[n-1] (lfsr[n-1]*pol[n])       // pol[n] always 1
//      lfsr[n-1] = lfsr[n-2] + fb*pol[n-1] 
//      lfsr[n-2] = lfsr[n-3] + fb*pol[n-2] 
//      ...
//      lfsr[1]   = lfsr[0]   + fb*pol[1] 
//      lfsr[0]   =           + fb (fb*pol[0])  // pol[0] always 1
// polynomials:
// LFSR size
#define NV_FDC_REPL_LFSR_SIZE   16
#define NV_FDC_REPL_POL 106513
//
//      L1 defines
//
//
//      ADDRESS packet: Tag/Offset. shared between all FDC L1 packets
//

// Packet NV_FDC_REQ_ADDRESS
#define LIST_PKT_FLD_NV_FDC_REQ_ADDRESS(_) \
_(NV_FDC_REQ_ADDRESS,TAG) \
_(NV_FDC_REQ_ADDRESS,OFFSET)
#define PKT_NV_FDC_REQ_ADDRESS(_) _(NV_FDC_REQ_ADDRESS,29,FLD)
#define PKT_FLD_NV_FDC_REQ_ADDRESS_TAG(_) _(NV_FDC_REQ_ADDRESS,TAG,0,27,28,2,0x7ffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_REQ_ADDRESS_TAG(_)
#define PKT_FLD_NV_FDC_REQ_ADDRESS_OFFSET(_) _(NV_FDC_REQ_ADDRESS,OFFSET,0,2,1,0,0x3,NOENM)
#define LIST_PKT_ENM_NV_FDC_REQ_ADDRESS_OFFSET(_)
//      2.) maximum requests per 64 bit address
#define NV_FDC_L1RREQ_MAXREQ    4
#define NV_FDC_L1RREQ_MAXREQ_CNT_WIDTH  2
//
//      3.) Pending queue FIFO defines
//      3a.) FIFO depths & widths (read only)
//           Write pend Q is only 2 deep (for pipelining)
//#define FDC_L1RREQ_QFIFO_DEPTH          8
//#define FDC_L1RREQ_QFIFO_DEPTH          ((FDC_CLIENT_LATENCY+3)/4)
//#define FDC_L1RREQ_QFIFO_DEPTH          ((FDC_CLIENT_LATENCY+3)>>2)
#define NV_FDC_L1RREQ_SV_QFIFO_DEPTH    38
#define NV_FDC_L1RREQ_Z_QFIFO_DEPTH     75
#define NV_FDC_L1RREQ_P_QFIFO_DEPTH     32
//      3b.) Packet for L1 read pending queue

// Packet NV_FDC_L1RREQ_PENDQUEUE
#define LIST_PKT_FLD_NV_FDC_L1RREQ_PENDQUEUE(_) \
_(NV_FDC_L1RREQ_PENDQUEUE,RELEASE) \
_(NV_FDC_L1RREQ_PENDQUEUE,REQ_MODE) \
_(NV_FDC_L1RREQ_PENDQUEUE,LINE_MODE) \
_(NV_FDC_L1RREQ_PENDQUEUE,REG_ENC_ADDRESS) \
_(NV_FDC_L1RREQ_PENDQUEUE,LINE) \
_(NV_FDC_L1RREQ_PENDQUEUE,OFFSET) \
_(NV_FDC_L1RREQ_PENDQUEUE,COUNT)
#define PKT_NV_FDC_L1RREQ_PENDQUEUE(_) _(NV_FDC_L1RREQ_PENDQUEUE,13,FLD)
#define PKT_FLD_NV_FDC_L1RREQ_PENDQUEUE_RELEASE(_) _(NV_FDC_L1RREQ_PENDQUEUE,RELEASE,0,1,12,12,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1RREQ_PENDQUEUE_RELEASE(_)
#define PKT_FLD_NV_FDC_L1RREQ_PENDQUEUE_REQ_MODE(_) _(NV_FDC_L1RREQ_PENDQUEUE,REQ_MODE,0,1,11,11,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_L1RREQ_PENDQUEUE_REQ_MODE(_) \
_(NV_FDC_L1RREQ_PENDQUEUE,REQ_MODE,PIXEL,0) \
_(NV_FDC_L1RREQ_PENDQUEUE,REQ_MODE,REGISTER,1)
// register address encode address packet overlap
#define PKT_FLD_NV_FDC_L1RREQ_PENDQUEUE_LINE_MODE(_) _(NV_FDC_L1RREQ_PENDQUEUE,LINE_MODE,0,1,11,11,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_L1RREQ_PENDQUEUE_LINE_MODE(_) \
_(NV_FDC_L1RREQ_PENDQUEUE,LINE_MODE,L64BIT,0) \
_(NV_FDC_L1RREQ_PENDQUEUE,LINE_MODE,L128BIT,1)
#define PKT_FLD_NV_FDC_L1RREQ_PENDQUEUE_REG_ENC_ADDRESS(_) _(NV_FDC_L1RREQ_PENDQUEUE,REG_ENC_ADDRESS,0,9,10,2,0x1ff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1RREQ_PENDQUEUE_REG_ENC_ADDRESS(_)
#define PKT_FLD_NV_FDC_L1RREQ_PENDQUEUE_LINE(_) _(NV_FDC_L1RREQ_PENDQUEUE,LINE,0,7,10,4,0x7f,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1RREQ_PENDQUEUE_LINE(_)
#define PKT_FLD_NV_FDC_L1RREQ_PENDQUEUE_OFFSET(_) _(NV_FDC_L1RREQ_PENDQUEUE,OFFSET,0,2,3,2,0x3,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1RREQ_PENDQUEUE_OFFSET(_)
#define PKT_FLD_NV_FDC_L1RREQ_PENDQUEUE_COUNT(_) _(NV_FDC_L1RREQ_PENDQUEUE,COUNT,0,2,1,0,0x3,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1RREQ_PENDQUEUE_COUNT(_)
//      3b.) Packet for L1 write pending queue
#define NV_FDC_L1WREQ_PENDQUEUE_BE_BASE 75
#define NV_FDC_L1WREQ_PENDQUEUE_DATA_BASE       11

// Packet NV_FDC_L1WREQ_PENDQUEUE
#define LIST_PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE(_) \
_(NV_FDC_L1WREQ_PENDQUEUE,BE) \
_(NV_FDC_L1WREQ_PENDQUEUE,REG_DATA) \
_(NV_FDC_L1WREQ_PENDQUEUE,DATA) \
_(NV_FDC_L1WREQ_PENDQUEUE,RELEASE) \
_(NV_FDC_L1WREQ_PENDQUEUE,REQ_MODE) \
_(NV_FDC_L1WREQ_PENDQUEUE,LINE_MODE) \
_(NV_FDC_L1WREQ_PENDQUEUE,REG_ENC_ADDRESS) \
_(NV_FDC_L1WREQ_PENDQUEUE,LINE) \
_(NV_FDC_L1WREQ_PENDQUEUE,OFFSET)
#define PKT_NV_FDC_L1WREQ_PENDQUEUE(_) _(NV_FDC_L1WREQ_PENDQUEUE,83,FLD)
// register data overlap
#define PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE_BE(_) _(NV_FDC_L1WREQ_PENDQUEUE,BE,0,8,82,75,0xff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQ_PENDQUEUE_BE(_)
#define PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE_REG_DATA(_) _(NV_FDC_L1WREQ_PENDQUEUE,REG_DATA,0,32,42,11,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQ_PENDQUEUE_REG_DATA(_)
#define PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE_DATA(_) _(NV_FDC_L1WREQ_PENDQUEUE,DATA,0,64,74,11,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQ_PENDQUEUE_DATA(_)
//these 2 overlap
#define PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE_RELEASE(_) _(NV_FDC_L1WREQ_PENDQUEUE,RELEASE,0,1,10,10,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQ_PENDQUEUE_RELEASE(_)
#define PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE_REQ_MODE(_) _(NV_FDC_L1WREQ_PENDQUEUE,REQ_MODE,0,1,9,9,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQ_PENDQUEUE_REQ_MODE(_) \
_(NV_FDC_L1WREQ_PENDQUEUE,REQ_MODE,PIXEL,0) \
_(NV_FDC_L1WREQ_PENDQUEUE,REQ_MODE,REGISTER,1)
// register address encode address packet overlap
#define PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE_LINE_MODE(_) _(NV_FDC_L1WREQ_PENDQUEUE,LINE_MODE,0,1,9,9,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQ_PENDQUEUE_LINE_MODE(_) \
_(NV_FDC_L1WREQ_PENDQUEUE,LINE_MODE,L64BIT,0) \
_(NV_FDC_L1WREQ_PENDQUEUE,LINE_MODE,L128BIT,1)
#define PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE_REG_ENC_ADDRESS(_) _(NV_FDC_L1WREQ_PENDQUEUE,REG_ENC_ADDRESS,0,9,8,0,0x1ff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQ_PENDQUEUE_REG_ENC_ADDRESS(_)
#define PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE_LINE(_) _(NV_FDC_L1WREQ_PENDQUEUE,LINE,0,7,8,2,0x7f,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQ_PENDQUEUE_LINE(_)
#define PKT_FLD_NV_FDC_L1WREQ_PENDQUEUE_OFFSET(_) _(NV_FDC_L1WREQ_PENDQUEUE,OFFSET,0,2,1,0,0x3,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQ_PENDQUEUE_OFFSET(_)
#define NV_FDC_L1WREQH_PENDQUEUE_BE_BASE        75
#define NV_FDC_L1WREQH_PENDQUEUE_DATA_BASE      11

// Packet NV_FDC_L1WREQH_PENDQUEUE
#define LIST_PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE(_) \
_(NV_FDC_L1WREQH_PENDQUEUE,ADDRESS) \
_(NV_FDC_L1WREQH_PENDQUEUE,BE) \
_(NV_FDC_L1WREQH_PENDQUEUE,REG_DATA) \
_(NV_FDC_L1WREQH_PENDQUEUE,DATA) \
_(NV_FDC_L1WREQH_PENDQUEUE,RELEASE) \
_(NV_FDC_L1WREQH_PENDQUEUE,REQ_MODE) \
_(NV_FDC_L1WREQH_PENDQUEUE,LINE_MODE) \
_(NV_FDC_L1WREQH_PENDQUEUE,REG_ENC_ADDRESS) \
_(NV_FDC_L1WREQH_PENDQUEUE,LINE) \
_(NV_FDC_L1WREQH_PENDQUEUE,OFFSET)
#define PKT_NV_FDC_L1WREQH_PENDQUEUE(_) _(NV_FDC_L1WREQH_PENDQUEUE,112,FLD)
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_ADDRESS(_) _(NV_FDC_L1WREQH_PENDQUEUE,ADDRESS,0,29,111,83,0x1fffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_ADDRESS(_)
// register data overlap
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_BE(_) _(NV_FDC_L1WREQH_PENDQUEUE,BE,0,8,82,75,0xff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_BE(_)
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_REG_DATA(_) _(NV_FDC_L1WREQH_PENDQUEUE,REG_DATA,0,32,42,11,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_REG_DATA(_)
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_DATA(_) _(NV_FDC_L1WREQH_PENDQUEUE,DATA,0,64,74,11,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_DATA(_)
//these 2 overlap
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_RELEASE(_) _(NV_FDC_L1WREQH_PENDQUEUE,RELEASE,0,1,10,10,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_RELEASE(_)
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_REQ_MODE(_) _(NV_FDC_L1WREQH_PENDQUEUE,REQ_MODE,0,1,9,9,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_REQ_MODE(_) \
_(NV_FDC_L1WREQH_PENDQUEUE,REQ_MODE,PIXEL,0) \
_(NV_FDC_L1WREQH_PENDQUEUE,REQ_MODE,REGISTER,1)
// register address encode address packet overlap
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_LINE_MODE(_) _(NV_FDC_L1WREQH_PENDQUEUE,LINE_MODE,0,1,9,9,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_LINE_MODE(_) \
_(NV_FDC_L1WREQH_PENDQUEUE,LINE_MODE,L64BIT,0) \
_(NV_FDC_L1WREQH_PENDQUEUE,LINE_MODE,L128BIT,1)
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_REG_ENC_ADDRESS(_) _(NV_FDC_L1WREQH_PENDQUEUE,REG_ENC_ADDRESS,0,9,8,0,0x1ff,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_REG_ENC_ADDRESS(_)
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_LINE(_) _(NV_FDC_L1WREQH_PENDQUEUE,LINE,0,7,8,2,0x7f,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_LINE(_)
#define PKT_FLD_NV_FDC_L1WREQH_PENDQUEUE_OFFSET(_) _(NV_FDC_L1WREQH_PENDQUEUE,OFFSET,0,2,1,0,0x3,NOENM)
#define LIST_PKT_ENM_NV_FDC_L1WREQH_PENDQUEUE_OFFSET(_)
// Register address packet

// Packet NV_FDC_REQ_REG_ADDR
#define LIST_PKT_FLD_NV_FDC_REQ_REG_ADDR(_) \
_(NV_FDC_REQ_REG_ADDR,BLK_NUM) \
_(NV_FDC_REQ_REG_ADDR,BLK_ADDR)
#define PKT_NV_FDC_REQ_REG_ADDR(_) _(NV_FDC_REQ_REG_ADDR,12,FLD)
#define PKT_FLD_NV_FDC_REQ_REG_ADDR_BLK_NUM(_) _(NV_FDC_REQ_REG_ADDR,BLK_NUM,0,4,11,8,0xf,NOENM)
#define LIST_PKT_ENM_NV_FDC_REQ_REG_ADDR_BLK_NUM(_)
#define PKT_FLD_NV_FDC_REQ_REG_ADDR_BLK_ADDR(_) _(NV_FDC_REQ_REG_ADDR,BLK_ADDR,0,8,7,0,0xff,NOENM)
#define LIST_PKT_ENM_NV_FDC_REQ_REG_ADDR_BLK_ADDR(_)
// Register address encode packet

// Packet NV_FDC_REQ_REG_ADDR_ENC
#define LIST_PKT_FLD_NV_FDC_REQ_REG_ADDR_ENC(_) \
_(NV_FDC_REQ_REG_ADDR_ENC,BLK_NUM) \
_(NV_FDC_REQ_REG_ADDR_ENC,BLK_ADDR)
#define PKT_NV_FDC_REQ_REG_ADDR_ENC(_) _(NV_FDC_REQ_REG_ADDR_ENC,9,FLD)
#define PKT_FLD_NV_FDC_REQ_REG_ADDR_ENC_BLK_NUM(_) _(NV_FDC_REQ_REG_ADDR_ENC,BLK_NUM,0,1,8,8,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_REQ_REG_ADDR_ENC_BLK_NUM(_) \
_(NV_FDC_REQ_REG_ADDR_ENC,BLK_NUM,FDC,0) \
_(NV_FDC_REQ_REG_ADDR_ENC,BLK_NUM,GLOBAL,1)
#define PKT_FLD_NV_FDC_REQ_REG_ADDR_ENC_BLK_ADDR(_) _(NV_FDC_REQ_REG_ADDR_ENC,BLK_ADDR,0,8,7,0,0xff,ENM)
#define LIST_PKT_ENM_NV_FDC_REQ_REG_ADDR_ENC_BLK_ADDR(_) \
_(NV_FDC_REQ_REG_ADDR_ENC,BLK_ADDR,GLOBAL_NV_MCCIF,0) \
_(NV_FDC_REQ_REG_ADDR_ENC,BLK_ADDR,OTHER,15)
// MC queue sizes
#define NV_FDC_MCQ_RD_QFIFO_WIDTH       8
#define NV_FDC_MCQ_WR_QFIFO_WIDTH       7
#define NV_FDC_MCQ_WR_DRAM_PEND_QFIFO_DEPTH     32
#define NV_FDC_MCQ_RD_DRAM_PEND_QFIFO_DEPTH     32

// Packet NV_FDC_MC_QUEUE
#define LIST_PKT_FLD_NV_FDC_MC_QUEUE(_) \
_(NV_FDC_MC_QUEUE,LINE)
#define PKT_NV_FDC_MC_QUEUE(_) _(NV_FDC_MC_QUEUE,7,FLD)
#define PKT_FLD_NV_FDC_MC_QUEUE_LINE(_) _(NV_FDC_MC_QUEUE,LINE,0,7,6,0,0x7f,NOENM)
#define LIST_PKT_ENM_NV_FDC_MC_QUEUE_LINE(_)
//      11.) SB interface FIFO depth
#define NV_FDC_SB_QFIFO_DEPTH   16
//
//      Packet for L2 line state
//

// Packet NV_FDC_L2LINESTAT
#define LIST_PKT_FLD_NV_FDC_L2LINESTAT(_) \
_(NV_FDC_L2LINESTAT,REQCNT) \
_(NV_FDC_L2LINESTAT,DIRTY) \
_(NV_FDC_L2LINESTAT,LOCKED) \
_(NV_FDC_L2LINESTAT,MCDONE) \
_(NV_FDC_L2LINESTAT,COMPLETE) \
_(NV_FDC_L2LINESTAT,PERSISTENT) \
_(NV_FDC_L2LINESTAT,READCLEAN)
#define PKT_NV_FDC_L2LINESTAT(_) _(NV_FDC_L2LINESTAT,9,FLD)
#define PKT_FLD_NV_FDC_L2LINESTAT_REQCNT(_) _(NV_FDC_L2LINESTAT,REQCNT,0,3,8,6,0x7,NOENM)
#define LIST_PKT_ENM_NV_FDC_L2LINESTAT_REQCNT(_)
#define PKT_FLD_NV_FDC_L2LINESTAT_DIRTY(_) _(NV_FDC_L2LINESTAT,DIRTY,0,1,5,5,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_L2LINESTAT_DIRTY(_)
#define PKT_FLD_NV_FDC_L2LINESTAT_LOCKED(_) _(NV_FDC_L2LINESTAT,LOCKED,0,1,4,4,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_L2LINESTAT_LOCKED(_)
#define PKT_FLD_NV_FDC_L2LINESTAT_MCDONE(_) _(NV_FDC_L2LINESTAT,MCDONE,0,1,3,3,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_L2LINESTAT_MCDONE(_)
#define PKT_FLD_NV_FDC_L2LINESTAT_COMPLETE(_) _(NV_FDC_L2LINESTAT,COMPLETE,0,1,2,2,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_L2LINESTAT_COMPLETE(_)
#define PKT_FLD_NV_FDC_L2LINESTAT_PERSISTENT(_) _(NV_FDC_L2LINESTAT,PERSISTENT,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_L2LINESTAT_PERSISTENT(_)
#define PKT_FLD_NV_FDC_L2LINESTAT_READCLEAN(_) _(NV_FDC_L2LINESTAT,READCLEAN,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_L2LINESTAT_READCLEAN(_)
//
//      Packet for RD client request to cache control
//

// Packet NV_FDC_RD_CLIENT_REQ
#define LIST_PKT_FLD_NV_FDC_RD_CLIENT_REQ(_) \
_(NV_FDC_RD_CLIENT_REQ,PERSISTENT) \
_(NV_FDC_RD_CLIENT_REQ,TAG)
#define PKT_NV_FDC_RD_CLIENT_REQ(_) _(NV_FDC_RD_CLIENT_REQ,28,FLD)
#define PKT_FLD_NV_FDC_RD_CLIENT_REQ_PERSISTENT(_) _(NV_FDC_RD_CLIENT_REQ,PERSISTENT,0,1,27,27,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_RD_CLIENT_REQ_PERSISTENT(_)
#define PKT_FLD_NV_FDC_RD_CLIENT_REQ_TAG(_) _(NV_FDC_RD_CLIENT_REQ,TAG,0,27,26,0,0x7ffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_RD_CLIENT_REQ_TAG(_)
//
//      Packet for WR client request to cache control
//

// Packet NV_FDC_WR_CLIENT_REQ
#define LIST_PKT_FLD_NV_FDC_WR_CLIENT_REQ(_) \
_(NV_FDC_WR_CLIENT_REQ,READCLEAN) \
_(NV_FDC_WR_CLIENT_REQ,PERSISTENT) \
_(NV_FDC_WR_CLIENT_REQ,TAG)
#define PKT_NV_FDC_WR_CLIENT_REQ(_) _(NV_FDC_WR_CLIENT_REQ,29,FLD)
#define PKT_FLD_NV_FDC_WR_CLIENT_REQ_READCLEAN(_) _(NV_FDC_WR_CLIENT_REQ,READCLEAN,0,1,28,28,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_WR_CLIENT_REQ_READCLEAN(_)
#define PKT_FLD_NV_FDC_WR_CLIENT_REQ_PERSISTENT(_) _(NV_FDC_WR_CLIENT_REQ,PERSISTENT,0,1,27,27,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_WR_CLIENT_REQ_PERSISTENT(_)
#define PKT_FLD_NV_FDC_WR_CLIENT_REQ_TAG(_) _(NV_FDC_WR_CLIENT_REQ,TAG,0,27,26,0,0x7ffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WR_CLIENT_REQ_TAG(_)
//
//      Read request Packet Cache control to MC
//

// Packet NV_FDC_MCQ_READ
#define LIST_PKT_FLD_NV_FDC_MCQ_READ(_) \
_(NV_FDC_MCQ_READ,BUF_SWAP) \
_(NV_FDC_MCQ_READ,LINE) \
_(NV_FDC_MCQ_READ,ADDRESS)
#define PKT_NV_FDC_MCQ_READ(_) _(NV_FDC_MCQ_READ,35,FLD)
#define PKT_FLD_NV_FDC_MCQ_READ_BUF_SWAP(_) _(NV_FDC_MCQ_READ,BUF_SWAP,0,1,34,34,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_READ_BUF_SWAP(_)
#define PKT_FLD_NV_FDC_MCQ_READ_LINE(_) _(NV_FDC_MCQ_READ,LINE,0,7,33,27,0x7f,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_READ_LINE(_)
#define PKT_FLD_NV_FDC_MCQ_READ_ADDRESS(_) _(NV_FDC_MCQ_READ,ADDRESS,0,27,26,0,0x7ffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_READ_ADDRESS(_)
//
//      Read data Packet MC to L2
//

// Packet NV_FDC_MCQ_RDATA
#define LIST_PKT_FLD_NV_FDC_MCQ_RDATA(_) \
_(NV_FDC_MCQ_RDATA,BUF_SWAP) \
_(NV_FDC_MCQ_RDATA,DATA) \
_(NV_FDC_MCQ_RDATA,LINE)
#define PKT_NV_FDC_MCQ_RDATA(_) _(NV_FDC_MCQ_RDATA,264,FLD)
#define PKT_FLD_NV_FDC_MCQ_RDATA_BUF_SWAP(_) _(NV_FDC_MCQ_RDATA,BUF_SWAP,0,1,263,263,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_RDATA_BUF_SWAP(_)
#define PKT_FLD_NV_FDC_MCQ_RDATA_DATA(_) _(NV_FDC_MCQ_RDATA,DATA,0,256,262,7,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_RDATA_DATA(_)
#define PKT_FLD_NV_FDC_MCQ_RDATA_LINE(_) _(NV_FDC_MCQ_RDATA,LINE,0,7,6,0,0x7f,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_RDATA_LINE(_)
//
//      Write request Packet Flush to MC
//

// Packet NV_FDC_MCQ_WRITE
#define LIST_PKT_FLD_NV_FDC_MCQ_WRITE(_) \
_(NV_FDC_MCQ_WRITE,DATA) \
_(NV_FDC_MCQ_WRITE,BE) \
_(NV_FDC_MCQ_WRITE,LINE) \
_(NV_FDC_MCQ_WRITE,ADDRESS)
#define PKT_NV_FDC_MCQ_WRITE(_) _(NV_FDC_MCQ_WRITE,322,FLD)
#define PKT_FLD_NV_FDC_MCQ_WRITE_DATA(_) _(NV_FDC_MCQ_WRITE,DATA,0,256,321,66,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_WRITE_DATA(_)
#define PKT_FLD_NV_FDC_MCQ_WRITE_BE(_) _(NV_FDC_MCQ_WRITE,BE,0,32,65,34,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_WRITE_BE(_)
#define PKT_FLD_NV_FDC_MCQ_WRITE_LINE(_) _(NV_FDC_MCQ_WRITE,LINE,0,7,33,27,0x7f,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_WRITE_LINE(_)
#define PKT_FLD_NV_FDC_MCQ_WRITE_ADDRESS(_) _(NV_FDC_MCQ_WRITE,ADDRESS,0,27,26,0,0x7ffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_MCQ_WRITE_ADDRESS(_)
//
//      Processed/collapsed scoreboard packet.
//

// Packet NV_FDC_SB_CHECK
#define LIST_PKT_FLD_NV_FDC_SB_CHECK(_) \
_(NV_FDC_SB_CHECK,BYTES_PER_PIXEL) \
_(NV_FDC_SB_CHECK,QUAD_Y) \
_(NV_FDC_SB_CHECK,QUAD_X) \
_(NV_FDC_SB_CHECK,BYTEMASK)
#define PKT_NV_FDC_SB_CHECK(_) _(NV_FDC_SB_CHECK,32,FLD)
#define PKT_FLD_NV_FDC_SB_CHECK_BYTES_PER_PIXEL(_) _(NV_FDC_SB_CHECK,BYTES_PER_PIXEL,0,2,31,30,0x3,ENM)
#define LIST_PKT_ENM_NV_FDC_SB_CHECK_BYTES_PER_PIXEL(_) \
_(NV_FDC_SB_CHECK,BYTES_PER_PIXEL,BPP1,0) \
_(NV_FDC_SB_CHECK,BYTES_PER_PIXEL,BPP2,1) \
_(NV_FDC_SB_CHECK,BYTES_PER_PIXEL,BPP4,2) \
_(NV_FDC_SB_CHECK,BYTES_PER_PIXEL,BPP8,3)
#define PKT_FLD_NV_FDC_SB_CHECK_QUAD_Y(_) _(NV_FDC_SB_CHECK,QUAD_Y,0,11,29,19,0x7ff,NOENM)
#define LIST_PKT_ENM_NV_FDC_SB_CHECK_QUAD_Y(_)
#define PKT_FLD_NV_FDC_SB_CHECK_QUAD_X(_) _(NV_FDC_SB_CHECK,QUAD_X,0,11,18,8,0x7ff,NOENM)
#define LIST_PKT_ENM_NV_FDC_SB_CHECK_QUAD_X(_)
#define PKT_FLD_NV_FDC_SB_CHECK_BYTEMASK(_) _(NV_FDC_SB_CHECK,BYTEMASK,0,8,7,0,0xff,NOENM)
#define LIST_PKT_ENM_NV_FDC_SB_CHECK_BYTEMASK(_)

// Packet NV_FDC_SB_PKT
#define LIST_PKT_FLD_NV_FDC_SB_PKT(_) \
_(NV_FDC_SB_PKT,PAYLOAD) \
_(NV_FDC_SB_PKT,QUAD_Y) \
_(NV_FDC_SB_PKT,QUAD_X) \
_(NV_FDC_SB_PKT,MASK)
#define PKT_NV_FDC_SB_PKT(_) _(NV_FDC_SB_PKT,30,FLD)
#define PKT_FLD_NV_FDC_SB_PKT_PAYLOAD(_) _(NV_FDC_SB_PKT,PAYLOAD,0,4,29,26,0xf,NOENM)
#define LIST_PKT_ENM_NV_FDC_SB_PKT_PAYLOAD(_)
#define PKT_FLD_NV_FDC_SB_PKT_QUAD_Y(_) _(NV_FDC_SB_PKT,QUAD_Y,0,11,25,15,0x7ff,NOENM)
#define LIST_PKT_ENM_NV_FDC_SB_PKT_QUAD_Y(_)
#define PKT_FLD_NV_FDC_SB_PKT_QUAD_X(_) _(NV_FDC_SB_PKT,QUAD_X,0,11,14,4,0x7ff,NOENM)
#define LIST_PKT_ENM_NV_FDC_SB_PKT_QUAD_X(_)
#define PKT_FLD_NV_FDC_SB_PKT_MASK(_) _(NV_FDC_SB_PKT,MASK,0,4,3,0,0xf,NOENM)
#define LIST_PKT_ENM_NV_FDC_SB_PKT_MASK(_)
//
// packet defs for read request for L1 clients
//
//
// Generic packet for PSEQ & QRAST read request clients
//
//   - REQ_MODE selects if request is fdc register read (REGISTER) or
//   pixel/data read (PIXEL). For PIXEL access, fields REQ_MODE,
//   LINE_MODE, ADDRESS, and PERSISTENT are valid. For REGISTER access,
//   fields REQ_MODE, REG_ADDR, REG_BLK_ADDR, and REG_BLK_NUM are valid.
//   - in PIXEL mode, LINE_MODE selects if request is for 64 bit or 128
//   bit data. If L128BIT is selected, both clients request buses should
//   be in sync with the 128 bit request.
//   - in PIXEL mode, ADDRESS is L1 cache size truncated address (8 byte)
//   - in PIXEL mode, PERSISTENT is a hint bit from client that, if set,
//   indicates that this line is likely to be reaccessed, and therefore
//   fdc should try to keep this line in the cache as long as possible.
//

// Packet NV_FDC_RREQ
#define LIST_PKT_FLD_NV_FDC_RREQ(_) \
_(NV_FDC_RREQ,PERSISTENT) \
_(NV_FDC_RREQ,REG_UNUSED) \
_(NV_FDC_RREQ,REG_BLK_NUM) \
_(NV_FDC_RREQ,REG_BLK_ADDR) \
_(NV_FDC_RREQ,REG_ADDR) \
_(NV_FDC_RREQ,TAG) \
_(NV_FDC_RREQ,OFFSET) \
_(NV_FDC_RREQ,ADDRESS) \
_(NV_FDC_RREQ,LINE_MODE) \
_(NV_FDC_RREQ,REQ_MODE)
#define PKT_NV_FDC_RREQ(_) _(NV_FDC_RREQ,32,FLD)
// persistent hint bit (PIXEL only)
// note: {REG_UNUSED,REG_ADDR}, {REG_UNUSED,REG_BLK_NUM,REG_BLK_ADDR} and {ADDRESS} overlap
#define PKT_FLD_NV_FDC_RREQ_PERSISTENT(_) _(NV_FDC_RREQ,PERSISTENT,0,1,31,31,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_PERSISTENT(_)
// REG read address - unused/reserved
#define PKT_FLD_NV_FDC_RREQ_REG_UNUSED(_) _(NV_FDC_RREQ,REG_UNUSED,0,17,30,14,0x1ffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_REG_UNUSED(_)
// REG read address - bits that point at the block
#define PKT_FLD_NV_FDC_RREQ_REG_BLK_NUM(_) _(NV_FDC_RREQ,REG_BLK_NUM,0,4,13,10,0xf,ENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_REG_BLK_NUM(_) \
_(NV_FDC_RREQ,REG_BLK_NUM,CTL,0) \
_(NV_FDC_RREQ,REG_BLK_NUM,IDX,1) \
_(NV_FDC_RREQ,REG_BLK_NUM,VPE,2) \
_(NV_FDC_RREQ,REG_BLK_NUM,SU,3) \
_(NV_FDC_RREQ,REG_BLK_NUM,QR,4) \
_(NV_FDC_RREQ,REG_BLK_NUM,PSEQ,5) \
_(NV_FDC_RREQ,REG_BLK_NUM,AT,6) \
_(NV_FDC_RREQ,REG_BLK_NUM,TEX,7) \
_(NV_FDC_RREQ,REG_BLK_NUM,ALU,8) \
_(NV_FDC_RREQ,REG_BLK_NUM,DW,9) \
_(NV_FDC_RREQ,REG_BLK_NUM,FDC,10) \
_(NV_FDC_RREQ,REG_BLK_NUM,GLB1,14) \
_(NV_FDC_RREQ,REG_BLK_NUM,GLB2,15)
// REG read address - offset within the block
#define PKT_FLD_NV_FDC_RREQ_REG_BLK_ADDR(_) _(NV_FDC_RREQ,REG_BLK_ADDR,0,8,9,2,0xff,NOENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_REG_BLK_ADDR(_)
// REG read address - whole address (needed for global MCCIF reg decode)
#define PKT_FLD_NV_FDC_RREQ_REG_ADDR(_) _(NV_FDC_RREQ,REG_ADDR,0,12,13,2,0xfff,NOENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_REG_ADDR(_)
// PIXEL read address Tag
#define PKT_FLD_NV_FDC_RREQ_TAG(_) _(NV_FDC_RREQ,TAG,0,27,30,4,0x7ffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_TAG(_)
// PIXEL read address offset
#define PKT_FLD_NV_FDC_RREQ_OFFSET(_) _(NV_FDC_RREQ,OFFSET,0,2,3,2,0x3,NOENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_OFFSET(_)
// PIXEL read address - L1 cache size truncated address (8 byte)
#define PKT_FLD_NV_FDC_RREQ_ADDRESS(_) _(NV_FDC_RREQ,ADDRESS,0,29,30,2,0x1fffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_ADDRESS(_)
// selects if PIXEL request is in 64 bit or 128 bit mode
#define PKT_FLD_NV_FDC_RREQ_LINE_MODE(_) _(NV_FDC_RREQ,LINE_MODE,0,1,1,1,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_LINE_MODE(_) \
_(NV_FDC_RREQ,LINE_MODE,L64BIT,0) \
_(NV_FDC_RREQ,LINE_MODE,L128BIT,1)
// selects if request is fdc register read (REGISTER) or
//    pixel/data read (PIXEL). Only QRAST Z client is allowed
//    to access fdc registers
#define PKT_FLD_NV_FDC_RREQ_REQ_MODE(_) _(NV_FDC_RREQ,REQ_MODE,0,1,0,0,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_RREQ_REQ_MODE(_) \
_(NV_FDC_RREQ,REQ_MODE,PIXEL,0) \
_(NV_FDC_RREQ,REQ_MODE,REGISTER,1)
//
// Generic packet for PSEQ & QRAST read data clients
//

// Packet NV_FDC_READ_DATA
#define LIST_PKT_FLD_NV_FDC_READ_DATA(_) \
_(NV_FDC_READ_DATA,REG_UNUSED) \
_(NV_FDC_READ_DATA,REG_DATA) \
_(NV_FDC_READ_DATA,DATA)
#define PKT_NV_FDC_READ_DATA(_) _(NV_FDC_READ_DATA,64,FLD)
// reserved when register read access
#define PKT_FLD_NV_FDC_READ_DATA_REG_UNUSED(_) _(NV_FDC_READ_DATA,REG_UNUSED,0,32,63,32,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_READ_DATA_REG_UNUSED(_)
// register read data
#define PKT_FLD_NV_FDC_READ_DATA_REG_DATA(_) _(NV_FDC_READ_DATA,REG_DATA,0,32,31,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_READ_DATA_REG_DATA(_)
// pixel read data
#define PKT_FLD_NV_FDC_READ_DATA_DATA(_) _(NV_FDC_READ_DATA,DATA,0,64,63,0,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_READ_DATA_DATA(_)
//
// packet for write request for L1 clients
//
//
// Generic packet for DW & QRAST write request
//
//   - REQ_MODE selects if request is fdc register write (REGISTER) or
//   pixel/data write (PIXEL). For PIXEL access, fields REQ_MODE,
//   LINE_MODE, ADDRESS, DATA, BE, PERSISTENT, READ_CLEAN, SB_MASK,
//   SB_QUAD_X, SB_QUAD_Y, SB_BYTES_PER_PIXEL are valid. For REGISTER
//   access, fields REQ_MODE, REG_ADDR, REG_BLK_ADDR, REG_BLK_NUM, and
//   REG_DATA are valid.
//   - in PIXEL mode, LINE_MODE selects if request is for 64 bit or 128
//   bit data. If L128BIT is selected, both clients request buses should
//   be in sync with the 128 bit request.
//   - in PIXEL mode, ADDRESS is L1 cache size truncated address (8 byte)
//   - in PIXEL mode, PERSISTENT is a hint bit from client that, if set,
//   indicates that this line is likely to be reaccessed, and therefore
//   fdc should try to keep this line in the cache as long as possible.
//   - in PIXEL mode, READ_CLEAN is a hint bit from client that, if set,
//   indicates that this line is a temporary buffer, and once read, can be
//   discarded even if it has not been flushed to main memory.
//   - in PIXEL mode, SB_MASK is a per quad pixel scoreboard valid mask.
//   To indicate an invalid scoreboard data, set all bits to zero.
// use this packet for REQ_MODE=PIXEL
#define NV_FDC_WREQ_DATA_BASE   31
#define NV_FDC_WREQ_BE_BASE     95

// Packet NV_FDC_WREQ
#define LIST_PKT_FLD_NV_FDC_WREQ(_) \
_(NV_FDC_WREQ,SB_BYTES_PER_PIXEL) \
_(NV_FDC_WREQ,SB_QUAD_Y) \
_(NV_FDC_WREQ,SB_QUAD_X) \
_(NV_FDC_WREQ,SB_MASK) \
_(NV_FDC_WREQ,SB_CLEAR) \
_(NV_FDC_WREQ,READ_CLEAN) \
_(NV_FDC_WREQ,PERSISTENT) \
_(NV_FDC_WREQ,BE) \
_(NV_FDC_WREQ,REG_DATA_UNUSED) \
_(NV_FDC_WREQ,REG_DATA) \
_(NV_FDC_WREQ,DATA) \
_(NV_FDC_WREQ,REG_UNUSED) \
_(NV_FDC_WREQ,REG_BLK_NUM) \
_(NV_FDC_WREQ,REG_BLK_ADDR) \
_(NV_FDC_WREQ,REG_ADDR) \
_(NV_FDC_WREQ,TAG) \
_(NV_FDC_WREQ,OFFSET) \
_(NV_FDC_WREQ,ADDRESS) \
_(NV_FDC_WREQ,LINE_MODE) \
_(NV_FDC_WREQ,REQ_MODE)
#define PKT_NV_FDC_WREQ(_) _(NV_FDC_WREQ,133,FLD)
// scoreboard surface format (PIXEL only)
#define PKT_FLD_NV_FDC_WREQ_SB_BYTES_PER_PIXEL(_) _(NV_FDC_WREQ,SB_BYTES_PER_PIXEL,0,2,132,131,0x3,ENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_SB_BYTES_PER_PIXEL(_) \
_(NV_FDC_WREQ,SB_BYTES_PER_PIXEL,BPP1,0) \
_(NV_FDC_WREQ,SB_BYTES_PER_PIXEL,BPP2,1) \
_(NV_FDC_WREQ,SB_BYTES_PER_PIXEL,BPP4,2) \
_(NV_FDC_WREQ,SB_BYTES_PER_PIXEL,BPP8,3)
// scoreboard quad y position (PIXEL only)
#define PKT_FLD_NV_FDC_WREQ_SB_QUAD_Y(_) _(NV_FDC_WREQ,SB_QUAD_Y,0,11,130,120,0x7ff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_SB_QUAD_Y(_)
// scoreboard quad x position (PIXEL only)
#define PKT_FLD_NV_FDC_WREQ_SB_QUAD_X(_) _(NV_FDC_WREQ,SB_QUAD_X,0,11,119,109,0x7ff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_SB_QUAD_X(_)
// scoreboard valid quad mask (PIXEL only)
// note: SB_CLEAR and all other SB_ overlap
#define PKT_FLD_NV_FDC_WREQ_SB_MASK(_) _(NV_FDC_WREQ,SB_MASK,0,4,108,105,0xf,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_SB_MASK(_)
// scoreboard clear packet (all combined - PIXEL only)
#define PKT_FLD_NV_FDC_WREQ_SB_CLEAR(_) _(NV_FDC_WREQ,SB_CLEAR,0,28,132,105,0xfffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_SB_CLEAR(_)
// read_clean hint bit (PIXEL only)
#define PKT_FLD_NV_FDC_WREQ_READ_CLEAN(_) _(NV_FDC_WREQ,READ_CLEAN,0,1,104,104,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_READ_CLEAN(_)
// persistent hint bit (PIXEL only)
#define PKT_FLD_NV_FDC_WREQ_PERSISTENT(_) _(NV_FDC_WREQ,PERSISTENT,0,1,103,103,0x1,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_PERSISTENT(_)
// PIXEL write per byte enables (8 bits).
// note: {REG_DATA_UNUSED,REG_DATA} and DATA overlap
#define PKT_FLD_NV_FDC_WREQ_BE(_) _(NV_FDC_WREQ,BE,0,8,102,95,0xff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_BE(_)
// REG write data - unused/reserved
#define PKT_FLD_NV_FDC_WREQ_REG_DATA_UNUSED(_) _(NV_FDC_WREQ,REG_DATA_UNUSED,0,32,94,63,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_REG_DATA_UNUSED(_)
// REG write data
#define PKT_FLD_NV_FDC_WREQ_REG_DATA(_) _(NV_FDC_WREQ,REG_DATA,0,32,62,31,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_REG_DATA(_)
// PIXEL write data - L1 cache size (8 bytes) aligned data
// note: {REG_UNUSED,REG_ADDR}, {REG_UNUSED,REG_BLK_NUM,REG_BLK_ADDR} and {ADDRESS} overlap
#define PKT_FLD_NV_FDC_WREQ_DATA(_) _(NV_FDC_WREQ,DATA,0,64,94,31,0xffffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_DATA(_)
// REG read address - unused/reserved
#define PKT_FLD_NV_FDC_WREQ_REG_UNUSED(_) _(NV_FDC_WREQ,REG_UNUSED,0,17,30,14,0x1ffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_REG_UNUSED(_)
// REG read address - bits that point at the block
#define PKT_FLD_NV_FDC_WREQ_REG_BLK_NUM(_) _(NV_FDC_WREQ,REG_BLK_NUM,0,4,13,10,0xf,ENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_REG_BLK_NUM(_) \
_(NV_FDC_WREQ,REG_BLK_NUM,CTL,0) \
_(NV_FDC_WREQ,REG_BLK_NUM,IDX,1) \
_(NV_FDC_WREQ,REG_BLK_NUM,VPE,2) \
_(NV_FDC_WREQ,REG_BLK_NUM,SU,3) \
_(NV_FDC_WREQ,REG_BLK_NUM,QR,4) \
_(NV_FDC_WREQ,REG_BLK_NUM,PSEQ,5) \
_(NV_FDC_WREQ,REG_BLK_NUM,AT,6) \
_(NV_FDC_WREQ,REG_BLK_NUM,TEX,7) \
_(NV_FDC_WREQ,REG_BLK_NUM,ALU,8) \
_(NV_FDC_WREQ,REG_BLK_NUM,DW,9) \
_(NV_FDC_WREQ,REG_BLK_NUM,FDC,10) \
_(NV_FDC_WREQ,REG_BLK_NUM,GLB1,14) \
_(NV_FDC_WREQ,REG_BLK_NUM,GLB2,15)
// REG read address - offset within the block
#define PKT_FLD_NV_FDC_WREQ_REG_BLK_ADDR(_) _(NV_FDC_WREQ,REG_BLK_ADDR,0,8,9,2,0xff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_REG_BLK_ADDR(_)
// REG read address - whole address (needed for global MCCIF reg decode)
#define PKT_FLD_NV_FDC_WREQ_REG_ADDR(_) _(NV_FDC_WREQ,REG_ADDR,0,12,13,2,0xfff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_REG_ADDR(_)
// PIXEL read address Tag
#define PKT_FLD_NV_FDC_WREQ_TAG(_) _(NV_FDC_WREQ,TAG,0,27,30,4,0x7ffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_TAG(_)
// PIXEL read address offset
#define PKT_FLD_NV_FDC_WREQ_OFFSET(_) _(NV_FDC_WREQ,OFFSET,0,2,3,2,0x3,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_OFFSET(_)
// PIXEL write address - L1 cache size truncated address (8 byte)
#define PKT_FLD_NV_FDC_WREQ_ADDRESS(_) _(NV_FDC_WREQ,ADDRESS,0,29,30,2,0x1fffffff,NOENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_ADDRESS(_)
// selects if PIXEL request is in 64 bit or 128 bit mode
#define PKT_FLD_NV_FDC_WREQ_LINE_MODE(_) _(NV_FDC_WREQ,LINE_MODE,0,1,1,1,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_LINE_MODE(_) \
_(NV_FDC_WREQ,LINE_MODE,L64BIT,0) \
_(NV_FDC_WREQ,LINE_MODE,L128BIT,1)
// selects if request is fdc register write (REGISTER) or
//    pixel/data write (PIXEL). Only QRAST Z client is allowed
//    to access fdc registers
#define PKT_FLD_NV_FDC_WREQ_REQ_MODE(_) _(NV_FDC_WREQ,REQ_MODE,0,1,0,0,0x1,ENM)
#define LIST_PKT_ENM_NV_FDC_WREQ_REQ_MODE(_) \
_(NV_FDC_WREQ,REQ_MODE,PIXEL,0) \
_(NV_FDC_WREQ,REQ_MODE,REGISTER,1)
////////////////////////////////////////////////////////////////////////
// NON-PIXSHADERPKT input FIFO depths
////////////////////////////////////////////////////////////////////////
#define SETUP2QRAST_INPUTFIFO_DEPTH     1
////////////////////////////////////////////////////////////////////////
// PIXSHADERPKT input FIFO depths
////////////////////////////////////////////////////////////////////////
#define QRAST2PSEQ_INPUTFIFO_DEPTH      1
// informative only
#define DWR2PSEQ_INPUTFIFO_DEPTH        5
#define PSEQ2ATRAST_INPUTFIFO_DEPTH     1
#define ATRAST2TEX_INPUTFIFO_DEPTH      1
#define TEX2ALU_INPUTFIFO_DEPTH 1
#define ALU2DWR_INPUTFIFO_DEPTH 1
////////////////////////////////////////////////////////////////////////
// internal pseq specs
////////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------
//
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// ########################## Internal packet definitions ######################
//
// This file contains implementation details that programmers don't need to see.
// pseq latency hiding fifo
#define PSEQ_DATAFETCH_FIFO_DEPTH       112
#define PSEQ_SB_FIFO_DEPTH      4
#define PSEQ_IDX_FIFO_DEPTH     4
// pseq latency sideband fifo

// Packet PSEQ_SIDEBAND
#define LIST_PKT_FLD_PSEQ_SIDEBAND(_) \
_(PSEQ_SIDEBAND,DEST) \
_(PSEQ_SIDEBAND,BUFFER1) \
_(PSEQ_SIDEBAND,BUFFER0)
#define PKT_PSEQ_SIDEBAND(_) _(PSEQ_SIDEBAND,4,FLD)
#define PKT_FLD_PSEQ_SIDEBAND_DEST(_) _(PSEQ_SIDEBAND,DEST,0,2,3,2,0x3,ENM)
#define LIST_PKT_ENM_PSEQ_SIDEBAND_DEST(_) \
_(PSEQ_SIDEBAND,DEST,PASS_THROUGH,0) \
_(PSEQ_SIDEBAND,DEST,UPPER_PIPE,1) \
_(PSEQ_SIDEBAND,DEST,SPILL,2) \
_(PSEQ_SIDEBAND,DEST,GATHER,3)
#define PKT_FLD_PSEQ_SIDEBAND_BUFFER1(_) _(PSEQ_SIDEBAND,BUFFER1,0,1,1,1,0x1,NOENM)
#define LIST_PKT_ENM_PSEQ_SIDEBAND_BUFFER1(_)
#define PKT_FLD_PSEQ_SIDEBAND_BUFFER0(_) _(PSEQ_SIDEBAND,BUFFER0,0,1,0,0,0x1,NOENM)
#define LIST_PKT_ENM_PSEQ_SIDEBAND_BUFFER0(_)
// pseq latency data fifo is SIDEBAND + PIXSHADERPKT

// Packet PSEQ_DATAFETCH
#define LIST_PKT_FLD_PSEQ_DATAFETCH(_) \
_(PSEQ_DATAFETCH,PSEQ_SIDEBAND) \
_(PSEQ_DATAFETCH,PIXSHADERPKT)
#define PKT_PSEQ_DATAFETCH(_) _(PSEQ_DATAFETCH,104,FLD)
#define PKT_FLD_PSEQ_DATAFETCH_PSEQ_SIDEBAND(_) _(PSEQ_DATAFETCH,PSEQ_SIDEBAND,0,4,103,100,0xf,NOENM)
#define LIST_PKT_ENM_PSEQ_DATAFETCH_PSEQ_SIDEBAND(_)
#define PKT_FLD_PSEQ_DATAFETCH_PIXSHADERPKT(_) _(PSEQ_DATAFETCH,PIXSHADERPKT,0,100,99,0,0xf,NOENM)
#define LIST_PKT_ENM_PSEQ_DATAFETCH_PIXSHADERPKT(_)
//
// GATHER
//  based on pixshaderpkt and used in pixshaderpkt fifos

// Packet PIXSHADERPKT_GATHER
#define LIST_PKT_FLD_PIXSHADERPKT_GATHER(_) \
_(PIXSHADERPKT_GATHER,DATA) \
_(PIXSHADERPKT_GATHER,BYTE_OFFSET)
#define PKT_PIXSHADERPKT_GATHER(_) _(PIXSHADERPKT_GATHER,100,FLD)
#define PKT_FLD_PIXSHADERPKT_GATHER_DATA(_) _(PIXSHADERPKT_GATHER,DATA,0,100,99,0,0xf,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_GATHER_DATA(_)
// byte offset within the 128 bit cacheline for the
// gather return data 
#define PKT_FLD_PIXSHADERPKT_GATHER_BYTE_OFFSET(_) _(PIXSHADERPKT_GATHER,BYTE_OFFSET,0,4,3,0,0xf,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_GATHER_BYTE_OFFSET(_)
//
// MOP
//  based on pixshaderpkt and used in pixshaderpkt fifos

// Packet PIXSHADERPKT_MOP
#define LIST_PKT_FLD_PIXSHADERPKT_MOP(_) \
_(PIXSHADERPKT_MOP,DATA) \
_(PIXSHADERPKT_MOP,PC) \
_(PIXSHADERPKT_MOP,SPILL) \
_(PIXSHADERPKT_MOP,START_SEQ)
#define PKT_PIXSHADERPKT_MOP(_) _(PIXSHADERPKT_MOP,100,FLD)
#define PKT_FLD_PIXSHADERPKT_MOP_DATA(_) _(PIXSHADERPKT_MOP,DATA,0,100,99,0,0xf,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_MOP_DATA(_)
// the current PC value.  used by the lower part of pseq to init dbg bits after a spill
#define PKT_FLD_PIXSHADERPKT_MOP_PC(_) _(PIXSHADERPKT_MOP,PC,0,4,12,9,0xf,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_MOP_PC(_)
#define PKT_FLD_PIXSHADERPKT_MOP_SPILL(_) _(PIXSHADERPKT_MOP,SPILL,0,1,8,8,0x1,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_MOP_SPILL(_)
#define PKT_FLD_PIXSHADERPKT_MOP_START_SEQ(_) _(PIXSHADERPKT_MOP,START_SEQ,0,6,5,0,0x3f,NOENM)
#define LIST_PKT_ENM_PIXSHADERPKT_MOP_START_SEQ(_)
//////////////////////////////
// internal atrast specs
//////////////////////////////
// --------------------------------------------------------------------------
//
// Copyright (c) 2004, NVIDIA Corp.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of NVIDIA Corp.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
// --------------------------------------------------------------------------
//
// ########################## Internal packet definitions ######################
//
// This file contains implementation details that programmers don't need to see.

// Packet ATRAST_W_FLOAT
#define LIST_PKT_FLD_ATRAST_W_FLOAT(_) \
_(ATRAST_W_FLOAT,MANT) \
_(ATRAST_W_FLOAT,EXP) \
_(ATRAST_W_FLOAT,SIGN)
#define PKT_ATRAST_W_FLOAT(_) _(ATRAST_W_FLOAT,25,FLD)
#define PKT_FLD_ATRAST_W_FLOAT_MANT(_) _(ATRAST_W_FLOAT,MANT,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_ATRAST_W_FLOAT_MANT(_)
#define PKT_FLD_ATRAST_W_FLOAT_EXP(_) _(ATRAST_W_FLOAT,EXP,0,6,23,18,0x3f,NOENM)
#define LIST_PKT_ENM_ATRAST_W_FLOAT_EXP(_)
#define PKT_FLD_ATRAST_W_FLOAT_SIGN(_) _(ATRAST_W_FLOAT,SIGN,0,1,24,24,0x1,NOENM)
#define LIST_PKT_ENM_ATRAST_W_FLOAT_SIGN(_)

// Packet ATRAST_AB_FLOAT
#define LIST_PKT_FLD_ATRAST_AB_FLOAT(_) \
_(ATRAST_AB_FLOAT,MANT) \
_(ATRAST_AB_FLOAT,EXP) \
_(ATRAST_AB_FLOAT,SIGN)
#define PKT_ATRAST_AB_FLOAT(_) _(ATRAST_AB_FLOAT,22,FLD)
#define PKT_FLD_ATRAST_AB_FLOAT_MANT(_) _(ATRAST_AB_FLOAT,MANT,0,15,14,0,0x7fff,NOENM)
#define LIST_PKT_ENM_ATRAST_AB_FLOAT_MANT(_)
#define PKT_FLD_ATRAST_AB_FLOAT_EXP(_) _(ATRAST_AB_FLOAT,EXP,0,6,20,15,0x3f,NOENM)
#define LIST_PKT_ENM_ATRAST_AB_FLOAT_EXP(_)
#define PKT_FLD_ATRAST_AB_FLOAT_SIGN(_) _(ATRAST_AB_FLOAT,SIGN,0,1,21,21,0x1,NOENM)
#define LIST_PKT_ENM_ATRAST_AB_FLOAT_SIGN(_)

// Packet ATRAST_AB_BLK_FLT
#define LIST_PKT_FLD_ATRAST_AB_BLK_FLT(_) \
_(ATRAST_AB_BLK_FLT,AB_HP_MANT) \
_(ATRAST_AB_BLK_FLT,AB_LP_MANT) \
_(ATRAST_AB_BLK_FLT,EXP)
#define PKT_ATRAST_AB_BLK_FLT(_) _(ATRAST_AB_BLK_FLT,34,FLD)
// S1.16
#define PKT_FLD_ATRAST_AB_BLK_FLT_AB_HP_MANT(_) _(ATRAST_AB_BLK_FLT,AB_HP_MANT,0,18,17,0,0x3ffff,NOENM)
#define LIST_PKT_ENM_ATRAST_AB_BLK_FLT_AB_HP_MANT(_)
// S1.8
#define PKT_FLD_ATRAST_AB_BLK_FLT_AB_LP_MANT(_) _(ATRAST_AB_BLK_FLT,AB_LP_MANT,0,10,27,18,0x3ff,NOENM)
#define LIST_PKT_ENM_ATRAST_AB_BLK_FLT_AB_LP_MANT(_)
// 6 excess 31
#define PKT_FLD_ATRAST_AB_BLK_FLT_EXP(_) _(ATRAST_AB_BLK_FLT,EXP,0,6,33,28,0x3f,NOENM)
#define LIST_PKT_ENM_ATRAST_AB_BLK_FLT_EXP(_)
// This parameter reduces the fractional bits used in the HP IPA.  It works for values of [0..17] inclusive.
#define ATRAST_HP_IPA_REDUCE_BITS       12
//////////////////////////////
// internal vpe specs
//////////////////////////////
//
// Note - converted from the original project_ar3d_vpe.spec since this
// shouldn't have been propagated into project.h
//
// in conversion, we moved the end-of-line comments to the beginning of
// the line, changed #define to define, and added a semicolon at end-of-line.
// 
// all this was done via emacs key macros, so apologies for the formatting...
//
// of course, since simspec doesn't understand defines based on other defines,
// some of these need some additional hand-tweaking...  sigh.
#define NV_GR3D_VPE_CMDQ_RAM_DEPTH      8
#define NV_GR3D_VPE_CMDQ_WIDTH  18
#define NV_GR3D_VPE_DPATH_WIDTH 32
#define NV_GR3D_VPE_NUM_COMPONENTS      4
#define NV_GR3D_VPE_DPATH_BUS_WIDTH     128
#define NV_GR3D_VPE_CTX_SIZE    256
#define NV_GR3D_VPE_PROGRAM_LENGTH      256
// Keep hard-coded to 10 since making it s
#define NV_GR3D_VPE_CTX_ADDR_BITS       10
#define NV_GR3D_VPE_CMD_ADDR_BITS       10
#define NV_GR3D_VPE_CC_BITS     3
#define NV_GR3D_VPE_CC_REG_WIDTH        12
#define NV_GR3D_VPE_XFSIDBAND_WIDTH     17
#define NV_GR3D_VPE_MODE_BITS   1
#define NV_GR3D_VPE_INSTR_LIMIT 65536
#define NV_GR3D_VPE_INSTR_LIMIT_BITS    16
#define NV_GR3D_VPE_PRO_ADDR_BITS       8
#define NV_GR3D_VPE_PROGRAM_LD_WIDTH    127
#define NV_GR3D_VPE_THREAD_BITS 1
//
// vpe instruction/ucode related defines.
//
// Operand type
// Operand not used
#define NV_GR3D_VPE_INSTR_OPR_TYPE_INVAL        0
// Position shadow for operand C (rankine only)
#define NV_GR3D_VPE_INSTR_OPR_TYPE_POS  0
// Register 
#define NV_GR3D_VPE_INSTR_OPR_TYPE_REG  1
// I-buffer
#define NV_GR3D_VPE_INSTR_OPR_TYPE_BUF  2
// Context 
#define NV_GR3D_VPE_INSTR_OPR_TYPE_CTX  3
// Operand extract type (per component output)
// Select x_in
#define NV_GR3D_VPE_INSTR_EXTR_X        0
// Select y_in
#define NV_GR3D_VPE_INSTR_EXTR_Y        1
// Select z_in
#define NV_GR3D_VPE_INSTR_EXTR_Z        2
// Select w_in
#define NV_GR3D_VPE_INSTR_EXTR_W        3
// Compare functions
#define NV_GR3D_VPE_INSTR_CC_FALSE      0
#define NV_GR3D_VPE_INSTR_CC_LT 1
#define NV_GR3D_VPE_INSTR_CC_EQ 2
#define NV_GR3D_VPE_INSTR_CC_LE 3
#define NV_GR3D_VPE_INSTR_CC_GT 4
#define NV_GR3D_VPE_INSTR_CC_NE 5
#define NV_GR3D_VPE_INSTR_CC_GE 6
#define NV_GR3D_VPE_INSTR_CC_TRUE       7
// Vector opcodes:
// no operation
#define NV_GR3D_VPE_INSTR_V_NOP 0
// move
#define NV_GR3D_VPE_INSTR_V_MOV 1
// multiply
#define NV_GR3D_VPE_INSTR_V_MUL 2
// add
#define NV_GR3D_VPE_INSTR_V_ADD 3
// multiply and add
#define NV_GR3D_VPE_INSTR_V_MAD 4
// 3 component dot product
#define NV_GR3D_VPE_INSTR_V_DP3 5
// 
#define NV_GR3D_VPE_INSTR_V_DPH 6
// 4 component dot product
#define NV_GR3D_VPE_INSTR_V_DP4 7
// DIS,  PASB
#define NV_GR3D_VPE_INSTR_V_DST 8
// minimum value select
#define NV_GR3D_VPE_INSTR_V_MIN 9
// maximum value select
#define NV_GR3D_VPE_INSTR_V_MAX 10
// set on less than
#define NV_GR3D_VPE_INSTR_V_SLT 11
// set on greater than and equal
#define NV_GR3D_VPE_INSTR_V_SGE 12
// address register load (floor)
#define NV_GR3D_VPE_INSTR_V_ARL 13
// FRC,  PASB
#define NV_GR3D_VPE_INSTR_V_FRC 14
// FLR,  PASB
#define NV_GR3D_VPE_INSTR_V_FLR 15
// SEQ,  PASB
#define NV_GR3D_VPE_INSTR_V_SEQ 16
// SFL,  PASB
#define NV_GR3D_VPE_INSTR_V_SFL 17
// SGT,  PASB
#define NV_GR3D_VPE_INSTR_V_SGT 18
// SLE,  PASB
#define NV_GR3D_VPE_INSTR_V_SLE 19
// SNE,  PASB
#define NV_GR3D_VPE_INSTR_V_SNE 20
// STR,  PASB 
#define NV_GR3D_VPE_INSTR_V_STR 21
// SSG,  PASB
#define NV_GR3D_VPE_INSTR_V_SSG 22
// address register load (round)
#define NV_GR3D_VPE_INSTR_V_ARR 23
// address register move
#define NV_GR3D_VPE_INSTR_V_MVA 24
// texture load
#define NV_GR3D_VPE_INSTR_V_TXL 25
// push address register onto stack
#define NV_GR3D_VPE_INSTR_V_PSH 26
// pop an address register from the stack
#define NV_GR3D_VPE_INSTR_V_POP 27
// reserved
#define NV_GR3D_VPE_INSTR_V_RSV0        28
// reserved
#define NV_GR3D_VPE_INSTR_V_RSV1        29
// reserved
#define NV_GR3D_VPE_INSTR_V_RSV2        30
// reserved
#define NV_GR3D_VPE_INSTR_V_RSV3        31
// Scalar opcodes
// no operation
#define NV_GR3D_VPE_INSTR_S_NOP 0
// move
#define NV_GR3D_VPE_INSTR_S_MOV 1
// reciprocal
#define NV_GR3D_VPE_INSTR_S_RCP 2
// clamped reciprocal
#define NV_GR3D_VPE_INSTR_S_RCC 3
// reciprocal square root
#define NV_GR3D_VPE_INSTR_S_RSQ 4
// exponent
#define NV_GR3D_VPE_INSTR_S_EXP 5
// logarithm
#define NV_GR3D_VPE_INSTR_S_LOG 6
// 
#define NV_GR3D_VPE_INSTR_S_LIT 7
// branch from jumptable  // Kelvin only!
#define NV_GR3D_VPE_INSTR_S_BRA 8
// branch immediate
#define NV_GR3D_VPE_INSTR_S_BRI 9
// call from jumptable    // Kelvin only!
#define NV_GR3D_VPE_INSTR_S_CLA 10
// call on immediate
#define NV_GR3D_VPE_INSTR_S_CLI 11
// return
#define NV_GR3D_VPE_INSTR_S_RET 12
// log base 2
#define NV_GR3D_VPE_INSTR_S_LG2 13
// power of 2
#define NV_GR3D_VPE_INSTR_S_EX2 14
// sine
#define NV_GR3D_VPE_INSTR_S_SIN 15
// cosine
#define NV_GR3D_VPE_INSTR_S_COS 16
// branch on boolean constant
#define NV_GR3D_VPE_INSTR_S_BRB 17
// call on boolean constant
#define NV_GR3D_VPE_INSTR_S_CLB 18
// push address register onto stack
#define NV_GR3D_VPE_INSTR_S_PSH 19
// push address register onto stack
#define NV_GR3D_VPE_INSTR_S_POP 20
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV0        21
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV1        22
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV2        23
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV3        24
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV4        25
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV5        26
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV6        27
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV7        28
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV8        29
// reserved
#define NV_GR3D_VPE_INSTR_S_RSV9        30
// reserved
#define NV_GR3D_VPE_INSTR_S_RSVA        31
//
//
// already in ar3d_vpe #define NV_GR3D_VPE_INSTR_REG_NOP        0x3f    // No-write option ;
// No-write from Rankine
#define NV_GR3D_VPE_RANKINE_REG_NOP     31
// Select the scalar data for OUT_SEL or CC_WR_SEL
#define NV_GR3D_VPE_INSTR_SEL_SCALAR    0
// Select the vector data for OUT_SEL or CC_WR_SEL
#define NV_GR3D_VPE_INSTR_SEL_VECTOR    1
//
// Fixed Function Microcode
#define NV_GR3D_VPE_PROG_TYPE_FFU       0
// Vertex Shader 1.0
#define NV_GR3D_VPE_PROG_TYPE_VS1       2
// Vertex Shader 2.0
#define NV_GR3D_VPE_PROG_TYPE_VS2       3
// Vertex Shader 3.0
#define NV_GR3D_VPE_PROG_TYPE_VS3       1
//
//
// VPE Control Field Enumerants
//
// Stage 1 operand multiplexer select
// Operand A mux width 
#define NV_GR3D_VPE_CTL_ASEL_WIDTH      3
//0b000         // Select position shadow
#define NV_GR3D_VPE_CTL_ASEL_IPOS       0
//0b001         // Select ibuf
#define NV_GR3D_VPE_CTL_ASEL_IBUF       1
//0b010         // Select context
#define NV_GR3D_VPE_CTL_ASEL_CTX        2
//0b100         // Select register 
#define NV_GR3D_VPE_CTL_ASEL_REG        4
//0b101         // Select adder result bus
#define NV_GR3D_VPE_CTL_ASEL_ADD_RSLT   5
//0b110         // Select multiplier result bus
#define NV_GR3D_VPE_CTL_ASEL_MUL_RSLT   6
//0b111 // Select scaler result bus (only for internal dual-issue)
#define NV_GR3D_VPE_CTL_ASEL_SCA_RSLT   7
// Operand B mux width 
#define NV_GR3D_VPE_CTL_BSEL_WIDTH      3
//0b000         // Select position shadow
#define NV_GR3D_VPE_CTL_BSEL_IPOS       0
//0b001         // Select ibuf
#define NV_GR3D_VPE_CTL_BSEL_IBUF       1
//0b010         // Select context
#define NV_GR3D_VPE_CTL_BSEL_CTX        2
//0b100         // Select register 
#define NV_GR3D_VPE_CTL_BSEL_REG        4
//0b101         // Select adder result bus
#define NV_GR3D_VPE_CTL_BSEL_ADD_RSLT   5
//0b110         // Select multiplier result bus
#define NV_GR3D_VPE_CTL_BSEL_MUL_RSLT   6
//0b111 // Select scaler result bus (only for internal dual-issue)
#define NV_GR3D_VPE_CTL_BSEL_SCA_RSLT   7
// Operand C mux width 
#define NV_GR3D_VPE_CTL_CSEL_WIDTH      3
//0b000         // Select position shadow
#define NV_GR3D_VPE_CTL_CSEL_IPOS       0
//0b001         // Select ibuf
#define NV_GR3D_VPE_CTL_CSEL_IBUF       1
//0b010         // Select context
#define NV_GR3D_VPE_CTL_CSEL_CTX        2
//0b100         // Select register 
#define NV_GR3D_VPE_CTL_CSEL_REG        4
//0b101         // Select adder result bus
#define NV_GR3D_VPE_CTL_CSEL_ADD_RSLT   5
//0b110         // Select multiplier result bus
#define NV_GR3D_VPE_CTL_CSEL_MUL_RSLT   6
//0b111         // Select scaler result bus (only for internal dual-issue)
#define NV_GR3D_VPE_CTL_CSEL_SCA_RSLT   7
// Stage 3 addin multiplexer select
//0b10          // Select adder result bypass bus
#define NV_GR3D_VPE_CTL_ADD_SEL_ADD_RSLT        2
//0b11          // Select scaler result bypass bus
#define NV_GR3D_VPE_CTL_ADD_SEL_SCA_RSLT        3
//b00           // Select passthru operand
#define NV_GR3D_VPE_CTL_ADD_SEL_PASS    0
// Cheop control decode definition
// IBuf tag (VAB Slot) definition
// LGG XXX SHOULD COME FROM .REF SYSTEM:
//b00000                // Cheop IBUF position (also used for any non-vertex data storage)
#define NV_GR3D_VPE_CTL_IBUF_RADDR_POS  0
//0b00001               // Cheop IBUF weight
#define NV_GR3D_VPE_CTL_IBUF_RADDR_WT   1
//0b00010               // Cheop IBUF normal
#define NV_GR3D_VPE_CTL_IBUF_RADDR_NRL  2
//0b00011               // Cheop IBUF diffuse
#define NV_GR3D_VPE_CTL_IBUF_RADDR_C0   3
//0b00100               // Cheop IBUF specular
#define NV_GR3D_VPE_CTL_IBUF_RADDR_C1   4
//0b00101               // Cheop IBUF weight
#define NV_GR3D_VPE_CTL_IBUF_RADDR_FOG  5
//0b00110               // Cheop IBUF weight
#define NV_GR3D_VPE_CTL_IBUF_RADDR_PS   6
//0b00111               // Cheop IBUF back diffuse
#define NV_GR3D_VPE_CTL_IBUF_RADDR_C2   7
//0b01000               // Cheop IBUF back specular
#define NV_GR3D_VPE_CTL_IBUF_RADDR_C3   8
//0b01000               // Cheop IBUF texture 0
#define NV_GR3D_VPE_CTL_IBUF_RADDR_T0   8
//0b01001               // Cheop IBUF texture 1
#define NV_GR3D_VPE_CTL_IBUF_RADDR_T1   9
//0b01010               // Cheop IBUF texture 2
#define NV_GR3D_VPE_CTL_IBUF_RADDR_T2   10
//0b01011               // Cheop IBUF texture 3
#define NV_GR3D_VPE_CTL_IBUF_RADDR_T3   11
//0b01100               // Cheop IBUF texture 4
#define NV_GR3D_VPE_CTL_IBUF_RADDR_T4   12
//0b01101               // Cheop IBUF texture 5
#define NV_GR3D_VPE_CTL_IBUF_RADDR_T5   13
//0b01110               // Cheop IBUF texture 6
#define NV_GR3D_VPE_CTL_IBUF_RADDR_T6   14
//0b01111               // Cheop IBUF texture 7
#define NV_GR3D_VPE_CTL_IBUF_RADDR_T7   15
// Multiplier opcodes
//0b00000
#define NV_GR3D_VPE_CTL_MUL_OP_MULT     0
//0b00001
#define NV_GR3D_VPE_CTL_MUL_OP_DIST     1
//0b00010
#define NV_GR3D_VPE_CTL_MUL_OP_PASA     2
//0b00011
#define NV_GR3D_VPE_CTL_MUL_OP_MULP     3
//0b00100               
#define NV_GR3D_VPE_CTL_MUL_OP_MIN      4
//0b00101               
#define NV_GR3D_VPE_CTL_MUL_OP_MAX      5
//0b00110               
#define NV_GR3D_VPE_CTL_MUL_OP_SLT      6
//0b00111               
#define NV_GR3D_VPE_CTL_MUL_OP_SGE      7
//0b01000               
#define NV_GR3D_VPE_CTL_MUL_OP_FLR      8
//0b01001               
#define NV_GR3D_VPE_CTL_MUL_OP_FRC      9
//0b01010               
#define NV_GR3D_VPE_CTL_MUL_OP_SEQ      10
//0b01011               
#define NV_GR3D_VPE_CTL_MUL_OP_SFL      11
//0b01100               
#define NV_GR3D_VPE_CTL_MUL_OP_SNE      12
//0b01101               
#define NV_GR3D_VPE_CTL_MUL_OP_SSG      13
//0b01110               
#define NV_GR3D_VPE_CTL_MUL_OP_STR      14
//0b01111               
#define NV_GR3D_VPE_CTL_MUL_OP_SGT      15
//0b10000               
#define NV_GR3D_VPE_CTL_MUL_OP_SLE      16
// Adder opcodes
//0b000         // x=x_a+x_b; y=y_a+y_b; z=z_a+z_b; w=w_a+w_b ( 4 x 1 add)
#define NV_GR3D_VPE_CTL_ADD_OP_ADDT     0
//0b010         // x=x_b+y_b+z_b; y=x_b+y_b+z_b; z=x_b+y_b+z_b; w=x_b+y_b+z_b  (3-to-1 adds)
#define NV_GR3D_VPE_CTL_ADD_OP_SUM3     2
//0b011         // x=x_b+y_b+z_b+w_b; y=x_b+y_b+z_b+w_b; z=x_b+y_b+z_b+w_b; w=x_b+y_b+z_b+w_b
#define NV_GR3D_VPE_CTL_ADD_OP_SUM4     3
//0b101         // x=x_a; y=y_a; z=z_a; w=w_a
#define NV_GR3D_VPE_CTL_ADD_OP_PASA     5
//0b110         // x=x_b; y=y_b; z=z_b; w=w_b
#define NV_GR3D_VPE_CTL_ADD_OP_PASB     6
// SCA opcodes
//0b0000                // nop
#define NV_GR3D_VPE_CTL_SCA_OP_NOP      0
//0b0001                // o=1.0/a
#define NV_GR3D_VPE_CTL_SCA_OP_INV      1
//0b0010                // o=1.0/a with a defined max and min
#define NV_GR3D_VPE_CTL_SCA_OP_CINV     2
//0b0011                // o=1.0/sqrt(a)
#define NV_GR3D_VPE_CTL_SCA_OP_ISQ      3
//0b0100                // pass vector
#define NV_GR3D_VPE_CTL_SCA_OP_MOV      4
//0b0101                // o=2**a
#define NV_GR3D_VPE_CTL_SCA_OP_EXP      5
//0b0110                // o=log2(a)
#define NV_GR3D_VPE_CTL_SCA_OP_LOG      6
//0b0111                // o=a**x
#define NV_GR3D_VPE_CTL_SCA_OP_PWR      7
//0b1000                // o=sin(x)
#define NV_GR3D_VPE_CTL_SCA_OP_SIN      8
//0b1001                // o=cos(x)
#define NV_GR3D_VPE_CTL_SCA_OP_COS      9
//0b1010                // o=x**2
#define NV_GR3D_VPE_CTL_SCA_OP_EX2      10
//0b1011                // o=log2x
#define NV_GR3D_VPE_CTL_SCA_OP_LG2      11
// REG mask
// Write W
#define NV_GR3D_VPE_CTL_REG_WMSK_W      0
// Write Z
#define NV_GR3D_VPE_CTL_REG_WMSK_Z      1
// Write Y
#define NV_GR3D_VPE_CTL_REG_WMSK_Y      2
// Write X
#define NV_GR3D_VPE_CTL_REG_WMSK_X      3
// RAM mask
// Write W
#define NV_GR3D_VPE_CTL_RAM_WMSK_W      0
// Write Z
#define NV_GR3D_VPE_CTL_RAM_WMSK_Z      1
// Write Y
#define NV_GR3D_VPE_CTL_RAM_WMSK_Y      2
// Write X
#define NV_GR3D_VPE_CTL_RAM_WMSK_X      3
// WT buffer types (indexed-addressing)
// Tag location for UC0, UC1, UC2
#define NV_GR3D_VPE_UC012_TAG   5
// Tag location for UC3, UC4, UC5
#define NV_GR3D_VPE_UC345_TAG   6
// Obuf types 
// position
#define NV_GR3D_VPE_OBUF_POS    0
// back diffuse color
#define NV_GR3D_VPE_OBUF_BDIFF  1
// back specular color
#define NV_GR3D_VPE_OBUF_BSPEC  2
// front diffuse color
#define NV_GR3D_VPE_OBUF_DIFF   3
// front specular color
#define NV_GR3D_VPE_OBUF_SPEC   4
// Fog/PS/UserClip 0-1
#define NV_GR3D_VPE_OBUF_FPU    5
// UserClip 2-5
#define NV_GR3D_VPE_OBUF_UCP    6
// -- nv30 relic for 1/w --
#define NV_GR3D_VPE_OBUF_RSVD   7
// texture 0
#define NV_GR3D_VPE_OBUF_T0     8
// texture 1
#define NV_GR3D_VPE_OBUF_T1     9
// texture 2
#define NV_GR3D_VPE_OBUF_T2     10
// texture 3
#define NV_GR3D_VPE_OBUF_T3     11
// texture 4
#define NV_GR3D_VPE_OBUF_T4     12
// texture 5
#define NV_GR3D_VPE_OBUF_T5     13
// texture 6 
#define NV_GR3D_VPE_OBUF_T6     14
// texture 7
#define NV_GR3D_VPE_OBUF_T7     15
// -- nv30 relic for Fog/W --
#define NV_GR3D_VPE_OBUF_FOGW   16
// User Clip 0
#define NV_GR3D_VPE_OBUF_UC0    17
// User Clip 1
#define NV_GR3D_VPE_OBUF_UC1    18
// User Clip 2
#define NV_GR3D_VPE_OBUF_UC2    19
// User Clip 3
#define NV_GR3D_VPE_OBUF_UC3    20
// User Clip 4
#define NV_GR3D_VPE_OBUF_UC4    21
// User Clip 5
#define NV_GR3D_VPE_OBUF_UC5    22
// FOG
#define NV_GR3D_VPE_OBUF_FOG    23
// Point Size
#define NV_GR3D_VPE_OBUF_PS     24
// Obuf buffer not-valid
#define NV_GR3D_VPE_OBUF_NOP    31
/////////////////////////////////////////////// obsolete defines //////////////////////////////////////////
// position -- delete this one --
#define NV_GR3D_VPE_CTL_OBUF_POS        0
// back diffuse color
#define NV_GR3D_VPE_OBUF_C2     1
// back specular color
#define NV_GR3D_VPE_OBUF_C3     2
// front diffuse color
#define NV_GR3D_VPE_OBUF_C0     3
// front specular color
#define NV_GR3D_VPE_OBUF_C1     4
// 0: ctx;  1: o-buffer
#define XF_INSTR_OUT_TYPE_FIELD 11
// Opcode field width
// Opcode field width
#define XF_INSTR_OPCODE_WIDTH   10
// Operand field width
// cheop ctx ram address width  nv25?
#define XF_INSTR_CTX_WIDTH      8
// ibuf address width  nv25?
#define XF_INSTR_IBUF_WIDTH     4
// Operand RA field width  nv25?
#define XF_INSTR_RA_WIDTH       4
// Operand RB field width  nv25?
#define XF_INSTR_RB_WIDTH       4
// Operand RC field width  nv25?
#define XF_INSTR_RC_WIDTH       4
// Destination RT field width  nv25?
#define XF_INSTR_RT_WIDTH       4
// Destination buffer/ctx field width  nv25?
#define XF_INSTR_OUT_WIDTH      9
// Operand type
// Context 
#define XF_INSTR_OPR_TYPE_CTX   3
// I-buffer
#define XF_INSTR_OPR_TYPE_BUF   2
// Register 
#define XF_INSTR_OPR_TYPE_REG   1
// operand not used
#define XF_INSTR_OPR_TYPE_INVAL 0
// position shadow for operand C
#define XF_INSTR_OPR_TYPE_POS   0
// Operand extract type (per component output)
// select x_in
#define XF_INSTR_EXTR_X 0
// select y_in
#define XF_INSTR_EXTR_Y 1
// select z_in
#define XF_INSTR_EXTR_Z 2
// select w_in
#define XF_INSTR_EXTR_W 3
// Opcode field width
// Opcode field width
#define XF_INSTR_OPCODE_WIDTH   10
// Operand field width
// cheop ctx ram address width  nv25?
#define XF_INSTR_CTX_WIDTH      8
// ibuf address width  nv25?
#define XF_INSTR_IBUF_WIDTH     4
// Operand RA field width  nv25?
#define XF_INSTR_RA_WIDTH       4
// Operand RB field width  nv25?
#define XF_INSTR_RB_WIDTH       4
// Operand RC field width  nv25?
#define XF_INSTR_RC_WIDTH       4
// Operand extract field width  nv25?
#define XF_INSTR_EXTR_WIDTH     2
// Destination RT field width  nv25?
#define XF_INSTR_RT_WIDTH       4
// Destination buffer/ctx field width  nv25?
#define XF_INSTR_OUT_WIDTH      9
//Compare functions:
//
// CLM - note these had #define CC_FALSE|XF_INSTR_CC_FALSE 0
// I assume vmod doesn't use the first one.
#define XF_INSTR_CC_FALSE       0
#define XF_INSTR_CC_LT  1
#define XF_INSTR_CC_LT  1
#define XF_INSTR_CC_EQ  2
#define XF_INSTR_CC_LE  3
#define XF_INSTR_CC_GT  4
#define XF_INSTR_CC_NE  5
#define XF_INSTR_CC_GE  6
#define XF_INSTR_CC_TRUE        7
//MLU ALU opcodes:
// NOP,  NOP
#define XF_V_NOP        0
// PASA, PASB
#define XF_V_MOV        1
// MULT, PASB
#define XF_V_MUL        2
// PASA, ADD
#define XF_V_ADD        3
// MULT, ADD
#define XF_V_MAD        4
// MULT, SUM3
#define XF_V_DP3        5
// MULB, SUM4
#define XF_V_DPH        6
// MULT, SUM4
#define XF_V_DP4        7
// DIS,  PASB
#define XF_V_DST        8
// MIN,  PASB
#define XF_V_MIN        9
// MAX,  PASB
#define XF_V_MAX        10
// SLE,  PASB
#define XF_V_SLT        11
// SGE,  PASB
#define XF_V_SGE        12
// address register load (floor)
#define XF_V_ARL        13
// FRC,  PASB
#define XF_V_FRC        14
// FLR,  PASB
#define XF_V_FLR        15
// SEQ,  PASB
#define XF_V_SEQ        16
// SFL,  PASB
#define XF_V_SFL        17
// SGT,  PASB
#define XF_V_SGT        18
// SLE,  PASB
#define XF_V_SLE        19
// SNE,  PASB
#define XF_V_SNE        20
// STR,  PASB 
#define XF_V_STR        21
// SSG,  PASB
#define XF_V_SSG        22
// address register load (round)
#define XF_V_ARR        23
// address register move
#define XF_V_MVA        24
// reserved
#define XF_V_RSV0       25
// reserved
#define XF_V_RSV1       26
// reserved
#define XF_V_RSV2       27
// reserved
#define XF_V_RSV3       28
// reserved
#define XF_V_RSV4       29
// reserved
#define XF_V_RSV5       30
// reserved
#define XF_V_RSV6       31
//ILU opcodes:
#define XF_S_NOP        0
#define XF_S_MOV        1
// reciprocal
#define XF_S_RCP        2
// clamped reciprocal
#define XF_S_RCC        3
// reciprocal square root
#define XF_S_RSQ        4
#define XF_S_EXP        5
#define XF_S_LOG        6
#define XF_S_LIT        7
// branch on address reg
#define XF_S_BRA        8
// branch immediate
#define XF_S_BRI        9
// call   on address reg 
#define XF_S_CLA        10
// call   immediate
#define XF_S_CLI        11
// return
#define XF_S_RET        12
#define XF_S_LG2        13
#define XF_S_EX2        14
#define XF_S_SIN        15
#define XF_S_COS        16
// reserved
#define XF_S_RSV0       17
// reserved
#define XF_S_RSV1       18
// reserved
#define XF_S_RSV2       19
// reserved
#define XF_S_RSV3       20
// reserved
#define XF_S_RSV4       21
// reserved
#define XF_S_RSV5       22
// reserved
#define XF_S_RSV6       23
// reserved
#define XF_S_RSV7       24
// reserved
#define XF_S_RSV8       25
// reserved
#define XF_S_RSV9       26
// reserved
#define XF_S_RSVa       27
// reserved
#define XF_S_RSVb       28
// reserved
#define XF_S_RSVc       29
// reserved
#define XF_S_RSVd       30
// reserved
#define XF_S_RSVe       31
// 
// Program and thread management
//
// Number of bits in a bundle address.
#define NV_GR3D_VPE_BUNDLE_ADDR_BITS    9
// IO BUS Width
// Sideband's launch width
#define NV_GR3D_VPE_XFCMD_WIDTH 5
#define NV_GR3D_VPE_CICO_BUS_WIDTH      65
#define NV_GR3D_VPE_CTX_CURIE_USER      512
#define NV_GR3D_VPE_CTX_CURIE_PRIV      32
//#define NV_GR3D_VPE_CTX_CURIE_SIZE  NV_GR3D_VPE_CTX_CURIE_USER + NV_GR3D_VPE_CTX_CURIE_PRIV ;
#define NV_GR3D_VPE_CTX_CURIE_SIZE      256
#define NV_GR3D_VPE_AR_INDEX_BITS       11
#define NV_GR3D_VPE_OFF_REG_WIDTH       44
// Issue window size  nv25?
#define NV_GR3D_VPE_ISSUE_WINDOW_SIZE   2
// Obuf buffer not-valid
#define NV_GR3D_VPE_OBUF_NOP    31
#define VPE_4X_INSTR_WIDTH      127
#define VPE_4X_INSTR_CTX_ADDR_WIDTH     10
#define VPE_4X_INSTR_RT_ADDR_WIDTH      6
#define VPE_4X_INSTR_OPCODE_V_WIDTH     5
#define VPE_4X_INSTR_OPCODE_S_WIDTH     5
#define VPE_4X_INSTR_SEL_SCALAR 0
#define VPE_4X_INSTR_LAST_LSB   0
#define VPE_4X_INSTR_RC_MSB     28
#define VPE_4X_INSTR_RC_LSB     23
// from geometry_if ATTR_BITS   BITS(NUM_ATTR), derek
#define NV_GR3D_VPE_ATTR_BITS   4
// branch stack size
#define NV_GR3D_VPE_STACK_SIZE  8
#define NV_GR3D_VPE_STACK_ADDR_BITS     3
// branch stack size for Rankine Class
#define NV_GR3D_VPE_RANKINE_STACK_SIZE  4
// for IDX-VPE read back channel address bus
#define NV_GR3D_VPE_READ_ADDR_BITS      9
#define NV_GR3D_VPE_READ_DATA_WIDTH     128
///////////////////////////////////////////////////////////////////////////////////////////////////////////

//
// AR3D ADDRESS SPACES
//

#define LIST_AR3D_ADDRESS_SPACES(_) \
_(AR3D_CTL,0x00000000) \
_(AR3D_IDX,0x00000100) \
_(AR3D_VPE,0x00000200) \
_(AR3D_SU,0x00000300) \
_(AR3D_QR,0x00000400) \
_(AR3D_PSEQ,0x00000500) \
_(AR3D_AT,0x00000600) \
_(AR3D_TEX,0x00000700) \
_(AR3D_ALU,0x00000800) \
_(AR3D_DW,0x00000900) \
_(AR3D_FDC,0x00000a00) \
_(AR3D_GLOBAL,0x00000e00)
#define BASE_ADDRESS_AR3D_CTL   0x00000000
#define BASE_ADDRESS_AR3D_IDX   0x00000100
#define BASE_ADDRESS_AR3D_VPE   0x00000200
#define BASE_ADDRESS_AR3D_SU    0x00000300
#define BASE_ADDRESS_AR3D_QR    0x00000400
#define BASE_ADDRESS_AR3D_PSEQ  0x00000500
#define BASE_ADDRESS_AR3D_AT    0x00000600
#define BASE_ADDRESS_AR3D_TEX   0x00000700
#define BASE_ADDRESS_AR3D_ALU   0x00000800
#define BASE_ADDRESS_AR3D_DW    0x00000900
#define BASE_ADDRESS_AR3D_FDC   0x00000a00
#define BASE_ADDRESS_AR3D_GLOBAL        0x00000e00

//
// AR3D_CTL REGISTERS
//

#define LIST_AR3D_CTL_REGS(_) \
_(AR3D_CTL,INCR_SYNCPT,REG) \
_(AR3D_CTL,INCR_SYNCPT_CNTRL,REG) \
_(AR3D_CTL,INCR_SYNCPT_ERROR,REG) \
_(AR3D_CTL,INTSTATUS,REG) \
_(AR3D_CTL,INTENABLE,REG) \
_(AR3D_CTL,CTXSW,REG) \
_(AR3D_CTL,STAT,ARY) \
_(AR3D_CTL,STAT_CLK_COUNT,ARY) \
_(AR3D_CTL,STAT_XFER_COUNT,ARY) \
_(AR3D_CTL,STAT_WAIT_COUNT,ARY) \
_(AR3D_CTL,STAT_EN_COUNT,ARY)

//
// AR3D_IDX REGISTERS
//

#define LIST_AR3D_IDX_REGS(_) \
_(AR3D_IDX,ATTRIBUTE,ARY) \
_(AR3D_IDX,ATTR_MASK,REG) \
_(AR3D_IDX,INDEX_BASE,REG) \
_(AR3D_IDX,SET_PRIM,REG) \
_(AR3D_IDX,DRAW_PRIM,REG) \
_(AR3D_IDX,IDX_CTL,REG) \
_(AR3D_IDX,IDX_STAT,REG) \
_(AR3D_IDX,NV_MCCIF_FIFOCTRL_RO,REG)

//
// AR3D_VPE REGISTERS
//

#define LIST_AR3D_VPE_REGS(_) \
_(AR3D_VPE,MODE,REG) \
_(AR3D_VPE,TIMEOUT,REG) \
_(AR3D_VPE,CONST_READ_LIMIT,REG) \
_(AR3D_VPE,BRANCHBITS,REG) \
_(AR3D_VPE,START,REG) \
_(AR3D_VPE,INST_OFFSET,REG) \
_(AR3D_VPE,INST_DATA,REG) \
_(AR3D_VPE,CONST_OFFSET,REG) \
_(AR3D_VPE,CONST_DATA,REG) \
_(AR3D_VPE,GEOM_STALL,REG) \
_(AR3D_VPE,VPE_CTRL,REG) \
_(AR3D_VPE,VPE_DEBUG,REG)

//
// AR3D_SU REGISTERS
//

#define LIST_AR3D_SU_REGS(_) \
_(AR3D_SU,INST,ARY) \
_(AR3D_SU,DRAW_POINT,REG) \
_(AR3D_SU,DRAW_LINE,REG) \
_(AR3D_SU,DRAW_TRI,REG) \
_(AR3D_SU,PARAM,REG) \
_(AR3D_SU,ZBIAS,REG) \
_(AR3D_SU,ZFACTOR,REG) \
_(AR3D_SU,POINT_PARAM,REG) \
_(AR3D_SU,POINT_WIDTH_2,REG) \
_(AR3D_SU,POINT_MAX_S,REG) \
_(AR3D_SU,POINT_MAX_T,REG) \
_(AR3D_SU,POINT_MIN_S,REG) \
_(AR3D_SU,POINT_MIN_T,REG) \
_(AR3D_SU,LINE_PARAM,REG) \
_(AR3D_SU,LINE_WIDTH_2,REG) \
_(AR3D_SU,LINE_MAX_ATTR_W,REG) \
_(AR3D_SU,LINE_MIN_ATTR_W,REG) \
_(AR3D_SU,SCISSOR_X,REG) \
_(AR3D_SU,SCISSOR_Y,REG) \
_(AR3D_SU,VIEWPORT_X,REG) \
_(AR3D_SU,VIEWPORT_Y,REG) \
_(AR3D_SU,VIEWPORT_Z,REG) \
_(AR3D_SU,VIEWPORT_W,REG) \
_(AR3D_SU,VIEWPORT_H,REG) \
_(AR3D_SU,VIEWPORT_D,REG) \
_(AR3D_SU,GUARDBAND_W,REG) \
_(AR3D_SU,GUARDBAND_H,REG) \
_(AR3D_SU,GUARDBAND_D,REG) \
_(AR3D_SU,UCPLANE,ARY) \
_(AR3D_SU,CLKEN_OVERRIDE,REG) \
_(AR3D_SU,CLIP_CLKEN_OVERRIDE,REG)

//
// AR3D_QR REGISTERS
//

#define LIST_AR3D_QR_REGS(_) \
_(AR3D_QR,S_TEST,ARY) \
_(AR3D_QR,S_CTRL,REG) \
_(AR3D_QR,Z_TEST,REG) \
_(AR3D_QR,Z_MIN,REG) \
_(AR3D_QR,Z_MAX,REG) \
_(AR3D_QR,RAST_OPERATION,REG) \
_(AR3D_QR,RAST_SCISSOR_SNAP,REG) \
_(AR3D_QR,RAST_SCISSOR_MIN,REG) \
_(AR3D_QR,RAST_SCISSOR_MAX,REG) \
_(AR3D_QR,RAST_BBOX_MIN,REG) \
_(AR3D_QR,RAST_BBOX_MAX,REG) \
_(AR3D_QR,SB_OPERATION,REG) \
_(AR3D_QR,QRAST_CLKEN_OVERRIDE,REG) \
_(AR3D_QR,VCAA_OPERATION,REG) \
_(AR3D_QR,OUTPUT_TO_SHADER,REG) \
_(AR3D_QR,QRAST_DEBUG,REG) \
_(AR3D_QR,QRAST_LIMITS,REG)

//
// AR3D_PSEQ REGISTERS
//

#define LIST_AR3D_PSEQ_REGS(_) \
_(AR3D_PSEQ,FLUSH,REG) \
_(AR3D_PSEQ,CTL,REG) \
_(AR3D_PSEQ,TIMEOUT,REG) \
_(AR3D_PSEQ,PC,REG) \
_(AR3D_PSEQ,COMMAND,ARY) \
_(AR3D_PSEQ,INST_OFFSET,REG) \
_(AR3D_PSEQ,INST_DATA,REG) \
_(AR3D_PSEQ,DBG_X,REG) \
_(AR3D_PSEQ,DBG_Y,REG) \
_(AR3D_PSEQ,DBG_CTL,REG) \
_(AR3D_PSEQ,QUAD_ID,REG) \
_(AR3D_PSEQ,DWR_IF_STATE,REG)

//
// AR3D_AT REGISTERS
//

#define LIST_AR3D_AT_REGS(_) \
_(AR3D_AT,REMAP_OFFSET,REG) \
_(AR3D_AT,REMAP_DATA,REG) \
_(AR3D_AT,REMAP_DATA_4X,REG) \
_(AR3D_AT,INST_OFFSET,REG) \
_(AR3D_AT,INST_DATA,REG) \
_(AR3D_AT,CONSTANT0,ARY) \
_(AR3D_AT,TRAM_OFFSET,REG) \
_(AR3D_AT,TRAM_DATA,REG) \
_(AR3D_AT,CLKEN_OVERRIDE,REG)

//
// AR3D_TEX REGISTERS
//

#define LIST_AR3D_TEX_REGS(_) \
_(AR3D_TEX,INST_OFFSET,REG) \
_(AR3D_TEX,INST_DATA,REG) \
_(AR3D_TEX,COLORKEY,REG) \
_(AR3D_TEX,TEXADDR,ARY) \
_(AR3D_TEX,TEXDESC,ARY) \
_(AR3D_TEX,TEXCTL,REG) \
_(AR3D_TEX,CLKEN_OVERRIDE,REG) \
_(AR3D_TEX,NV_MCCIF_FIFOCTRL_RO,REG)

//
// AR3D_ALU REGISTERS
//

#define LIST_AR3D_ALU_REGS(_) \
_(AR3D_ALU,REMAP_OFFSET,REG) \
_(AR3D_ALU,REMAP_DATA,REG) \
_(AR3D_ALU,REMAP_DATA_4X,REG) \
_(AR3D_ALU,INST_OFFSET,REG) \
_(AR3D_ALU,INST_DATA,REG) \
_(AR3D_ALU,P2CX_OFFSET,REG) \
_(AR3D_ALU,P2CX_DATA,REG) \
_(AR3D_ALU,GLOBALS,ARY)

//
// AR3D_DW REGISTERS
//

#define LIST_AR3D_DW_REGS(_) \
_(AR3D_DW,INST_OFFSET,REG) \
_(AR3D_DW,INST_DATA,REG) \
_(AR3D_DW,LOGIC_OP,REG) \
_(AR3D_DW,ST_ENABLE,REG)

//
// AR3D_FDC REGISTERS
//

#define LIST_AR3D_FDC_REGS(_) \
_(AR3D_FDC,CONTROL,REG) \
_(AR3D_FDC,STATUS,REG) \
_(AR3D_FDC,MAX_QZ_LINES,REG) \
_(AR3D_FDC,MAX_QV_LINES,REG) \
_(AR3D_FDC,MAX_QS_LINES,REG) \
_(AR3D_FDC,MAX_PS_LINES,REG) \
_(AR3D_FDC,MAX_Q_LINES,REG) \
_(AR3D_FDC,MAX_Q_P_LINES,REG) \
_(AR3D_FDC,FLUSH_CTL,REG) \
_(AR3D_FDC,L1_TIMEOUT,REG) \
_(AR3D_FDC,INSTRUMENT,REG) \
_(AR3D_FDC,CLKEN_OVERRIDE,REG) \
_(AR3D_FDC,NV_MCCIF_FIFOCTRL_RO,REG)

//
// AR3D_GLOBAL REGISTERS
//

#define LIST_AR3D_GLOBAL_REGS(_) \
_(AR3D_GLOBAL,SURFADDR,ARY) \
_(AR3D_GLOBAL,SURFDESC,ARY) \
_(AR3D_GLOBAL,PIX_ATTR,REG) \
_(AR3D_GLOBAL,TRI_ATTR,REG) \
_(AR3D_GLOBAL,INST_OFFSET,REG) \
_(AR3D_GLOBAL,RAISE,REG) \
_(AR3D_GLOBAL,REFCNT,REG) \
_(AR3D_GLOBAL,INSTRUMENT,REG) \
_(AR3D_GLOBAL,DITHER_TABLE,REG) \
_(AR3D_GLOBAL,FLUSH,REG) \
_(AR3D_GLOBAL,S_OPERATION,ARY) \
_(AR3D_GLOBAL,SPILLSURFADDR,REG) \
_(AR3D_GLOBAL,NV_MCCIF_FIFOCTRL,REG)

//
// ACCESS MACROS
//

#define _REG_base(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _base
#define REG_base(_x) REG_##_x(_REG_base)
#define _REG_rnam(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _rnam
#define REG_rnam(_x) REG_##_x(_REG_rnam)
#define _REG_addr(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _addr
#define REG_addr(_x) REG_##_x(_REG_addr)
#define _REG_off(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _off
#define REG_off(_x) REG_##_x(_REG_off)
#define _REG_asiz(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _asiz
#define REG_asiz(_x) REG_##_x(_REG_asiz)
#define _REG_size(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _size
#define REG_size(_x) REG_##_x(_REG_size)
#define _REG_mask(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _mask
#define REG_mask(_x) REG_##_x(_REG_mask)
#define _REG_rstv(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _rstv
#define REG_rstv(_x) REG_##_x(_REG_rstv)
#define _REG_arry(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _arry
#define REG_arry(_x) REG_##_x(_REG_arry)
#define _REG_flds(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _flds
#define REG_flds(_x) REG_##_x(_REG_flds)

#define _RAM_base(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _base
#define RAM_base(_x) RAM_##_x(_RAM_base)
#define _RAM_rnam(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _rnam
#define RAM_rnam(_x) RAM_##_x(_RAM_rnam)
#define _RAM_addr(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _addr
#define RAM_addr(_x) RAM_##_x(_RAM_addr)
#define _RAM_off(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _off
#define RAM_off(_x) RAM_##_x(_RAM_off)
#define _RAM_asiz(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _asiz
#define RAM_asiz(_x) RAM_##_x(_RAM_asiz)
#define _RAM_size(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _size
#define RAM_size(_x) RAM_##_x(_RAM_size)
#define _RAM_mask(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _mask
#define RAM_mask(_x) RAM_##_x(_RAM_mask)
#define _RAM_rstv(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _rstv
#define RAM_rstv(_x) RAM_##_x(_RAM_rstv)
#define _RAM_arry(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _arry
#define RAM_arry(_x) RAM_##_x(_RAM_arry)
#define _RAM_flds(_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_arry,_flds) _flds
#define RAM_flds(_x) RAM_##_x(_RAM_flds)

#define _REG_FLD_base(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _base
#define REG_FLD_base(_x) REG_FLD_##_x(_REG_FLD_base)
#define _REG_FLD_rnam(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _rnam
#define REG_FLD_rnam(_x) REG_FLD_##_x(_REG_FLD_rnam)
#define _REG_FLD_fnam(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _fnam
#define REG_FLD_fnam(_x) REG_FLD_##_x(_REG_FLD_fnam)
#define _REG_FLD_fsiz(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _fsiz
#define REG_FLD_fsiz(_x) REG_FLD_##_x(_REG_FLD_fsiz)
#define _REG_FLD_msb(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _msb
#define REG_FLD_msb(_x) REG_FLD_##_x(_REG_FLD_msb)
#define _REG_FLD_lsb(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _lsb
#define REG_FLD_lsb(_x) REG_FLD_##_x(_REG_FLD_lsb)
#define _REG_FLD_read(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _read
#define REG_FLD_read(_x) REG_FLD_##_x(_REG_FLD_read)
#define _REG_FLD_mask(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _mask
#define REG_FLD_mask(_x) REG_FLD_##_x(_REG_FLD_mask)
#define _REG_FLD_rstv(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _rstv
#define REG_FLD_rstv(_x) REG_FLD_##_x(_REG_FLD_rstv)
#define _REG_FLD_renm(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _renm
#define REG_FLD_renm(_x) REG_FLD_##_x(_REG_FLD_renm)
#define _REG_FLD_enum(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _enum
#define REG_FLD_enum(_x) REG_FLD_##_x(_REG_FLD_enum)

#define _RAM_FLD_base(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _base
#define RAM_FLD_base(_x) RAM_FLD_##_x(_RAM_FLD_base)
#define _RAM_FLD_rnam(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _rnam
#define RAM_FLD_rnam(_x) RAM_FLD_##_x(_RAM_FLD_rnam)
#define _RAM_FLD_fnam(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _fnam
#define RAM_FLD_fnam(_x) RAM_FLD_##_x(_RAM_FLD_fnam)
#define _RAM_FLD_fsiz(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _fsiz
#define RAM_FLD_fsiz(_x) RAM_FLD_##_x(_RAM_FLD_fsiz)
#define _RAM_FLD_msb(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _msb
#define RAM_FLD_msb(_x) RAM_FLD_##_x(_RAM_FLD_msb)
#define _RAM_FLD_lsb(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _lsb
#define RAM_FLD_lsb(_x) RAM_FLD_##_x(_RAM_FLD_lsb)
#define _RAM_FLD_read(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _read
#define RAM_FLD_read(_x) RAM_FLD_##_x(_RAM_FLD_read)
#define _RAM_FLD_mask(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _mask
#define RAM_FLD_mask(_x) RAM_FLD_##_x(_RAM_FLD_mask)
#define _RAM_FLD_rstv(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _rstv
#define RAM_FLD_rstv(_x) RAM_FLD_##_x(_RAM_FLD_rstv)
#define _RAM_FLD_renm(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _renm
#define RAM_FLD_renm(_x) RAM_FLD_##_x(_RAM_FLD_renm)
#define _RAM_FLD_enum(_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_mask,_rstv,_renm,_enum) _enum
#define RAM_FLD_enum(_x) RAM_FLD_##_x(_RAM_FLD_enum)

#define _PKT_pnam(_pnam,_size,_flds) _pnam
#define PKT_pnam(_x) PKT_##_x(_PKT_pnam)
#define _PKT_size(_pnam,_size,_flds) _size
#define PKT_size(_x) PKT_##_x(_PKT_size)
#define _PKT_flds(_pnam,_size,_flds) _flds
#define PKT_flds(_x) PKT_##_x(_PKT_flds)

#define _PKT_FLD_pnam(_pnam,_fnam,_row,_fsiz,_msb,_lsb,_mask,_enum) _pnam
#define PKT_FLD_pnam(_x) PKT_FLD_##_x(_PKT_FLD_pnam)
#define _PKT_FLD_fnam(_pnam,_fnam,_row,_fsiz,_msb,_lsb,_mask,_enum) _fnam
#define PKT_FLD_fnam(_x) PKT_FLD_##_x(_PKT_FLD_fnam)
#define _PKT_FLD_row(_pnam,_fnam,_row,_fsiz,_msb,_lsb,_mask,_enum) _row
#define PKT_FLD_row(_x) PKT_FLD_##_x(_PKT_FLD_row)
#define _PKT_FLD_fsiz(_pnam,_fnam,_row,_fsiz,_msb,_lsb,_mask,_enum) _fsiz
#define PKT_FLD_fsiz(_x) PKT_FLD_##_x(_PKT_FLD_fsiz)
#define _PKT_FLD_msb(_pnam,_fnam,_row,_fsiz,_msb,_lsb,_mask,_enum) _msb
#define PKT_FLD_msb(_x) PKT_FLD_##_x(_PKT_FLD_msb)
#define _PKT_FLD_lsb(_pnam,_fnam,_row,_fsiz,_msb,_lsb,_mask,_enum) _lsb
#define PKT_FLD_lsb(_x) PKT_FLD_##_x(_PKT_FLD_lsb)
#define _PKT_FLD_mask(_pnam,_fnam,_row,_fsiz,_msb,_lsb,_mask,_enum) _mask
#define PKT_FLD_mask(_x) PKT_FLD_##_x(_PKT_FLD_mask)
#define _PKT_FLD_enum(_pnam,_fnam,_row,_fsiz,_msb,_lsb,_mask,_enum) _enum
#define PKT_FLD_enum(_x) PKT_FLD_##_x(_PKT_FLD_enum)

#ifndef _MK_SHIFT_CONST
  #define _MK_SHIFT_CONST(_constant_) _constant_
#endif
#ifndef _MK_MASK_CONST
  #define _MK_MASK_CONST(_constant_) _constant_
#endif
#ifndef _MK_ENUM_CONST
  #define _MK_ENUM_CONST(_constant_) (_constant_ ## UL)
#endif
#ifndef _MK_ADDR_CONST
  #define _MK_ADDR_CONST(_constant_) _constant_
#endif
#endif // ifndef ___AR3D_UH_INC_
